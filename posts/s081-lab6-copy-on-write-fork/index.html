<!DOCTYPE html><html lang="en" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="generator" content="Jekyll v4.2.2" /><meta property="og:title" content="[mit6.s081] 笔记 Lab6: Copy-on-write fork fork 懒拷贝" /><meta property="og:locale" content="en" /><meta name="description" content="这是我自学 MIT6.S081 操作系统课程的 lab 代码笔记第六篇：Copy-on-write fork。此 lab 大致耗时：4小时。 课程地址：https://pdos.csail.mit.edu/6.S081/2020/schedule.html Lab 地址：https://pdos.csail.mit.edu/6.S081/2020/labs/cow.html 我的代码地址：https://github.com/Miigon/my-xv6-labs-2020/tree/cow Commits: https://github.com/Miigon/my-xv6-labs-2020/commits/cow 本文中代码注释是编写博客的时候加入的，原仓库中的代码可能缺乏注释或代码不完全相同。" /><meta property="og:description" content="这是我自学 MIT6.S081 操作系统课程的 lab 代码笔记第六篇：Copy-on-write fork。此 lab 大致耗时：4小时。 课程地址：https://pdos.csail.mit.edu/6.S081/2020/schedule.html Lab 地址：https://pdos.csail.mit.edu/6.S081/2020/labs/cow.html 我的代码地址：https://github.com/Miigon/my-xv6-labs-2020/tree/cow Commits: https://github.com/Miigon/my-xv6-labs-2020/commits/cow 本文中代码注释是编写博客的时候加入的，原仓库中的代码可能缺乏注释或代码不完全相同。" /><link rel="canonical" href="https://blog.miigon.net/posts/s081-lab6-copy-on-write-fork/" /><meta property="og:url" content="https://blog.miigon.net/posts/s081-lab6-copy-on-write-fork/" /><meta property="og:site_name" content="Miigon’s blog" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2021-10-05T15:21:00+08:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="[mit6.s081] 笔记 Lab6: Copy-on-write fork fork 懒拷贝" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2023-02-20T17:06:52+08:00","datePublished":"2021-10-05T15:21:00+08:00","description":"这是我自学 MIT6.S081 操作系统课程的 lab 代码笔记第六篇：Copy-on-write fork。此 lab 大致耗时：4小时。 课程地址：https://pdos.csail.mit.edu/6.S081/2020/schedule.html Lab 地址：https://pdos.csail.mit.edu/6.S081/2020/labs/cow.html 我的代码地址：https://github.com/Miigon/my-xv6-labs-2020/tree/cow Commits: https://github.com/Miigon/my-xv6-labs-2020/commits/cow 本文中代码注释是编写博客的时候加入的，原仓库中的代码可能缺乏注释或代码不完全相同。","headline":"[mit6.s081] 笔记 Lab6: Copy-on-write fork fork 懒拷贝","mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.miigon.net/posts/s081-lab6-copy-on-write-fork/"},"url":"https://blog.miigon.net/posts/s081-lab6-copy-on-write-fork/"}</script><title>[mit6.s081] 笔记 Lab6: Copy-on-write fork | fork 懒拷贝 | Miigon's blog</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="Miigon's blog"><meta name="application-name" content="Miigon's blog"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link rel="dns-prefetch" href="https://fonts.gstatic.com" crossorigin><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://cdn.jsdelivr.net" ><link rel="dns-prefetch" href="https://cdn.jsdelivr.net" ><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Lato&family=Source+Sans+Pro:wght@400;600;700;900&display=swap"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get MODE_ATTR() { return "data-mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } static get ID() { return "mode-toggle"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } let self = this; /* always follow the system prefers */ this.sysDarkPrefers.addEventListener("change", () => { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.notify(); }); } /* constructor() */ get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode === ModeToggle.DARK_MODE; } get isLightMode() { return this.mode === ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer)) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } setDark() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_ATTR); sessionStorage.removeItem(ModeToggle.MODE_KEY); } /* Notify another plugins that the theme mode has changed */ notify() { window.postMessage({ direction: ModeToggle.ID, message: this.modeStatus }, "*"); } } /* ModeToggle */ const toggle = new ModeToggle(); function flipMode() { if (toggle.hasMode) { if (toggle.isSysDarkPrefer) { if (toggle.isLightMode) { toggle.clearMode(); } else { toggle.setLight(); } } else { if (toggle.isDarkMode) { toggle.clearMode(); } else { toggle.setDark(); } } } else { if (toggle.isSysDarkPrefer) { toggle.setLight(); } else { toggle.setDark(); } } toggle.notify(); } /* flipMode() */ </script><body data-spy="scroll" data-target="#toc" data-topbar-visible="true"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" class="mx-auto"> <img src="/assets/img/avatar.png" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">Miigon's blog</a></div><div class="site-subtitle font-italic">My ideas, thoughts and experiences</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tag ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info-circle ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center align-items-center"> <button class="mode-toggle btn" aria-label="Switch Mode"> <i class="fas fa-adjust"></i> </button> <span class="icon-border"></span> <a href="https://github.com/Miigon" aria-label="github" target="_blank" rel="noopener"> <i class="fab fa-github-alt"></i> </a> <a href="https://twitter.com/" aria-label="twitter" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['miigon.pg','gmail.com'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="https://stackoverflow.com/users/7509248/miigon" aria-label="stack-overflow" target="_blank" rel="noopener"> <i class="fab fa-stack-overflow"></i> </a></div></div><div id="topbar-wrapper"><div id="topbar" class="container d-flex align-items-center justify-content-between h-100 pl-3 pr-3 pl-md-4 pr-md-4"> <span id="breadcrumb"> <span> <a href="/"> Home </a> </span> <span>[mit6.s081] 笔记 Lab6: Copy-on-write fork | fork 懒拷贝</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..."> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper" class="d-flex justify-content-center"><div id="main" class="container pl-xl-4 pr-xl-4"><div class="row"><div id="core-wrapper" class="col-12 col-lg-11 col-xl-9 pr-xl-4"><div class="post pl-1 pr-1 pl-md-2 pr-md-2"><h1 data-toc-skip>[mit6.s081] 笔记 Lab6: Copy-on-write fork | fork 懒拷贝</h1><div class="post-meta text-muted"> <span> Posted <em class="" data-ts="1633418460" data-df="ll" data-toggle="tooltip" data-placement="bottom"> Oct 5, 2021 </em> </span> <span> Updated <em class="" data-ts="1676884012" data-df="ll" data-toggle="tooltip" data-placement="bottom"> Feb 20, 2023 </em> </span><div class="d-flex justify-content-between"> <span> By <em> <a href="https://github.com/Miigon">Miigon</a> </em> </span><div> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="3702 words"> <em>20 min</em> read</span></div></div></div><div class="post-content"><blockquote><p>这是我自学 MIT6.S081 操作系统课程的 lab 代码笔记第六篇：Copy-on-write fork。此 lab 大致耗时：4小时。</p><p>课程地址：<a href="https://pdos.csail.mit.edu/6.S081/2020/schedule.html">https://pdos.csail.mit.edu/6.S081/2020/schedule.html</a><br /> Lab 地址：<a href="https://pdos.csail.mit.edu/6.S081/2020/labs/cow.html">https://pdos.csail.mit.edu/6.S081/2020/labs/cow.html</a><br /> 我的代码地址：<a href="https://github.com/Miigon/my-xv6-labs-2020/tree/cow">https://github.com/Miigon/my-xv6-labs-2020/tree/cow</a><br /> Commits: <a href="https://github.com/Miigon/my-xv6-labs-2020/commits/cow">https://github.com/Miigon/my-xv6-labs-2020/commits/cow</a></p><p>本文中代码注释是编写博客的时候加入的，原仓库中的代码可能缺乏注释或代码不完全相同。</p></blockquote><h1 id="lab-6-copy-on-write-fork">Lab 6: Copy-on-write fork</h1><p>COW fork() creates just a pagetable for the child, with PTEs for user memory pointing to the parent’s physical pages. COW fork() marks all the user PTEs in both parent and child as not writable. When either process tries to write one of these COW pages, the CPU will force a page fault. The kernel page-fault handler detects this case, allocates a page of physical memory for the faulting process, copies the original page into the new page, and modifies the relevant PTE in the faulting process to refer to the new page, this time with the PTE marked writeable. When the page fault handler returns, the user process will be able to write its copy of the page.</p><p>COW fork() makes freeing of the physical pages that implement user memory a little trickier. A given physical page may be referred to by multiple processes’ page tables, and should be freed only when the last reference disappears.</p><p>实现 fork 懒复制机制，在进程 fork 后，不立刻复制内存页，而是将虚拟地址指向与父进程相同的物理地址。在父子任意一方尝试对内存页进行修改时，才对内存页进行复制。 物理内存页必须保证在所有引用都消失后才能被释放，这里需要有引用计数机制。</p><h2 id="implement-copy-on-write-hard"><span class="mr-2">Implement copy-on write (hard)</span><a href="#implement-copy-on-write-hard" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><blockquote><p>为了便于区分，本文将只创建引用而不进行实际内存分配的页复制过程称为「懒复制」，将分配新的内存空间并将数据复制到其中的过程称为「实复制」</p></blockquote><h3 id="fork-时不立刻复制内存"><span class="mr-2">fork 时不立刻复制内存</span><a href="#fork-时不立刻复制内存" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>首先修改 uvmcopy()，在复制父进程的内存到子进程的时候，不立刻复制数据，而是建立指向原物理页的映射，并将父子两端的页表项都设置为不可写。</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
</pre><td class="rouge-code"><pre><span class="c1">// kernel/vm.c</span>
<span class="kt">int</span>
<span class="nf">uvmcopy</span><span class="p">(</span><span class="n">pagetable_t</span> <span class="n">old</span><span class="p">,</span> <span class="n">pagetable_t</span> <span class="n">new</span><span class="p">,</span> <span class="n">uint64</span> <span class="n">sz</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">pte_t</span> <span class="o">*</span><span class="n">pte</span><span class="p">;</span>
  <span class="n">uint64</span> <span class="n">pa</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>
  <span class="n">uint</span> <span class="n">flags</span><span class="p">;</span>

  <span class="k">for</span><span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">sz</span><span class="p">;</span> <span class="n">i</span> <span class="o">+=</span> <span class="n">PGSIZE</span><span class="p">){</span>
    <span class="k">if</span><span class="p">((</span><span class="n">pte</span> <span class="o">=</span> <span class="n">walk</span><span class="p">(</span><span class="n">old</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
      <span class="n">panic</span><span class="p">(</span><span class="s">"uvmcopy: pte should exist"</span><span class="p">);</span>
    <span class="k">if</span><span class="p">((</span><span class="o">*</span><span class="n">pte</span> <span class="o">&amp;</span> <span class="n">PTE_V</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
      <span class="n">panic</span><span class="p">(</span><span class="s">"uvmcopy: page not present"</span><span class="p">);</span>
    <span class="n">pa</span> <span class="o">=</span> <span class="n">PTE2PA</span><span class="p">(</span><span class="o">*</span><span class="n">pte</span><span class="p">);</span>
    <span class="k">if</span><span class="p">(</span><span class="o">*</span><span class="n">pte</span> <span class="o">&amp;</span> <span class="n">PTE_W</span><span class="p">)</span> <span class="p">{</span>
      <span class="c1">// 清除父进程的 PTE_W 标志位，设置 PTE_COW 标志位表示是一个懒复制页（多个进程引用同个物理页）</span>
      <span class="o">*</span><span class="n">pte</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">pte</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">PTE_W</span><span class="p">)</span> <span class="o">|</span> <span class="n">PTE_COW</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">flags</span> <span class="o">=</span> <span class="n">PTE_FLAGS</span><span class="p">(</span><span class="o">*</span><span class="n">pte</span><span class="p">);</span>
    <span class="c1">// 将父进程的物理页直接 map 到子进程 （懒复制）</span>
    <span class="c1">// 权限设置和父进程一致</span>
    <span class="c1">// （不可写+PTE_COW，或者如果父进程页本身单纯只读非 COW，则子进程页同样只读且无 COW 标识）</span>
    <span class="k">if</span><span class="p">(</span><span class="n">mappages</span><span class="p">(</span><span class="n">new</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">PGSIZE</span><span class="p">,</span> <span class="p">(</span><span class="n">uint64</span><span class="p">)</span><span class="n">pa</span><span class="p">,</span> <span class="n">flags</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">){</span>
      <span class="k">goto</span> <span class="n">err</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="c1">// 将物理页的引用次数增加 1</span>
    <span class="n">krefpage</span><span class="p">((</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">pa</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

 <span class="nl">err:</span>
  <span class="n">uvmunmap</span><span class="p">(</span><span class="n">new</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">i</span> <span class="o">/</span> <span class="n">PGSIZE</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
  <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

</pre></table></code></div></div><blockquote><p>UPDATE 2023-02-20: 上述代码一开始的版本没有考虑只读页的拷贝，会导致单纯的非 COW 只读页被错误标记为 COW 页从而变成可写。<br /> 这里给出的代码<a href="https://github.com/Miigon/my-xv6-labs-2020/commit/c119f033881ffe19f4000d0149043e717304f659">已经修复该问题</a>，感谢 <a href="https://github.com/zztaki">@zztaki</a> 指出该问题。<br /> 修复后，只读页会直接共享物理页，并参与引用计数，但是不会被打上 COW 标记。</p></blockquote><p>上面用到了 PTE_COW 标志位，用于标示一个映射对应的物理页是否是懒复制页。这里 PTE_COW 需要在 riscv.h 中定义：</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="c1">// kernel/riscv.h</span>
<span class="cp">#define PTE_V (1L &lt;&lt; 0) // valid
#define PTE_R (1L &lt;&lt; 1)
#define PTE_W (1L &lt;&lt; 2)
#define PTE_X (1L &lt;&lt; 3)
#define PTE_U (1L &lt;&lt; 4) // 1 -&gt; user can access
#define PTE_COW (1L &lt;&lt; 8) // 是否为懒复制页，使用页表项 flags 中保留的第 8 位表示
</span><span class="c1">// （页表项 flags 中，第 8、9、10 位均为保留给操作系统使用的位，可以用作任意自定义用途）</span>
</pre></table></code></div></div><p>这样，fork 时就不会立刻复制内存，只会创建一个映射了。这时候如果尝试修改懒复制的页，会出现 page fault 被 usertrap() 捕获。接下来需要在 usertrap() 中捕捉这个 page fault，并在尝试修改页的时候，执行实复制操作。</p><h3 id="捕获写操作并执行复制"><span class="mr-2">捕获写操作并执行复制</span><a href="#捕获写操作并执行复制" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>与 lazy allocation lab 类似，在 usertrap() 中添加对 page fault 的检测，并在当前访问的地址符合懒复制页条件时，对懒复制页进行实复制操作：</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</pre><td class="rouge-code"><pre><span class="c1">// kernel/trap.c</span>
<span class="kt">void</span>
<span class="nf">usertrap</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>

  <span class="c1">// ......</span>

  <span class="p">}</span> <span class="k">else</span> <span class="nf">if</span><span class="p">((</span><span class="n">which_dev</span> <span class="o">=</span> <span class="n">devintr</span><span class="p">())</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">){</span>
    <span class="c1">// ok</span>
  <span class="p">}</span> <span class="k">else</span> <span class="nf">if</span><span class="p">((</span><span class="n">r_scause</span><span class="p">()</span> <span class="o">==</span> <span class="mi">13</span> <span class="o">||</span> <span class="n">r_scause</span><span class="p">()</span> <span class="o">==</span> <span class="mi">15</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">uvmcheckcowpage</span><span class="p">(</span><span class="n">r_stval</span><span class="p">()))</span> <span class="p">{</span> <span class="c1">// copy-on-write</span>
    <span class="k">if</span><span class="p">(</span><span class="n">uvmcowcopy</span><span class="p">(</span><span class="n">r_stval</span><span class="p">())</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">){</span> <span class="c1">// 如果内存不足，则杀死进程</span>
      <span class="n">p</span><span class="o">-&gt;</span><span class="n">killed</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"usertrap(): unexpected scause %p pid=%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">r_scause</span><span class="p">(),</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"            sepc=%p stval=%p</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">r_sepc</span><span class="p">(),</span> <span class="n">r_stval</span><span class="p">());</span>
    <span class="n">p</span><span class="o">-&gt;</span><span class="n">killed</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">// ......</span>

<span class="err">}</span>
</pre></table></code></div></div><p>同时 copyout() 由于是软件访问页表，不会触发缺页异常，所以需要手动添加同样的监测代码（同 lab5），检测接收的页是否是一个懒复制页，若是，执行实复制操作：</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</pre><td class="rouge-code"><pre><span class="c1">// kernel/vm.c</span>
<span class="kt">int</span>
<span class="nf">copyout</span><span class="p">(</span><span class="n">pagetable_t</span> <span class="n">pagetable</span><span class="p">,</span> <span class="n">uint64</span> <span class="n">dstva</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">src</span><span class="p">,</span> <span class="n">uint64</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">uint64</span> <span class="n">n</span><span class="p">,</span> <span class="n">va0</span><span class="p">,</span> <span class="n">pa0</span><span class="p">;</span>

  <span class="k">while</span><span class="p">(</span><span class="n">len</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">){</span>
    <span class="k">if</span><span class="p">(</span><span class="n">uvmcheckcowpage</span><span class="p">(</span><span class="n">dstva</span><span class="p">))</span> <span class="c1">// 检查每一个被写的页是否是 COW 页</span>
      <span class="n">uvmcowcopy</span><span class="p">(</span><span class="n">dstva</span><span class="p">);</span>
    <span class="n">va0</span> <span class="o">=</span> <span class="n">PGROUNDDOWN</span><span class="p">(</span><span class="n">dstva</span><span class="p">);</span>
    <span class="n">pa0</span> <span class="o">=</span> <span class="n">walkaddr</span><span class="p">(</span><span class="n">pagetable</span><span class="p">,</span> <span class="n">va0</span><span class="p">);</span>
    
    <span class="c1">// .......memmove from src to pa0</span>

    <span class="n">len</span> <span class="o">-=</span> <span class="n">n</span><span class="p">;</span>
    <span class="n">src</span> <span class="o">+=</span> <span class="n">n</span><span class="p">;</span>
    <span class="n">dstva</span> <span class="o">=</span> <span class="n">va0</span> <span class="o">+</span> <span class="n">PGSIZE</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">// ......</span>
<span class="p">}</span>

</pre></table></code></div></div><blockquote><p>UPDATE 2023-02-20: 上述代码原始版本只检查了第一个目标页的 COW 状态，对于跨越多页的 copyout，如果目标页中有多个 COW 页，只有刚好在地址范围开头的第一个页会被检查，导致共享页被误写。 感谢 <a href="https://github.com/zztaki">@zztaki</a> 指出该问题，这里给出的代码<a href="https://github.com/Miigon/my-xv6-labs-2020/commit/c119f033881ffe19f4000d0149043e717304f659">已经修复该问题</a>。 该版本对每一个目标页，在写入之前都对 COW 标志位进行检查。</p></blockquote><p>实现懒复制页的检测（<code class="language-plaintext highlighter-rouge">uvmcheckcowpage()</code>）与实复制（<code class="language-plaintext highlighter-rouge">uvmcowcopy()</code>）操作：</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
</pre><td class="rouge-code"><pre><span class="c1">// kernel/vm.c</span>
<span class="c1">// 检查一个地址指向的页是否是懒复制页</span>
<span class="kt">int</span> <span class="nf">uvmcheckcowpage</span><span class="p">(</span><span class="n">uint64</span> <span class="n">va</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">pte_t</span> <span class="o">*</span><span class="n">pte</span><span class="p">;</span>
  <span class="k">struct</span> <span class="n">proc</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">myproc</span><span class="p">();</span>
  
  <span class="k">return</span> <span class="n">va</span> <span class="o">&lt;</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">sz</span> <span class="c1">// 在进程内存范围内</span>
    <span class="o">&amp;&amp;</span> <span class="p">((</span><span class="n">pte</span> <span class="o">=</span> <span class="n">walk</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">pagetable</span><span class="p">,</span> <span class="n">va</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span><span class="o">!=</span><span class="mi">0</span><span class="p">)</span>
    <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="o">*</span><span class="n">pte</span> <span class="o">&amp;</span> <span class="n">PTE_V</span><span class="p">)</span> <span class="c1">// 页表项存在</span>
    <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="o">*</span><span class="n">pte</span> <span class="o">&amp;</span> <span class="n">PTE_COW</span><span class="p">);</span> <span class="c1">// 页是一个懒复制页</span>
<span class="p">}</span>

<span class="c1">// 实复制一个懒复制页，并重新映射为可写</span>
<span class="kt">int</span> <span class="nf">uvmcowcopy</span><span class="p">(</span><span class="n">uint64</span> <span class="n">va</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">pte_t</span> <span class="o">*</span><span class="n">pte</span><span class="p">;</span>
  <span class="k">struct</span> <span class="n">proc</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">myproc</span><span class="p">();</span>

  <span class="k">if</span><span class="p">((</span><span class="n">pte</span> <span class="o">=</span> <span class="n">walk</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">pagetable</span><span class="p">,</span> <span class="n">va</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">panic</span><span class="p">(</span><span class="s">"uvmcowcopy: walk"</span><span class="p">);</span>
  
  <span class="c1">// 调用 kalloc.c 中的 kcopy_n_deref 方法，复制页</span>
  <span class="c1">// (如果懒复制页的引用已经为 1，则不需要重新分配和复制内存页，只需清除 PTE_COW 标记并标记 PTE_W 即可)</span>
  <span class="n">uint64</span> <span class="n">pa</span> <span class="o">=</span> <span class="n">PTE2PA</span><span class="p">(</span><span class="o">*</span><span class="n">pte</span><span class="p">);</span>
  <span class="n">uint64</span> <span class="n">new</span> <span class="o">=</span> <span class="p">(</span><span class="n">uint64</span><span class="p">)</span><span class="n">kcopy_n_deref</span><span class="p">((</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">pa</span><span class="p">);</span> <span class="c1">// 将一个懒复制的页引用变为一个实复制的页</span>
  <span class="k">if</span><span class="p">(</span><span class="n">new</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
  
  <span class="c1">// 重新映射为可写，并清除 PTE_COW 标记</span>
  <span class="n">uint64</span> <span class="n">flags</span> <span class="o">=</span> <span class="p">(</span><span class="n">PTE_FLAGS</span><span class="p">(</span><span class="o">*</span><span class="n">pte</span><span class="p">)</span> <span class="o">|</span> <span class="n">PTE_W</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">PTE_COW</span><span class="p">;</span>
  <span class="n">uvmunmap</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">pagetable</span><span class="p">,</span> <span class="n">PGROUNDDOWN</span><span class="p">(</span><span class="n">va</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
  <span class="k">if</span><span class="p">(</span><span class="n">mappages</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">pagetable</span><span class="p">,</span> <span class="n">va</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">new</span><span class="p">,</span> <span class="n">flags</span><span class="p">)</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">panic</span><span class="p">(</span><span class="s">"uvmcowcopy: mappages"</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>到这里，就已经确定了大体的逻辑了：在 fork 的时候不复制数据只建立映射+标记，在进程尝试写入的时候进行实复制并重新映射为可写。</p><p>接下来，还需要做页的生命周期管理，确保在所有进程都不使用一个页时才将其释放</p><h3 id="物理页生命周期以及引用计数"><span class="mr-2">物理页生命周期以及引用计数</span><a href="#物理页生命周期以及引用计数" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>在 kalloc.c 中，我们需要定义一系列的新函数，用于完成在支持懒复制的条件下的物理页生命周期管理。</p><p>在原本的 xv6 实现中，一个物理页的生命周期内，可以支持以下操作：</p><ul><li>kalloc(): 分配物理页<li>kfree(): 释放回收物理页</ul><p>而在支持了懒分配后，由于一个物理页可能被多个进程（多个虚拟地址）引用，并且必须在最后一个引用消失后才可以释放回收该物理页，所以一个物理页的生命周期内，现在需要支持以下操作：</p><ul><li>kalloc(): 分配物理页，将其引用计数置为 1<li>krefpage(): 创建物理页的一个新引用，引用计数加 1<li>kcopy_n_deref(): 将物理页的一个引用实复制到一个新物理页上（引用计数为 1），返回得到的副本页；并将本物理页的引用计数减 1<li>kfree(): 释放物理页的一个引用，引用计数减 1；如果计数变为 0，则释放回收物理页</ul><p>一个物理页 p 首先会被父进程使用 kalloc() 创建，fork 的时候，新创建的子进程会使用 krefpage() 声明自己对父进程物理页的引用。当尝试修改父进程或子进程中的页时，kcopy_n_deref() 负责将想要修改的页实复制到独立的副本，并记录解除旧的物理页的引用（引用计数减 1）。最后 kfree() 保证只有在所有的引用者都释放该物理页的引用时，才释放回收该物理页。</p><p>这里首先定义一个数组 pageref[] 以及对应的宏，用于记录与获取某个物理页的引用计数：</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
</pre><td class="rouge-code"><pre><span class="c1">// kernel/kalloc.c</span>

<span class="c1">// 用于访问物理页引用计数数组</span>
<span class="cp">#define PA2PGREF_ID(p) (((p)-KERNBASE)/PGSIZE)
#define PGREF_MAX_ENTRIES PA2PGREF_ID(PHYSTOP)
</span>
<span class="k">struct</span> <span class="n">spinlock</span> <span class="n">pgreflock</span><span class="p">;</span> <span class="c1">// 用于 pageref 数组的锁，防止竞态条件引起内存泄漏</span>
<span class="kt">int</span> <span class="n">pageref</span><span class="p">[</span><span class="n">PGREF_MAX_ENTRIES</span><span class="p">];</span> <span class="c1">// 从 KERNBASE 开始到 PHYSTOP 之间的每个物理页的引用计数</span>
<span class="c1">// note:  reference counts are incremented on fork, not on mapping. this means that</span>
<span class="c1">//        multiple mappings of the same physical page within a single process are only</span>
<span class="c1">//        counted as one reference.</span>
<span class="c1">//        this shouldn't be a problem, though. as there's no way for a user program to map</span>
<span class="c1">//        a physical page twice within it's address space in xv6.</span>

<span class="c1">// 通过物理地址获得引用计数</span>
<span class="cp">#define PA2PGREF(p) pageref[PA2PGREF_ID((uint64)(p))]
</span>
<span class="kt">void</span>
<span class="nf">kinit</span><span class="p">()</span>
<span class="p">{</span>
  <span class="n">initlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kmem</span><span class="p">.</span><span class="n">lock</span><span class="p">,</span> <span class="s">"kmem"</span><span class="p">);</span>
  <span class="n">initlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pgreflock</span><span class="p">,</span> <span class="s">"pgref"</span><span class="p">);</span> <span class="c1">// 初始化锁</span>
  <span class="n">freerange</span><span class="p">(</span><span class="n">end</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">PHYSTOP</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span>
<span class="nf">kfree</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">pa</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">struct</span> <span class="n">run</span> <span class="o">*</span><span class="n">r</span><span class="p">;</span>

  <span class="k">if</span><span class="p">(((</span><span class="n">uint64</span><span class="p">)</span><span class="n">pa</span> <span class="o">%</span> <span class="n">PGSIZE</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">||</span> <span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">pa</span> <span class="o">&lt;</span> <span class="n">end</span> <span class="o">||</span> <span class="p">(</span><span class="n">uint64</span><span class="p">)</span><span class="n">pa</span> <span class="o">&gt;=</span> <span class="n">PHYSTOP</span><span class="p">)</span>
    <span class="n">panic</span><span class="p">(</span><span class="s">"kfree"</span><span class="p">);</span>

  <span class="n">acquire</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pgreflock</span><span class="p">);</span>
  <span class="k">if</span><span class="p">(</span><span class="o">--</span><span class="n">PA2PGREF</span><span class="p">(</span><span class="n">pa</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 当页面的引用计数小于等于 0 的时候，释放页面</span>

    <span class="c1">// Fill with junk to catch dangling refs.</span>
    <span class="c1">// pa will be memset multiple times if race-condition occurred.</span>
    <span class="n">memset</span><span class="p">(</span><span class="n">pa</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">PGSIZE</span><span class="p">);</span>

    <span class="n">r</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">run</span><span class="o">*</span><span class="p">)</span><span class="n">pa</span><span class="p">;</span>

    <span class="n">acquire</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kmem</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>
    <span class="n">r</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">kmem</span><span class="p">.</span><span class="n">freelist</span><span class="p">;</span>
    <span class="n">kmem</span><span class="p">.</span><span class="n">freelist</span> <span class="o">=</span> <span class="n">r</span><span class="p">;</span>
    <span class="n">release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kmem</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="n">release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pgreflock</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="o">*</span>
<span class="nf">kalloc</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">struct</span> <span class="n">run</span> <span class="o">*</span><span class="n">r</span><span class="p">;</span>

  <span class="n">acquire</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kmem</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>
  <span class="n">r</span> <span class="o">=</span> <span class="n">kmem</span><span class="p">.</span><span class="n">freelist</span><span class="p">;</span>
  <span class="k">if</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
    <span class="n">kmem</span><span class="p">.</span><span class="n">freelist</span> <span class="o">=</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
  <span class="n">release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kmem</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>

  <span class="k">if</span><span class="p">(</span><span class="n">r</span><span class="p">){</span>
    <span class="n">memset</span><span class="p">((</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">r</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="n">PGSIZE</span><span class="p">);</span> <span class="c1">// fill with junk</span>
    <span class="c1">// 新分配的物理页的引用计数为 1</span>
    <span class="c1">// (这里无需加锁)</span>
    <span class="n">PA2PGREF</span><span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span>
  
  <span class="k">return</span> <span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">r</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// Decrease reference to the page by one if it's more than one, then</span>
<span class="c1">// allocate a new physical page and copy the page into it.</span>
<span class="c1">// (Effectively turing one reference into one copy.)</span>
<span class="c1">// </span>
<span class="c1">// Do nothing and simply return pa when reference count is already</span>
<span class="c1">// less than or equal to 1.</span>
<span class="c1">// </span>
<span class="c1">// 当引用已经小于等于 1 时，不创建和复制到新的物理页，而是直接返回该页本身</span>
<span class="kt">void</span> <span class="o">*</span><span class="nf">kcopy_n_deref</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">pa</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">acquire</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pgreflock</span><span class="p">);</span>

  <span class="k">if</span><span class="p">(</span><span class="n">PA2PGREF</span><span class="p">(</span><span class="n">pa</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 只有 1 个引用，无需复制</span>
    <span class="n">release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pgreflock</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">pa</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">// 分配新的内存页，并复制旧页中的数据到新页</span>
  <span class="n">uint64</span> <span class="n">newpa</span> <span class="o">=</span> <span class="p">(</span><span class="n">uint64</span><span class="p">)</span><span class="n">kalloc</span><span class="p">();</span>
  <span class="k">if</span><span class="p">(</span><span class="n">newpa</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pgreflock</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// out of memory</span>
  <span class="p">}</span>
  <span class="n">memmove</span><span class="p">((</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">newpa</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">pa</span><span class="p">,</span> <span class="n">PGSIZE</span><span class="p">);</span>

  <span class="c1">// 旧页的引用减 1</span>
  <span class="n">PA2PGREF</span><span class="p">(</span><span class="n">pa</span><span class="p">)</span><span class="o">--</span><span class="p">;</span>

  <span class="n">release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pgreflock</span><span class="p">);</span>
  <span class="k">return</span> <span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">newpa</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// 为 pa 的引用计数增加 1</span>
<span class="kt">void</span> <span class="nf">krefpage</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">pa</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">acquire</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pgreflock</span><span class="p">);</span>
  <span class="n">PA2PGREF</span><span class="p">(</span><span class="n">pa</span><span class="p">)</span><span class="o">++</span><span class="p">;</span>
  <span class="n">release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pgreflock</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><p>这里可以看到，为 pageref[] 数组定义了自旋锁 pgreflock，并且在除了 kalloc 的其他操作中，都使用了 <code class="language-plaintext highlighter-rouge">acquire(&amp;pgreflock);</code> 和 <code class="language-plaintext highlighter-rouge">release(&amp;pgreflock);</code> 获取和释放锁来保护操作的代码。这里的锁的作用是防止竞态条件（race-condition）下导致的内存泄漏。</p><p>举一个很常见的 fork() 后 exec() 的例子：</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre>父进程: 分配物理页 p（p 引用计数 = 1）
父进程: fork()（p 引用计数 = 2）
父进程: 尝试修改 p，触发页异常
父进程: 由于 p 引用计数大于 1，开始实复制 p（p 引用计数 = 2）
--- 调度器切换到子进程
子进程: exec() 替换进程影像，释放所有旧的页
子进程: 尝试释放 p（引用计数减 1），子进程丢弃对 p 的引用（p 引用计数 = 1）
--- 调度器切换到父进程
父进程: （继续实复制p）创建新页 q，将 p 复制到 q，将 q 标记为可写并建立映射，在这过程中父进程丢弃对旧 p 的引用
</pre></table></code></div></div><p>在这一个执行流过后，最终结果是物理页 p 并没有被释放回收，然而父进程和子进程都已经丢弃了对 p 的引用（页表中均没有指向 p 的页表项），这样一来 p 占用的内存就属于泄漏内存了，永远无法被回收。</p><p>加了锁之后，保证了这种情况不会出现。</p><p>注意 kalloc() 可以不用加锁，因为 kmem 的锁已经保证了同一个物理页不会同时被两个进程分配，并且在 kalloc() 返回前，其他操作 pageref() 的函数也不会被调用，因为没有任何其他进程能够在 kalloc() 返回前得到这个新页的地址。</p><h3 id="执行测试"><span class="mr-2">执行测试</span><a href="#执行测试" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre><td class="rouge-code"><pre>$ make grade
......
== Test running cowtest == 
$ make qemu-gdb
(10.4s) 
== Test   simple == 
  simple: OK 
== Test   three == 
  three: OK 
== Test   file == 
  file: OK 
== Test usertests == 
$ make qemu-gdb
(99.8s) 
== Test   usertests: copyin == 
  usertests: copyin: OK 
== Test   usertests: copyout == 
  usertests: copyout: OK 
== Test   usertests: all tests == 
  usertests: all tests: OK 
== Test time == 
time: OK 
Score: 110/110
</pre></table></code></div></div><p>如果测试失败，可在 xv6 中手动执行 cowtest 以及 usertests 单独测试，并观察输出。 usertests 可能会输出以下错误：</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>FAILED -- lost some free pages 32442 (out of 32448)
</pre></table></code></div></div><p>该错误是 usertests 检测到运行前后的空闲页数量减少，也就是检测到发生了内存泄漏。检查上面的 kalloc.c 中的操作有没有正确加锁，或者一些页的分配/释放是否正确。</p></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/course-notes/'>Course Notes</a>, <a href='/categories/mit6-s081/'>MIT6.S081</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/operating-system/" class="post-tag no-text-decoration" >operating system</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=%5Bmit6.s081%5D+%E7%AC%94%E8%AE%B0+Lab6%3A+Copy-on-write+fork+%7C+fork+%E6%87%92%E6%8B%B7%E8%B4%9D+-+Miigon%27s+blog&url=https%3A%2F%2Fblog.miigon.net%2Fposts%2Fs081-lab6-copy-on-write-fork%2F" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=%5Bmit6.s081%5D+%E7%AC%94%E8%AE%B0+Lab6%3A+Copy-on-write+fork+%7C+fork+%E6%87%92%E6%8B%B7%E8%B4%9D+-+Miigon%27s+blog&u=https%3A%2F%2Fblog.miigon.net%2Fposts%2Fs081-lab6-copy-on-write-fork%2F" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://t.me/share/url?url=https%3A%2F%2Fblog.miigon.net%2Fposts%2Fs081-lab6-copy-on-write-fork%2F&text=%5Bmit6.s081%5D+%E7%AC%94%E8%AE%B0+Lab6%3A+Copy-on-write+fork+%7C+fork+%E6%87%92%E6%8B%B7%E8%B4%9D+-+Miigon%27s+blog" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i id="copy-link" class="fa-fw fas fa-link small" data-toggle="tooltip" data-placement="top" title="Copy link" data-title-succeed="Link copied successfully!"> </i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted"><div class="access"><div id="access-lastmod" class="post"><div class="panel-heading">Recently Updated</div><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/storing-hash-objects-on-filesystem/">[随笔]文件系统上存储哈希对象：哈希算法以及目录结构对性能的影响</a><li><a href="/posts/origin-of-git-feat-bitkeeper/">git的前世，和BitKeeper</a><li><a href="/posts/golang-loop-var-reference-problems-and-semantic-fix/">随笔：Golang 循环变量引用问题以及官方语义修复</a><li><a href="/posts/s081-lab6-copy-on-write-fork/">[mit6.s081] 笔记 Lab6: Copy-on-write fork | fork 懒拷贝</a><li><a href="/posts/mysql-prepare-slower-query-bug-analyze/">MySQL Prepare后语句查询性能降低 内核源码bug排查分析</a></ul></div><div id="access-tags"><div class="panel-heading">Trending Tags</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/operating-system/">operating system</a> <a class="post-tag" href="/tags/chinese/">Chinese</a> <a class="post-tag" href="/tags/system-design/">system design</a> <a class="post-tag" href="/tags/c/">C++</a> <a class="post-tag" href="/tags/course-recommendation/">course recommendation</a> <a class="post-tag" href="/tags/grpc/">gRPC</a> <a class="post-tag" href="/tags/translated/">translated</a> <a class="post-tag" href="/tags/announcement/">announcement</a> <a class="post-tag" href="/tags/c-standard/">c++ standard</a> <a class="post-tag" href="/tags/computer-system/">computer system</a></div></div><div id="access-links" class="post"><div class="panel-heading">Links</div><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="http://0xffff.one">0xffff.one 搬砖技术社区</a><li><a href="https://blog.izgq.net">ZGQ's Blog</a></ul></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"><div class="panel-heading pl-3 pt-2 mb-2">Contents</div><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div id="tail-wrapper" class="col-12 col-lg-11 col-xl-9 pl-3 pr-3 pr-xl-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/s081-lab1-unix-utilities/"><div class="card-body"> <em class="small" data-ts="1631005200" data-df="ll" > Sep 7, 2021 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>[mit6.s081] 笔记 Lab1: Unix utilities | Unix 实用工具</h3><div class="text-muted small"><p> 这是我自学 MIT6.S081 操作系统课程的 lab 代码笔记第一篇：Unix utilities。此 lab 大致耗时：4小时。 课程地址：https://pdos.csail.mit.edu/6.S081/2020/schedule.html Lab 地址：https://pdos.csail.mit.edu/6.S081/2020/labs/util.html 我的代码地...</p></div></div></a></div><div class="card"> <a href="/posts/s081-lab2-system-calls/"><div class="card-body"> <em class="small" data-ts="1631185200" data-df="ll" > Sep 9, 2021 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>[mit6.s081] 笔记 Lab2: System calls | 系统调用</h3><div class="text-muted small"><p> 这是我自学 MIT6.S081 操作系统课程的 lab 代码笔记第二篇：System calls。此 lab 大致耗时：4小时。 课程地址：https://pdos.csail.mit.edu/6.S081/2020/schedule.html Lab 地址：https://pdos.csail.mit.edu/6.S081/2020/labs/syscall.html 我的代码...</p></div></div></a></div><div class="card"> <a href="/posts/s081-lab3-page-tables/"><div class="card-body"> <em class="small" data-ts="1631790000" data-df="ll" > Sep 16, 2021 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>[mit6.s081] 笔记 Lab3: Page tables | 页表</h3><div class="text-muted small"><p> 这是我自学 MIT6.S081 操作系统课程的 lab 代码笔记第三篇：Page tables。此 lab 大致耗时：19小时。 课程地址：https://pdos.csail.mit.edu/6.S081/2020/schedule.html Lab 地址：https://pdos.csail.mit.edu/6.S081/2020/labs/pgtbl.html 我的代码地址...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/s081-lab5-lazy-page-allocation/" class="btn btn-outline-primary" prompt="Older"><p>[mit6.s081] 笔记 Lab5: Lazy Page Allocation | 内存页懒分配</p></a> <a href="/posts/s081-lab7-multithreading/" class="btn btn-outline-primary" prompt="Newer"><p>[mit6.s081] 笔记 Lab7: Multithreading | 多线程</p></a></div><script type="text/javascript"> $(function () { const origin = "https://giscus.app"; const iframe = "iframe.giscus-frame"; const lightTheme = "light"; const darkTheme = "dark_dimmed"; let initTheme = lightTheme; if ($("html[data-mode=dark]").length > 0 || ($("html[data-mode]").length == 0 && window.matchMedia("(prefers-color-scheme: dark)").matches)) { initTheme = darkTheme; } let giscusAttributes = { "src": "https://giscus.app/client.js", "data-repo": "Miigon/blog", "data-repo-id": "MDEwOlJlcG9zaXRvcnkzMjI1MjkwNzA=", "data-category": "BlogComments", "data-category-id": "DIC_kwDOEzlnLs4CQ6Y4", "data-mapping": "pathname", "data-reactions-enabled": "1", "data-emit-metadata": "0", "data-theme": initTheme, "data-input-position": "top", "data-lang": "en", "crossorigin": "anonymous", "async": "" }; let giscusScript = document.createElement("script"); Object.entries(giscusAttributes).forEach(([key, value]) => giscusScript.setAttribute(key, value)); document.getElementById("tail-wrapper").prepend(giscusScript); addEventListener("message", (event) => { if (event.source === window && event.data && event.data.direction === ModeToggle.ID) { /* global theme mode changed */ const mode = event.data.message; const theme = (mode === ModeToggle.DARK_MODE ? darkTheme : lightTheme); const message = { setConfig: { theme: theme } }; const giscus = document.querySelector(iframe).contentWindow; giscus.postMessage({ giscus: message }, origin); } }); }); </script></div></div><footer class="row pl-3 pr-3"><div class="col-12 d-flex justify-content-between align-items-center text-muted pl-0 pr-0"><div class="footer-left"><p class="mb-0"> © 2023 <a href="https://github.com/Miigon">Miigon</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Customized Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><div id="access-tags"><div class="panel-heading">Trending Tags</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/operating-system/">operating system</a> <a class="post-tag" href="/tags/chinese/">Chinese</a> <a class="post-tag" href="/tags/system-design/">system design</a> <a class="post-tag" href="/tags/c/">C++</a> <a class="post-tag" href="/tags/course-recommendation/">course recommendation</a> <a class="post-tag" href="/tags/grpc/">gRPC</a> <a class="post-tag" href="/tags/translated/">translated</a> <a class="post-tag" href="/tags/announcement/">announcement</a> <a class="post-tag" href="/tags/c-standard/">c++ standard</a> <a class="post-tag" href="/tags/computer-system/">computer system</a></div></div></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a><div id="notification" class="toast" role="alert" aria-live="assertive" aria-atomic="true" data-animation="true" data-autohide="false"><div class="toast-header"> <button type="button" class="ml-2 ml-auto close" data-dismiss="toast" aria-label="Close"> <span aria-hidden="true">&times;</span> </button></div><div class="toast-body text-center pt-0"><p class="pl-2 pr-2 mb-3">A new version of content is available.</p><button type="button" class="btn btn-primary" aria-label="Update"> Update </button></div></div><script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No results found.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/magnific-popup@1/dist/jquery.magnific-popup.min.js,npm/lozad/dist/lozad.min.js,npm/clipboard@2/dist/clipboard.min.js"></script> <script src="https://cdn.jsdelivr.net/combine/npm/dayjs@1/dayjs.min.js,npm/dayjs@1/locale/en.min.js,npm/dayjs@1/plugin/relativeTime.min.js,npm/dayjs@1/plugin/localizedFormat.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.bundle.min.js"></script> <script defer src="/app.js"></script>
