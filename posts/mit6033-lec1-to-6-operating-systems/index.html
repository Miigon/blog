<!DOCTYPE html><html lang="en" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="generator" content="Jekyll v4.2.2" /><meta property="og:title" content="[mit6.033] 第一部分 LEC 1-6 Operating Systems 笔记" /><meta property="og:locale" content="en" /><meta name="description" content="这是我自学 MIT6.033 课程的第一部分：Operating Systems 的笔记。 该课程共分为 4 部分：Operating Systems、Networking、Distributed Systems、Security 课程详细介绍可以查阅：https://blog.miigon.net/posts/mit6033-computer-system-design/ 笔记为学习过程中随笔记录以及思考，未经整理，所以可能会比较零散。" /><meta property="og:description" content="这是我自学 MIT6.033 课程的第一部分：Operating Systems 的笔记。 该课程共分为 4 部分：Operating Systems、Networking、Distributed Systems、Security 课程详细介绍可以查阅：https://blog.miigon.net/posts/mit6033-computer-system-design/ 笔记为学习过程中随笔记录以及思考，未经整理，所以可能会比较零散。" /><link rel="canonical" href="https://blog.miigon.net/posts/mit6033-lec1-to-6-operating-systems/" /><meta property="og:url" content="https://blog.miigon.net/posts/mit6033-lec1-to-6-operating-systems/" /><meta property="og:site_name" content="Miigon’s blog" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2021-11-11T04:45:00+08:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="[mit6.033] 第一部分 LEC 1-6 Operating Systems 笔记" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2021-12-01T21:34:56+08:00","datePublished":"2021-11-11T04:45:00+08:00","description":"这是我自学 MIT6.033 课程的第一部分：Operating Systems 的笔记。 该课程共分为 4 部分：Operating Systems、Networking、Distributed Systems、Security 课程详细介绍可以查阅：https://blog.miigon.net/posts/mit6033-computer-system-design/ 笔记为学习过程中随笔记录以及思考，未经整理，所以可能会比较零散。","headline":"[mit6.033] 第一部分 LEC 1-6 Operating Systems 笔记","mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.miigon.net/posts/mit6033-lec1-to-6-operating-systems/"},"url":"https://blog.miigon.net/posts/mit6033-lec1-to-6-operating-systems/"}</script><title>[mit6.033] 第一部分 LEC 1-6 Operating Systems 笔记 | Miigon's blog</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="Miigon's blog"><meta name="application-name" content="Miigon's blog"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link rel="dns-prefetch" href="https://fonts.gstatic.com" crossorigin><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://cdn.jsdelivr.net" ><link rel="dns-prefetch" href="https://cdn.jsdelivr.net" ><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Lato&family=Source+Sans+Pro:wght@400;600;700;900&display=swap"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get MODE_ATTR() { return "data-mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } static get ID() { return "mode-toggle"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } let self = this; /* always follow the system prefers */ this.sysDarkPrefers.addEventListener("change", () => { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.notify(); }); } /* constructor() */ get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode === ModeToggle.DARK_MODE; } get isLightMode() { return this.mode === ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer)) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } setDark() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_ATTR); sessionStorage.removeItem(ModeToggle.MODE_KEY); } /* Notify another plugins that the theme mode has changed */ notify() { window.postMessage({ direction: ModeToggle.ID, message: this.modeStatus }, "*"); } } /* ModeToggle */ const toggle = new ModeToggle(); function flipMode() { if (toggle.hasMode) { if (toggle.isSysDarkPrefer) { if (toggle.isLightMode) { toggle.clearMode(); } else { toggle.setLight(); } } else { if (toggle.isDarkMode) { toggle.clearMode(); } else { toggle.setDark(); } } } else { if (toggle.isSysDarkPrefer) { toggle.setLight(); } else { toggle.setDark(); } } toggle.notify(); } /* flipMode() */ </script><body data-spy="scroll" data-target="#toc" data-topbar-visible="true"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" class="mx-auto"> <img src="/assets/img/avatar.png" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">Miigon's blog</a></div><div class="site-subtitle font-italic">My ideas, thoughts and experiences</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tag ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info-circle ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center align-items-center"> <button class="mode-toggle btn" aria-label="Switch Mode"> <i class="fas fa-adjust"></i> </button> <span class="icon-border"></span> <a href="https://github.com/Miigon" aria-label="github" target="_blank" rel="noopener"> <i class="fab fa-github-alt"></i> </a> <a href="https://twitter.com/" aria-label="twitter" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['miigon.pg','gmail.com'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="https://stackoverflow.com/users/7509248/miigon" aria-label="stack-overflow" target="_blank" rel="noopener"> <i class="fab fa-stack-overflow"></i> </a></div></div><div id="topbar-wrapper"><div id="topbar" class="container d-flex align-items-center justify-content-between h-100 pl-3 pr-3 pl-md-4 pr-md-4"> <span id="breadcrumb"> <span> <a href="/"> Home </a> </span> <span>[mit6.033] 第一部分 LEC 1-6 Operating Systems 笔记</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..."> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper" class="d-flex justify-content-center"><div id="main" class="container pl-xl-4 pr-xl-4"><div class="row"><div id="core-wrapper" class="col-12 col-lg-11 col-xl-9 pr-xl-4"><div class="post pl-1 pr-1 pl-md-2 pr-md-2"><h1 data-toc-skip>[mit6.033] 第一部分 LEC 1-6 Operating Systems 笔记</h1><div class="post-meta text-muted"> <span> Posted <em class="" data-ts="1636577100" data-df="ll" data-toggle="tooltip" data-placement="bottom"> Nov 11, 2021 </em> </span> <span> Updated <em class="" data-ts="1638365696" data-df="ll" data-toggle="tooltip" data-placement="bottom"> Dec 1, 2021 </em> </span><div class="d-flex justify-content-between"> <span> By <em> <a href="https://github.com/Miigon">Miigon</a> </em> </span><div> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="5781 words"> <em>32 min</em> read</span></div></div></div><div class="post-content"><blockquote><p>这是我自学 MIT6.033 课程的第一部分：Operating Systems 的笔记。<br /> 该课程共分为 4 部分：<strong>Operating Systems</strong>、Networking、Distributed Systems、Security</p><p>课程详细介绍可以查阅：<a href="https://blog.miigon.net/posts/mit6033-computer-system-design/">https://blog.miigon.net/posts/mit6033-computer-system-design/</a></p><p>笔记为学习过程中随笔记录以及思考，未经整理，所以可能会比较零散。</p></blockquote><h2 id="lec1-enforced-modularity-via-clientserver-organization"><span class="mr-2">LEC1 Enforced Modularity via Client/Server Organization</span><a href="#lec1-enforced-modularity-via-clientserver-organization" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><h3 id="复杂度"><span class="mr-2">复杂度</span><a href="#复杂度" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p><strong>复杂度</strong>使得构建系统变得困难。</p><p>使用<strong>模块化</strong>和<strong>抽象</strong>的方式，来解决复杂度。</p><ul><li>模块化：模块化的系统更容易理解、管理、改变、改进<li>模块化减少了「命运共享」(fate-sharing)<li>抽象使我们可以不指定具体实现的情况下进行交互（隐藏细节）<li>好的抽象设计应当减少模块之间的连接（低耦合）</ul><h3 id="强制实施enforced的模块性"><span class="mr-2">「强制实施(Enforced)」的模块性</span><a href="#强制实施enforced的模块性" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li>「软模块化」并不足够（eg. 面向对象，但是运行在同一程序内，即错误或崩溃会在模块间传播）<li>一种强制实施模块化的方法是客户端/服务器模型（使得模块可以运行在物理隔离的机器上。或者多进程，此时模块化与错误隔离能力由操作系统提供。）</ul><h3 id="系统设计的其他目标"><span class="mr-2">系统设计的其他目标</span><a href="#系统设计的其他目标" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li>除了降低复杂度，我们可能还希望有：可伸缩性（scalability）、容错性（fault-tolerance）、安全性（security）、性能（performance）等。<li>好的模块化设计可以帮助我们实现这些特性。<li><strong>难以全部得到，多个之间有取舍。</strong></ul><h2 id="lec2-naming"><span class="mr-2">LEC2 Naming</span><a href="#lec2-naming" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>对模块的「命名」使得模块之间可以互相交互。</p><h3 id="使用命名的好处"><span class="mr-2">使用命名的好处</span><a href="#使用命名的好处" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li>方便检索<li>共享（多个用户访问同一个名称）<li>用户友好<li>寻径（eg.IP地址、域名）<li>隐藏具体细节（以及访问控制）<li>Indirection（间接，系统可以更换一个名字所指向的具体对象，而不需改动或通知客户端）</ul><p>命名的 scheme 体现了我们希望系统通过命名来得到什么功能。（addressing, indirection, etc）</p><h3 id="naming-schemes"><span class="mr-2">Naming Schemes</span><a href="#naming-schemes" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ol><li>namespace: 所有可能的名称集合 names<li>所有可能的值集合 values<li>从 name -&gt; values 的映射/查找算法（name resolution）</ol><p>需要思考的问题：</p><ul><li>名称的语法是什么？<li>名称是否含有内部结构？（例如IP地址、域名）<li>名称是全局名称还是依赖上下文的局部名称？<li><strong>系统的那一部分有权利来做「将一个名称绑定到一个值」这件事？</strong>（eg. nameserver）<li>一个名称可以对应多个值吗？（负载均衡）<li>名字对应关系是否可以随时间而改变？<li>名称解析在哪里发生？</ul><p>取舍：eg. 分布性、可伸缩性、委托（delegation）</p><h3 id="example-dns"><span class="mr-2">Example: DNS</span><a href="#example-dns" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>benefit（与上面的需要思考的问题对应）:</p><ul><li>用户友好<li>负载均衡（一个名称对应多个值）<li>单机多网站（一个值对应多个名称）<li>名字对应关系可以随时间而改变</ul><h4 id="bad-design-1"><span class="mr-2">bad design 1</span><a href="#bad-design-1" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>初期，在每一台主机都维护了一份 hosts 映射表，当新的主机加入网络的时候，新主机向所有现有主机发送更新：</p><p><img data-src="/assets/img/mit6033/post1/Pasted image 20211104103933.png" alt="" data-proofer-ignore></p><p>问题：难以 scale，一旦主机多起来，难以使所有机器上的映射表保持最新。 （也许还有 proofing attack 风险？）</p><h4 id="bad-design-2"><span class="mr-2">bad design 2</span><a href="#bad-design-2" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>用中央的服务器维护唯一的一份 hosts 映射表，每次其他主机访问域名时，都与中央服务器请求对应的 ip</p><p><img data-src="/assets/img/mit6033/post1/Pasted image 20211104104301.png" alt="" data-proofer-ignore></p><p>问题：解决了更新一致性问题，但是依然有 scale 问题，中央服务器需要处理成吨的请求</p><h4 id="分布式的解决方法dns"><span class="mr-2">分布式的解决方法（DNS）</span><a href="#分布式的解决方法dns" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>DNS 中，没有任何一个机器包含所有的映射关系。映射关系被分布在许多不同的机器上。</p><p>新问题：如何知道要访问的域名的映射关系存在哪一台机器上？ 方案：DNS 名称的「结构本身」</p><p><strong>思想：分布式（distributed）+分层架构（hierarchical）</strong></p><p><img data-src="/assets/img/mit6033/post1/Pasted image 20211104104904.png" alt="" data-proofer-ignore></p><p>apple、google、mit 等自己管理自己的名称服务器（nameserver）。顶级域名 com、net、edu 管理的名称服务器只解析 apple.com、mit.edu 这种二级域名以及它们的名称服务器，而类似 eecs.mit.edu 这种三级域名的解析，由 mit.edu 自己的名称服务器提供。</p><p>请求解析的时候，向根服务器发出请求，请求一层层代理委托至最终的名称服务器，得到 ip 地址。</p><p>解析 blog.miigon.net 的过程：</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre>root nameserver
-&gt; NS of net is at 192.14.171.193

net nameserver (192.14.171.193)
-&gt; NS of miigon.net is at 58.247.212.48

miigon.net nameserver (58.247.212.48)
-&gt; blog.miigon.net A-record 185.199.108.153

blog.miigon.net is at 185.199.108.153
</pre></table></code></div></div><p>每一级向上一级/下一级请求的过程，如果由客户端完成，则为 iterative DNS，如果由每一级服务器代为完成，则为 recursive DNS。</p><blockquote><p>root nameserver 的地址直接硬编码在机器中。</p></blockquote><ul><li>每一层解析，更接近最终的结果：这里体现了 delegation 委托，即根服务器不能直接给出查询结果，但是可以将请求委托给下一级名称服务器去完成。</ul><blockquote><p>类比：文件系统路径的分层结构 对比：对象存储服务，所有文件路径都只是扁平的键，没有分层结构 （体现的是另一种设计选择与取舍：低复杂度，高访问速度，但无法做目录遍历，也就是难以实现类似 ls 指令的功能）</p></blockquote><p>依然有问题：</p><ul><li><strong>性能问题</strong>：解析需要许多请求，尤其是对根服务器<li><strong>可靠性问题</strong>：名称服务器失效或（<strong>安全问题</strong>）被攻击</ul><h3 id="总结"><span class="mr-2">总结</span><a href="#总结" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li>「模块化」与「抽象」能降低复杂度。<li>「客户/服务器模型」使得我们可以通过将模块放在物理隔离的机器上，从而增加模块性<li>「命名」使得模块之间可以交互，同时提供了如间接性、用户友好等其他特性<li>DNS 是一个很好的命名实例，同时展示了如<strong>分层（hierarchy）</strong>、<strong>可伸缩（scalability）</strong>、<strong>代理委托（delegation）</strong>、<strong>去中心化（decentralization）</strong></ul><h4 id="rec3-dns"><span class="mr-2">REC3: DNS</span><a href="#rec3-dns" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><ul><li>递归（recursive）请求的好处是什么？<ul><li>相比 iterative，简化客户端设计，只需要请求一个名称服务器，名称服务器代为完成整个请求过程。<li>容易实现 cache，如果请求的某一级服务器已经有完整记录，则可直接返回，而对于客户端来说是无感知的。</ul><li>DNS 分层架构的好处是什么？有什么缺点吗？<ul><li>每一层只需管理/维护该层的映射关系，将工作量分摊到不同的层上的不同主机，避免了单主机处理所有请求<li>由每个名称服务器管理自己的域内的名称，无需担心更新时需要向某个中央服务器汇报导致难以 scale 的问题<li><strong>依然不是完全分布式，依然有 single point of faliure（根服务器）</strong></ul><li>应该由谁控制 DNS 根服务器？</ul><h2 id="lec3-virtual-memory"><span class="mr-2">LEC3 Virtual Memory</span><a href="#lec3-virtual-memory" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><h3 id="操作系统"><span class="mr-2">操作系统</span><a href="#操作系统" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>操作系统通过「虚拟化（Virtualization）」和「抽象（Abstraction）」，<strong>保证单机上的模块性</strong></p><p>为了实现单机器上的模块性，操作系统需要实现的目标：</p><ol><li>程序不应该可以访问和修改其他程序的内存（隔离） =&gt; <strong>virtual memory（今天话题）</strong><li>程序之间应该可以互相通信（通信机制）<li>程序应该可以和其他程序共享 CPU</ol><p>主要实现这些目标的手段：<strong>虚拟化</strong> 操作系统对硬件的不同部分进行虚拟化，让程序<strong>以为</strong>自己访问的是完整的物理硬件。</p><h3 id="虚拟内存"><span class="mr-2">虚拟内存</span><a href="#虚拟内存" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>让程序寻址整个地址空间，MMU 负责将虚拟地址转换为物理地址。</p><ul><li>Virtual Memory 也是一种 Naming Scheme，为我们提供了隐藏（隐藏其他程序的内存）、间接性（虚拟地址指向的实际地址可以随时改变，而不需要显式地告知程序）、访问控制（页表控制位，R/W）等特性。</ul><h4 id="ideas"><span class="mr-2">Ideas</span><a href="#ideas" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><ol><li>储存所有物理地址对应关系，使用整个虚拟地址作为 index<ul><li>问题：表太大</ul><li>页表：分页映射，虚拟地址前 p 位作为页 index，后 q 位作为页内偏移<ul><li>体积小很多</ul></ol><ul><li>虚拟内存是否真的能阻止程序访问其他程序的内存？（只有系统可以修改页表，+权限位，当程序尝试破坏这一模块性的时候，系统捕获exception，防止发生）<li>在这里会出现什么性能问题？（每次内存访问都有查表开销，缓解：TLB 快表作为 cache，潜在问题 consistency）</ul><p>详细见S081。</p><h4 id="多级页表hierarchical"><span class="mr-2">多级页表（Hierarchical）</span><a href="#多级页表hierarchical" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>单级页表的设计依然需要使用许多空间，解决方法：多级页表，每一级存储指向下一级的地址，仅在使用到时分配。</p><p>tradeoff：</p><ul><li>优点：更离散化的存储（利用零散内存页），占用更小空间<li>缺点：查询速度（多级查找而不是一级），更多的缺页异常</ul><h4 id="抽象abstraction"><span class="mr-2">抽象（abstraction）</span><a href="#抽象abstraction" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>对于不可虚拟化的资源（磁盘、网络）（ps其实还是可以虚拟化的hhhhhh），系统提供抽象（系统调用），使得这些东西更加可移植。</p><h2 id="lec4-bounded-buffers-and-locks"><span class="mr-2">LEC4 Bounded buffers and locks</span><a href="#lec4-bounded-buffers-and-locks" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><h3 id="操作系统again"><span class="mr-2">操作系统（again）</span><a href="#操作系统again" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>操作系统通过「虚拟化（Virtualization）」和「抽象（Abstraction）」，<strong>保证单机上的模块性</strong></p><p>为了实现单机器上的模块性，操作系统需要实现的目标：</p><ol><li>程序不应该可以访问和修改其他程序的内存（隔离） =&gt; virtual memory<li>程序之间应该可以互相通信（通信机制） =&gt; <strong>有界缓冲区与锁同步（今日话题）</strong><li>程序应该可以和其他程序共享 CPU</ol><h3 id="bounded-buffers--locks-concurrency"><span class="mr-2">Bounded buffers &amp; locks (concurrency)</span><a href="#bounded-buffers--locks-concurrency" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>例子：unix pipe（consumer/producer）</p><p>考虑 consumer/producer 问题，如果可以用一个整数数值来描述资源剩余数量，比如剩余的 bounded buffers 空间，则可以用「信号量Semaphore」来同步。 如果资源可用条件较为复杂，无法使用整数描述，则应该使用「条件变量Condition variable」来同步（利用其较高的自由度，自定义唤醒条件） [[唤醒丢失问题 &amp; 条件变量 vs 信号量 the lost wakeup problem &amp; condition variable vs semaphore]]</p><p>本质：都是利用互斥锁同步。</p><h4 id="atomic-actions"><span class="mr-2">Atomic actions</span><a href="#atomic-actions" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>原子操作的粒度？</p><ul><li>过粗：性能变低（根本原因是<strong>并行性受到了限制</strong>，体现为“锁竞争严重”）<li>过细：意外行为</ul><p>tip：将锁的作用理解为「保护不变量」。在不变量被暂时破坏时保护数据结构，以不被外部察觉。在释放锁之前，operation 应该恢复该不变量。 [[锁的作用 Ways to think about what locks achieve]]</p><h3 id="例子文件系统中的锁"><span class="mr-2">例子：文件系统中的锁</span><a href="#例子文件系统中的锁" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>文件移动：</p><ul><li>粗粒度锁：锁整个文件系统，问题：性能低，不能同时移动两个文件<li>细粒度锁：更好的性能，但是更难正确<ul><li>例子：将 file1.txt 从 A 移动到 B，同时将 file2.txt 从 B 移动到 A （死锁，拿A锁等B锁，拿B锁等A锁）<li>例子解决方法：确保获取锁顺序，阻止环路形成。（例如强行要求先拿小inode号的目录的锁）</ul></ul><p>结论：一些系统中的锁问题以及锁设计，需要有全局观地去思考锁与锁之间的交互，而不能只考虑锁对局部代码的影响。</p><h2 id="lec5-threads"><span class="mr-2">LEC5 Threads</span><a href="#lec5-threads" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><h3 id="操作系统again-again"><span class="mr-2">操作系统（again again）</span><a href="#操作系统again-again" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>操作系统通过「虚拟化（Virtualization）」和「抽象（Abstraction）」，<strong>保证单机上的模块性</strong></p><p>为了实现单机器上的模块性，操作系统需要实现的目标：</p><ol><li>程序不应该可以访问和修改其他程序的内存（隔离） =&gt; virtual memory<li>程序之间应该可以互相通信（通信机制） =&gt; bounded buffers &amp; locks<li>程序应该可以和其他程序共享 CPU =&gt; <strong>虚拟化CPU（抢占式多线程 threads）</strong></ol><p>线程thread：一个虚拟的处理器（包装了一个程序的运行状态） 线程切换：将当前程序的运行状态换出，将另一个程序的运行状态换入（suspend/resume，或context switching）</p><ul><li>线程需要包含的信息：所有的寄存器、所有的内存（利用页表切换实现）<li>何时挂起/恢复一个线程？（定期，yield()）</ul><h3 id="线程主动放弃cpuyield"><span class="mr-2">线程主动放弃CPU：yield()</span><a href="#线程主动放弃cpuyield" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>放弃当前线程的CPU执行权，保存当前线程的信息（栈、页表寄存器、callee-saved registers，不需要保存pc，因为在栈中的return address已经有），找到另一个可以运行的线程，并恢复新线程的运行状态（恢复栈指针、页表、callee-saved registers，ret指令返回到新线程之前yield后的位置）</p><p>这一部分在s081中有更详细展开：https://blog.miigon.net/posts/s081-lab7-multithreading/</p><p>在 bounded buffer 的 send 遇到缓冲区不足时，进程调用 yield 来主动放弃 CPU，但是进程可能在缓冲区出现空闲之前被再次调度唤醒，然后立刻又进入睡眠。</p><p><img data-src="/assets/img/mit6033/post1/Pasted image 20211111013118.png" alt="" data-proofer-ignore></p><p>我们希望能够实现「yield，然后直到 buffer 中有空闲位置之前都不要再次唤醒该线程」（减小无意义唤醒）——操作系统提供条件变量机制来实现这一功能（condition variable）</p><h3 id="条件变量condition-variable"><span class="mr-2">条件变量（condition variable）</span><a href="#条件变量condition-variable" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>程序可以等待（wait）一个条件（condition）的发生，并且在该条件发生的时候收到通知。 另一进程可以在一个条件变为真的时候，使用 <code class="language-plaintext highlighter-rouge">notify()</code> 通知所有正在等待该条件的进程。</p><p>more on [[唤醒丢失问题 &amp; 条件变量 vs 信号量 the lost wakeup problem &amp; condition variable vs semaphore]] （https://blog.miigon.net/posts/the-lost-wakeup-problem-cond-var-vs-semaphore/）</p><h4 id="问题lost-wakeup-唤醒丢失"><span class="mr-2">问题：lost wakeup 唤醒丢失</span><a href="#问题lost-wakeup-唤醒丢失" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p><img data-src="/assets/img/mit6033/post1/Pasted image 20211111013812.png" alt="" data-proofer-ignore></p><p>进程 A 在完成 <code class="language-plaintext highlighter-rouge">release(bb.lock)</code> 之后，但是进入 <code class="language-plaintext highlighter-rouge">wait(bb.has_space)</code> 之前，另一个进程 B 可能会执行 receive，从而尝试唤醒正在等待 has_space 条件变量的进程。而此时唤醒的进程中不会包括进程 A。这时候进程 A 继续执行，然后才进入到 <code class="language-plaintext highlighter-rouge">wait(bb.has_space)</code> 中，而不会收到来自进程 B 的唤醒。</p><p>从而，进程 A “丢失” 了进程 B 发出的这一次唤醒。</p><p>唤醒丢失的后果轻者可能是使得进程 A 需要等待下一次条件为真时才能被唤醒，对于一些十分关键的条件变量，A 可能永远都不会再收到通知，从而陷入永久的沉睡。</p><p>解决方法：wait() 进入等待的同时，原子性地放弃锁。在被唤醒之后，原子性地重新获得锁，然后再从 wait 返回到用户代码。</p><p>即：</p><div class="language-python highlighter-rouge"><div class="code-header"> <span data-label-text="Python"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="c1"># pseudo-code
</span><span class="k">def</span> <span class="nf">wait</span><span class="p">(</span><span class="n">cond_var</span><span class="p">,</span> <span class="n">mutex</span><span class="p">):</span>
	<span class="n">release</span><span class="p">(</span><span class="n">mutex</span><span class="p">)</span>
	<span class="n">currentthread</span><span class="p">.</span><span class="n">state</span> <span class="o">=</span> <span class="n">WAITING</span>
	<span class="n">currentthread</span><span class="p">.</span><span class="n">waiting_on</span> <span class="o">=</span> <span class="n">cond_var</span>
	<span class="n">yield_wait</span><span class="p">()</span>
	<span class="n">acquire</span><span class="p">(</span><span class="n">mutex</span><span class="p">)</span>
</pre></table></code></div></div><p>注意 wait 整个操作必须是原子的，这一原子性可以通过给 wait 加一个额外的锁 tlock 实现。</p><h4 id="问题yield_wait-死锁"><span class="mr-2">问题：yield_wait 死锁</span><a href="#问题yield_wait-死锁" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>这里的 yield_wait 有一个很细微的死锁问题：<br /> <img data-src="/assets/img/mit6033/post1/Pasted image 20211111022845.png" alt="" data-proofer-ignore></p><p>这里寻找可运行的线程的循环，由于 yield_wait 被调用时持有 t_lock，假设当所有其他线程都处于等待/不可运行状态，则该循环不会找到可运行的线程，并且更糟糕的是由于该循环执行时持有 t_lock，而其他 CPU 需要首先进行 yield 才能运行线程，而 yield 所要求的 t_lock 被 yield_wait 所在 CPU 持有着，则其他 CPU 无法推进任何线程的状态，该循环永远找不到可运行线程，整个系统进入死锁。这种情况在普通的 yield 中是不会出现的，因为普通的 yield 无论如何都至少会有切换前的原线程是 RUNNABLE 的，所以循环必然会终止（而对于 yield_wait 来说不是这样）。</p><p>这里是一个 CPU 持有 t_lock 去等待「有可运行线程出现」这一条件，而可运行的线程在出现前又需要获取 t_lock，造成环路等待。</p><p>解决方法比较简单，循环中需要间断性主动放弃 t_lock，破坏环路等待，使得其他 CPU 可以推进，从而使得「可运行线程出现」，解除死锁。</p><h4 id="问题两个-cpu-共用同一线程栈导致栈损坏"><span class="mr-2">问题：两个 CPU 共用同一线程栈导致栈损坏</span><a href="#问题两个-cpu-共用同一线程栈导致栈损坏" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>这里还有一个小细节，由于 yield_wait 此时使用的还是原线程的栈，此时放弃 t_lock 允许其他线程执行的时候，其他 CPU 可能会执行到该线程，而此时 yield_wait 的循环依然可能需要用到栈。从而导致有两个 CPU 使用同一个线程的栈，导致栈内容损坏。</p><p>这一情况比较稀有，但是依然可能出现，解决方法就是在进入 yield_wait 循环之前，将栈切换到其他地方，比如 CPU-specific 的栈，从而避免两个 CPU 共用一个线程栈。</p><h3 id="如果线程不主动放弃-cpu-呢抢占preemption"><span class="mr-2">如果线程不主动放弃 CPU 呢？抢占（preemption）。</span><a href="#如果线程不主动放弃-cpu-呢抢占preemption" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>使用时钟中断，定期中断 CPU 执行流，并强行调用 yield。</p><div class="language-python highlighter-rouge"><div class="code-header"> <span data-label-text="Python"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre><span class="k">def</span> <span class="nf">timer_interrupt</span><span class="p">():</span>
	<span class="n">push</span> <span class="n">PC</span>
	<span class="n">push</span> <span class="n">ALL</span> <span class="n">registers</span> 
	
	<span class="k">yield</span><span class="p">()</span> <span class="c1"># will further save stack pointer,
</span>			<span class="c1"># page table register and callee-saved registers
</span>
	<span class="c1"># since this is an interrupt, must restore all registers,
</span>	<span class="c1"># instead of just the callee-saved ones.
</span>	<span class="n">pop</span> <span class="n">ALL</span> <span class="n">registers</span>
	<span class="n">pop</span> <span class="n">pc</span>
</pre></table></code></div></div><h3 id="总结-1"><span class="mr-2">总结</span><a href="#总结-1" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><ul><li>「线程」虚拟化了 CPU，使得一个 CPU 可以在多个程序之间共享。<li>「条件变量」为线程提供了一个更高效的等待其他线程事件发生的 API<li><p>「抢占」使得一个进程能被中断并强制其放弃CPU，使得不需要依赖程序员主动调用 yield 来放弃 CPU（抢占式多线程以及协作式多线程）</p><li>操作系统中为用户程序提供模块化的三个不同方面：内存、通信、CPU；机制看起来不同，但都是虚拟化思想的应用（虚拟化环境，使得上层应用/模块可以运行在自己独立的环境中而与其他模块互不干扰）。<li>单机上的模块化（模块之间互相隔离）的保证，需要来自操作系统以及硬件的支持。<li>我们成功的利用操作系统的虚拟内存机制、通信机制、虚拟化CPU机制，保证了单机上的模块性。</ul><h2 id="lec6-os-structure-virtual-machines"><span class="mr-2">LEC6 OS structure, Virtual Machines</span><a href="#lec6-os-structure-virtual-machines" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>另一种 virtualization 的应用：虚拟机</p><h3 id="目标在同一机器上同时运行多个系统"><span class="mr-2">目标：在同一机器上同时运行多个系统</span><a href="#目标在同一机器上同时运行多个系统" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>限制：兼容性。因为我们不希望需要修改内核的代码（否则称为半虚拟化）。</p><p>操作系统考虑的是如何将程序与程序之间隔离。虚拟机的任务是退后一步，也就是如何将操作系统与操作系统之间隔离。</p><p>内核中负责运行虚拟机的模块，称为 virtual machine monitor VMM （Linux kernel 中的实现为 KVM，windows 下为 hyperv）。</p><p>VMM 需要负责分配资源以及分发事件，这里重点考虑如何处理客户系统中执行的，需要与实际硬件交互的指令。</p><p><img data-src="/assets/img/mit6033/post1/Pasted image 20211111034151.png" alt="" data-proofer-ignore></p><h4 id="虚拟化-cpu"><span class="mr-2">虚拟化 CPU</span><a href="#虚拟化-cpu" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>尝试方案1：模拟每一条客户系统执行的指令。问题：慢（内存比寄存器要慢100倍左右，仅仅是用内存去模拟寄存器这一步就会将性能降低两个数量级） 尝试方案2：用户系统直接在真实 CPU 上运行指令。问题：特权指令的处理</p><p>VMM 负责处理特权指令，当子系统执行特权指令的时候，会引发宿主系统的中断，并允许宿主系统处理这一特权指令。</p><p>方式：</p><ol><li>通过将客户系统运行在用户态使得特权操作触发中断（trap-and-emulate）。但是有一些特权操作（如写入 U/K 位切换用户/内核态）本身就不会触发中断，需要修改客户系统或进行指令替换；<li>通过硬件提供的支持，如 Intel VT-x</ol><h4 id="虚拟化内存"><span class="mr-2">虚拟化内存</span><a href="#虚拟化内存" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><ul><li>方法1：将客户系统的页表内存设为只读，捕获每一个客户系统对页表的修改，并将其与宿主机的页表结合，生成一个合并页表，作为 CPU 实际使用的页表。<li>方法2：现代 CPU 含有对虚拟化的支持，CPU 同时知道客户系统以及宿主系统的页表的存在，并会在客户系统尝试访问内存时，依次查询两个页表。（拓展：嵌套虚拟化，CPU 会需要知道并查找 n 层页表）</ul><h3 id="内核架构"><span class="mr-2">内核架构</span><a href="#内核架构" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>宏内核：</p><ul><li>Linux 内核，内核内部没有模块化与隔离，一个bug可以使整个系统崩溃。<li>由于复杂度，bug 容易出现 微内核：<li>将子系统——文件系统、设备驱动——运行为用户态程序。<li>更好的模块性，更少的 bug，bug 更不容易将整个系统带垮。<li>模块间接口设计更复杂，模块间通信性能可能受影响。</ul><h3 id="性能"><span class="mr-2">性能</span><a href="#性能" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>一个选择宏内核而不是微内核的理由是性能。</p><p>测量性能的指标：吞吐量 throughput、延迟 latency。 提升性能的通用手段：批处理 batching、缓存 caching、并发 concurrency、调度 scheduling</p><p>会在后续的网络章节继续讲延迟与吞吐的话题。6.033 重点在于讨论系统设计中「通用的提升性能手段」，而不是如复杂度优化这一类场景相关的具体优化手段。</p><h2 id="总结-2"><span class="mr-2">总结</span><a href="#总结-2" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>在 Operating System 的 Lecture 结束后，已经理解了系统中单台机器上的模块化以及工作。后续讨论多机系统中机器之间互相交流必不可少的部分：网络。</p></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/course-notes/'>Course Notes</a>, <a href='/categories/mit6-033/'>MIT6.033</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/system-design/" class="post-tag no-text-decoration" >system design</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=%5Bmit6.033%5D+%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86+LEC+1-6+Operating+Systems+%E7%AC%94%E8%AE%B0+-+Miigon%27s+blog&url=https%3A%2F%2Fblog.miigon.net%2Fposts%2Fmit6033-lec1-to-6-operating-systems%2F" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=%5Bmit6.033%5D+%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86+LEC+1-6+Operating+Systems+%E7%AC%94%E8%AE%B0+-+Miigon%27s+blog&u=https%3A%2F%2Fblog.miigon.net%2Fposts%2Fmit6033-lec1-to-6-operating-systems%2F" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://t.me/share/url?url=https%3A%2F%2Fblog.miigon.net%2Fposts%2Fmit6033-lec1-to-6-operating-systems%2F&text=%5Bmit6.033%5D+%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86+LEC+1-6+Operating+Systems+%E7%AC%94%E8%AE%B0+-+Miigon%27s+blog" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i id="copy-link" class="fa-fw fas fa-link small" data-toggle="tooltip" data-placement="top" title="Copy link" data-title-succeed="Link copied successfully!"> </i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted"><div class="access"><div id="access-lastmod" class="post"><div class="panel-heading">Recently Updated</div><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/storing-hash-objects-on-filesystem/">[随笔]文件系统上存储哈希对象：哈希算法以及目录结构对性能的影响</a><li><a href="/posts/origin-of-git-feat-bitkeeper/">git的前世，和BitKeeper</a><li><a href="/posts/golang-loop-var-reference-problems-and-semantic-fix/">随笔：Golang 循环变量引用问题以及官方语义修复</a><li><a href="/posts/s081-lab6-copy-on-write-fork/">[mit6.s081] 笔记 Lab6: Copy-on-write fork | fork 懒拷贝</a><li><a href="/posts/mysql-prepare-slower-query-bug-analyze/">MySQL Prepare后语句查询性能降低 内核源码bug排查分析</a></ul></div><div id="access-tags"><div class="panel-heading">Trending Tags</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/operating-system/">operating system</a> <a class="post-tag" href="/tags/chinese/">Chinese</a> <a class="post-tag" href="/tags/system-design/">system design</a> <a class="post-tag" href="/tags/c/">C++</a> <a class="post-tag" href="/tags/course-recommendation/">course recommendation</a> <a class="post-tag" href="/tags/grpc/">gRPC</a> <a class="post-tag" href="/tags/translated/">translated</a> <a class="post-tag" href="/tags/announcement/">announcement</a> <a class="post-tag" href="/tags/c-standard/">c++ standard</a> <a class="post-tag" href="/tags/computer-system/">computer system</a></div></div><div id="access-links" class="post"><div class="panel-heading">Links</div><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="http://0xffff.one">0xffff.one 搬砖技术社区</a><li><a href="https://blog.izgq.net">ZGQ's Blog</a></ul></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"><div class="panel-heading pl-3 pt-2 mb-2">Contents</div><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div id="tail-wrapper" class="col-12 col-lg-11 col-xl-9 pl-3 pr-3 pr-xl-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/mit6033-lec7-to-12-networking/"><div class="card-body"> <em class="small" data-ts="1638365460" data-df="ll" > Dec 1, 2021 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>[mit6.033] 第二部分 LEC 7-12 Networking 笔记</h3><div class="text-muted small"><p> 这是我自学 MIT6.033 课程的第二部分：Networking 的笔记。 该课程共分为 4 部分：Operating Systems、Networking、Distributed Systems、Security 课程详细介绍可以查阅：https://blog.miigon.net/posts/mit6033-computer-system-design/ 笔记为学习过...</p></div></div></a></div><div class="card"> <a href="/posts/mit6033-computer-system-design/"><div class="card-body"> <em class="small" data-ts="1635704340" data-df="ll" > Nov 1, 2021 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>MIT6.033 Computer System Design | 计算机系统设计</h3><div class="text-muted small"><p> MIT6.033 Computer System Design (Spring 2021) 前置课程： 6.004 Computation Structures 计算架构 6.006 Introduction to Algorithms 算法导论 ps. 本课 6.033 Computer System Design 和 6.S081 Operatin...</p></div></div></a></div><div class="card"> <a href="/posts/mit6830-database-systems/"><div class="card-body"> <em class="small" data-ts="1661336640" data-df="ll" > Aug 24, 2022 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>MIT6.830 Database Systems | 数据库系统</h3><div class="text-muted small"><p> MIT6.830 Database Systems (Spring 2021) 前置课程： 6.033 Computer System Design 计算机系统设计 这门课与MIT 6.814是同一门课程，两者区别在于Final Project在6.814中由Lab5以及Lab6替代。虽然这门课是研究生课程，但是在MIT里，这门课大概1/3的学生是本科生。 ...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/mit6033-computer-system-design/" class="btn btn-outline-primary" prompt="Older"><p>MIT6.033 Computer System Design | 计算机系统设计</p></a> <a href="/posts/mit6033-lec7-to-12-networking/" class="btn btn-outline-primary" prompt="Newer"><p>[mit6.033] 第二部分 LEC 7-12 Networking 笔记</p></a></div><script type="text/javascript"> $(function () { const origin = "https://giscus.app"; const iframe = "iframe.giscus-frame"; const lightTheme = "light"; const darkTheme = "dark_dimmed"; let initTheme = lightTheme; if ($("html[data-mode=dark]").length > 0 || ($("html[data-mode]").length == 0 && window.matchMedia("(prefers-color-scheme: dark)").matches)) { initTheme = darkTheme; } let giscusAttributes = { "src": "https://giscus.app/client.js", "data-repo": "Miigon/blog", "data-repo-id": "MDEwOlJlcG9zaXRvcnkzMjI1MjkwNzA=", "data-category": "BlogComments", "data-category-id": "DIC_kwDOEzlnLs4CQ6Y4", "data-mapping": "pathname", "data-reactions-enabled": "1", "data-emit-metadata": "0", "data-theme": initTheme, "data-input-position": "top", "data-lang": "en", "crossorigin": "anonymous", "async": "" }; let giscusScript = document.createElement("script"); Object.entries(giscusAttributes).forEach(([key, value]) => giscusScript.setAttribute(key, value)); document.getElementById("tail-wrapper").prepend(giscusScript); addEventListener("message", (event) => { if (event.source === window && event.data && event.data.direction === ModeToggle.ID) { /* global theme mode changed */ const mode = event.data.message; const theme = (mode === ModeToggle.DARK_MODE ? darkTheme : lightTheme); const message = { setConfig: { theme: theme } }; const giscus = document.querySelector(iframe).contentWindow; giscus.postMessage({ giscus: message }, origin); } }); }); </script></div></div><footer class="row pl-3 pr-3"><div class="col-12 d-flex justify-content-between align-items-center text-muted pl-0 pr-0"><div class="footer-left"><p class="mb-0"> © 2023 <a href="https://github.com/Miigon">Miigon</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Customized Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><div id="access-tags"><div class="panel-heading">Trending Tags</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/operating-system/">operating system</a> <a class="post-tag" href="/tags/chinese/">Chinese</a> <a class="post-tag" href="/tags/system-design/">system design</a> <a class="post-tag" href="/tags/c/">C++</a> <a class="post-tag" href="/tags/course-recommendation/">course recommendation</a> <a class="post-tag" href="/tags/grpc/">gRPC</a> <a class="post-tag" href="/tags/translated/">translated</a> <a class="post-tag" href="/tags/announcement/">announcement</a> <a class="post-tag" href="/tags/c-standard/">c++ standard</a> <a class="post-tag" href="/tags/computer-system/">computer system</a></div></div></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a><div id="notification" class="toast" role="alert" aria-live="assertive" aria-atomic="true" data-animation="true" data-autohide="false"><div class="toast-header"> <button type="button" class="ml-2 ml-auto close" data-dismiss="toast" aria-label="Close"> <span aria-hidden="true">&times;</span> </button></div><div class="toast-body text-center pt-0"><p class="pl-2 pr-2 mb-3">A new version of content is available.</p><button type="button" class="btn btn-primary" aria-label="Update"> Update </button></div></div><script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No results found.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/magnific-popup@1/dist/jquery.magnific-popup.min.js,npm/lozad/dist/lozad.min.js,npm/clipboard@2/dist/clipboard.min.js"></script> <script src="https://cdn.jsdelivr.net/combine/npm/dayjs@1/dayjs.min.js,npm/dayjs@1/locale/en.min.js,npm/dayjs@1/plugin/relativeTime.min.js,npm/dayjs@1/plugin/localizedFormat.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.bundle.min.js"></script> <script defer src="/app.js"></script>
