<!DOCTYPE html><html lang="en" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="generator" content="Jekyll v4.2.2" /><meta property="og:title" content="Linux 是否有 zombie thread？从glibc和内核源码探究" /><meta property="og:locale" content="en" /><meta name="description" content="系统编程课上遇到的一个问题：Linux下，如果一个 pthread_create 创建的线程没有被 pthread_join 回收，是否会和僵尸进程一样，产生“僵尸线程”，并一直占用一个 pid/tid？" /><meta property="og:description" content="系统编程课上遇到的一个问题：Linux下，如果一个 pthread_create 创建的线程没有被 pthread_join 回收，是否会和僵尸进程一样，产生“僵尸线程”，并一直占用一个 pid/tid？" /><link rel="canonical" href="https://blog.miigon.net/posts/does-linux-has-zombie-thread/" /><meta property="og:url" content="https://blog.miigon.net/posts/does-linux-has-zombie-thread/" /><meta property="og:site_name" content="Miigon’s blog" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2022-11-23T17:47:00+08:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="Linux 是否有 zombie thread？从glibc和内核源码探究" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2022-11-25T14:05:20+08:00","datePublished":"2022-11-23T17:47:00+08:00","description":"系统编程课上遇到的一个问题：Linux下，如果一个 pthread_create 创建的线程没有被 pthread_join 回收，是否会和僵尸进程一样，产生“僵尸线程”，并一直占用一个 pid/tid？","headline":"Linux 是否有 zombie thread？从glibc和内核源码探究","mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.miigon.net/posts/does-linux-has-zombie-thread/"},"url":"https://blog.miigon.net/posts/does-linux-has-zombie-thread/"}</script><title>Linux 是否有 zombie thread？从glibc和内核源码探究 | Miigon's blog</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="Miigon's blog"><meta name="application-name" content="Miigon's blog"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link rel="dns-prefetch" href="https://fonts.gstatic.com" crossorigin><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://cdn.jsdelivr.net" ><link rel="dns-prefetch" href="https://cdn.jsdelivr.net" ><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Lato&family=Source+Sans+Pro:wght@400;600;700;900&display=swap"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get MODE_ATTR() { return "data-mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } static get ID() { return "mode-toggle"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } let self = this; /* always follow the system prefers */ this.sysDarkPrefers.addEventListener("change", () => { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.notify(); }); } /* constructor() */ get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode === ModeToggle.DARK_MODE; } get isLightMode() { return this.mode === ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer)) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } setDark() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_ATTR); sessionStorage.removeItem(ModeToggle.MODE_KEY); } /* Notify another plugins that the theme mode has changed */ notify() { window.postMessage({ direction: ModeToggle.ID, message: this.modeStatus }, "*"); } } /* ModeToggle */ const toggle = new ModeToggle(); function flipMode() { if (toggle.hasMode) { if (toggle.isSysDarkPrefer) { if (toggle.isLightMode) { toggle.clearMode(); } else { toggle.setLight(); } } else { if (toggle.isDarkMode) { toggle.clearMode(); } else { toggle.setDark(); } } } else { if (toggle.isSysDarkPrefer) { toggle.setLight(); } else { toggle.setDark(); } } toggle.notify(); } /* flipMode() */ </script><body data-spy="scroll" data-target="#toc" data-topbar-visible="true"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" class="mx-auto"> <img src="/assets/img/avatar.png" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">Miigon's blog</a></div><div class="site-subtitle font-italic">My ideas, thoughts and experiences</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tag ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info-circle ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center align-items-center"> <button class="mode-toggle btn" aria-label="Switch Mode"> <i class="fas fa-adjust"></i> </button> <span class="icon-border"></span> <a href="https://github.com/Miigon" aria-label="github" target="_blank" rel="noopener"> <i class="fab fa-github-alt"></i> </a> <a href="https://twitter.com/" aria-label="twitter" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['miigon.pg','gmail.com'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="https://stackoverflow.com/users/7509248/miigon" aria-label="stack-overflow" target="_blank" rel="noopener"> <i class="fab fa-stack-overflow"></i> </a></div></div><div id="topbar-wrapper"><div id="topbar" class="container d-flex align-items-center justify-content-between h-100 pl-3 pr-3 pl-md-4 pr-md-4"> <span id="breadcrumb"> <span> <a href="/"> Home </a> </span> <span>Linux 是否有 zombie thread？从glibc和内核源码探究</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..."> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper" class="d-flex justify-content-center"><div id="main" class="container pl-xl-4 pr-xl-4"><div class="row"><div id="core-wrapper" class="col-12 col-lg-11 col-xl-9 pr-xl-4"><div class="post pl-1 pr-1 pl-md-2 pr-md-2"><h1 data-toc-skip>Linux 是否有 zombie thread？从glibc和内核源码探究</h1><div class="post-meta text-muted"> <span> Posted <em class="" data-ts="1669196820" data-df="ll" data-toggle="tooltip" data-placement="bottom"> Nov 23, 2022 </em> </span> <span> Updated <em class="" data-ts="1669356320" data-df="ll" data-toggle="tooltip" data-placement="bottom"> Nov 25, 2022 </em> </span><div class="d-flex justify-content-between"> <span> By <em> <a href="https://github.com/Miigon">Miigon</a> </em> </span><div> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="5762 words"> <em>32 min</em> read</span></div></div></div><div class="post-content"><p>系统编程课上遇到的一个问题：Linux下，如果一个 <code class="language-plaintext highlighter-rouge">pthread_create</code> 创建的线程没有被 <code class="language-plaintext highlighter-rouge">pthread_join</code> 回收，是否会和僵尸进程一样，产生“僵尸<strong>线程</strong>”，并一直占用一个 pid/tid？</p><h1 id="猜想">猜想</h1><h2 id="僵尸进程"><span class="mr-2">僵尸进程</span><a href="#僵尸进程" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>对于进程与子进程来说，如果子进程退出了，但是父进程不对子进程进行 reap （即使用 wait/waitpid 对子进程进行回收），则子进程的 PCB（内核中的 task_struct）依然会保留，用于记录返回状态直到父进程获取，并且状态将被设置成 ZOMBIE，即产生“僵尸线程”。</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">if</span><span class="p">(</span><span class="n">fork</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// child exits immediately</span>
    <span class="p">}</span>
    <span class="k">while</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span> <span class="c1">// parent loops</span>
<span class="p">}</span>
</pre></table></code></div></div><p>运行后可以看到子进程 607727 的状态为 Zombie，并且在最后有 <code class="language-plaintext highlighter-rouge">&lt;defunct&gt;</code> 标志。</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre>USER         PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
miigon    607726 97.5  0.0   2640   988 pts/0    R+   21:55   0:28 ./child
miigon    607727  0.0  0.0      0     0 pts/0    Z+   21:55   0:00 [child] &lt;defunct&gt;
</pre></table></code></div></div><h2 id="僵尸线程"><span class="mr-2">僵尸<em>线程</em>？</span><a href="#僵尸线程" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;pthread.h&gt;</span><span class="cp">
</span>
<span class="kt">void</span> <span class="o">*</span><span class="nf">child_thread</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// child thread exits immediately.</span>
    <span class="k">return</span> <span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="mi">666</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">pthread_t</span> <span class="n">t1</span><span class="p">;</span>

    <span class="n">pthread_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">t1</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">child_thread</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

    <span class="k">while</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="c1">// parent and child never join.</span>
    <span class="c1">// pthread_join(t1, NULL);</span>
<span class="p">}</span>
</pre></table></code></div></div><p>子线程启动后马上返回，而父线程无限循环，并且不 join 子线程，不检查其返回状态。</p><p>Linux 内核中（至少在调度上）并不区分线程和进程，都视为 task，故合理猜想：可能这里的 pthread_create 和 pthread_join 也可以类比 fork 和 wait，如果一个线程被创建后，不进行 pthread_join，那在子线程执行结束后，可能子线程也会进入 Zombie 状态，直至被父线程回收？（猜想）</p><h1 id="验证">验证</h1><p>对上述猜想进行验证，编译运行上述线程代码：</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre>$ gcc pt.c -o pt -lpthread -g
$ ./pt
</pre></table></code></div></div><p>如果我们的猜想正确，当查看 pt 的所有线程的时候，理论上应该可以看到一个主线程，还有一个 defunct 状态的子线程 task。</p><p>使用 ps 检查 pt 的所有线程：</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre>$ ps -T -C pt
    PID    SPID TTY          TIME CMD
 610281  610281 pts/1    00:00:09 pt
</pre></table></code></div></div><p>发现只有一个主线程（<code class="language-plaintext highlighter-rouge">PID == SPID</code>），没有观察到 defunct 状态的子线程，子线程退出后虽然主线程没有 pthread_join 读取其返回值，但是子线程 pid/tid 依然被回收了，并没有进入僵尸状态。</p><p>验证一下如果把子线程函数换成死循环，运行后可以观察到子线程存在，说明测试方法没有问题，排除子线程没有创建成功或者观测方法有误的可能性：</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="kt">void</span> <span class="o">*</span><span class="nf">child_thread</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">while</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre>$ ps -T -C pt
    PID    SPID TTY          TIME CMD
 610762  610762 pts/1    00:00:05 pt
 610762  610763 pts/1    00:00:05 pt
</pre></table></code></div></div><p>说明我们的猜想是不准确的，并没有观察到子线程退出后变为僵尸状态。</p><h1 id="探究">探究</h1><p>由于已知在 Linux 上，创建线程和创建进程实际上走的是同一套机制，本质上都是 fork/clone，只是调用者指定的资源共享程度不同，所以差异出现的诱因只能是位于 fork/clone 的调用者，即位于 pthread 的代码中。</p><p>pthread 在 Linux 上一般是由 libc 实现的，最常见的 libc 是 glibc（另一个 Linux 上常用的 libc 的例子是 musl，更轻量，不展开）。glibc 的 pthread 实现叫做 NPTL（替换掉之前的远古实现叫 LinuxThreads，也不展开），可以在 <a href="https://codebrowser.dev/glibc/glibc/nptl/">https://codebrowser.dev/glibc/glibc/nptl/</a> 很方便地在线浏览相关代码。</p><blockquote><p>本文环境 ubuntuserver 22.04.1 + linux5.15.0 + glibc2.35；所有源代码文件以这些版本为准。 如果发现 glibc/NPTL 部分代码的锁进很乱，那是由于原来的代码就是这么锁进的，不是文章格式化错误。</p></blockquote><h2 id="线程等待-pthread_join"><span class="mr-2">线程等待 pthread_join()</span><a href="#线程等待-pthread_join" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>首先检查 pthread_join 的源码，因为根据我们的猜想，如果是会产生“僵尸线程”的话，pthread_join 要回收这个“僵尸线程”，必然要调用 wait/waitpid 系的系统调用。</p><p><a href="https://codebrowser.dev/glibc/glibc/nptl/pthread_join.c.html">https://codebrowser.dev/glibc/glibc/nptl/pthread_join.c.html</a> <a href="https://codebrowser.dev/glibc/glibc/nptl/pthread_join_common.c.html">https://codebrowser.dev/glibc/glibc/nptl/pthread_join_common.c.html</a></p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="c1">// pthread_join.c:21</span>
<span class="kt">int</span>
<span class="nf">___pthread_join</span> <span class="p">(</span><span class="n">pthread_t</span> <span class="n">threadid</span><span class="p">,</span> <span class="kt">void</span> <span class="o">**</span><span class="n">thread_return</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">return</span> <span class="n">__pthread_clockjoin_ex</span> <span class="p">(</span><span class="n">threadid</span><span class="p">,</span> <span class="n">thread_return</span><span class="p">,</span> <span class="mi">0</span> <span class="cm">/* Ignored */</span><span class="p">,</span>
				 <span class="nb">NULL</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><p>核心部分：</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
</pre><td class="rouge-code"><pre><span class="c1">// pthread_join_common.c:35</span>
<span class="kt">int</span>
<span class="nf">__pthread_clockjoin_ex</span> <span class="p">(</span><span class="n">pthread_t</span> <span class="n">threadid</span><span class="p">,</span> <span class="kt">void</span> <span class="o">**</span><span class="n">thread_return</span><span class="p">,</span>
                        <span class="n">clockid_t</span> <span class="n">clockid</span><span class="p">,</span>
                        <span class="k">const</span> <span class="k">struct</span> <span class="n">__timespec64</span> <span class="o">*</span><span class="n">abstime</span><span class="p">,</span> <span class="n">bool</span> <span class="n">block</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">struct</span> <span class="n">pthread</span> <span class="o">*</span><span class="n">pd</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">pthread</span> <span class="o">*</span><span class="p">)</span> <span class="n">threadid</span><span class="p">;</span>
  
  <span class="c1">// ......</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">block</span><span class="p">)</span> <span class="c1">// true</span>
    <span class="p">{</span>
	  <span class="c1">// 等待线程执行完成</span>
      <span class="n">pthread_cleanup_push</span> <span class="p">(</span><span class="n">cleanup</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pd</span><span class="o">-&gt;</span><span class="n">joinid</span><span class="p">);</span>

      <span class="n">pid_t</span> <span class="n">tid</span><span class="p">;</span>
      <span class="k">while</span> <span class="p">((</span><span class="n">tid</span> <span class="o">=</span> <span class="n">atomic_load_acquire</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">pd</span><span class="o">-&gt;</span><span class="n">tid</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="c1">// 获取锁</span>
        <span class="p">{</span>
	  <span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">__futex_abstimed_wait_cancelable64</span> <span class="p">(</span> <span class="c1">// 通过等待一个 futex 来等待线程执行完成，只是 futex syscall 的封装，内部并没有调用 wait/waitpid</span>
	    <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">pd</span><span class="o">-&gt;</span><span class="n">tid</span><span class="p">,</span> <span class="n">tid</span><span class="p">,</span> <span class="n">clockid</span><span class="p">,</span> <span class="n">abstime</span><span class="p">,</span> <span class="n">LLL_SHARED</span><span class="p">);</span>
	  <span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="n">ETIMEDOUT</span> <span class="o">||</span> <span class="n">ret</span> <span class="o">==</span> <span class="n">EOVERFLOW</span><span class="p">)</span>
	    <span class="p">{</span>
	      <span class="n">result</span> <span class="o">=</span> <span class="n">ret</span><span class="p">;</span>
	      <span class="k">break</span><span class="p">;</span>
	    <span class="p">}</span>
	<span class="p">}</span>

      <span class="n">pthread_cleanup_pop</span> <span class="p">(</span><span class="mi">0</span><span class="p">);</span>
    <span class="p">}</span>

  <span class="kt">void</span> <span class="o">*</span><span class="n">pd_result</span> <span class="o">=</span> <span class="n">pd</span><span class="o">-&gt;</span><span class="n">result</span><span class="p">;</span> <span class="c1">// 获取线程的返回值，说明线程已经执行完成</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">__glibc_likely</span> <span class="p">(</span><span class="n">result</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span> <span class="c1">// 等待成功</span>
    <span class="p">{</span>
      <span class="cm">/* We mark the thread as terminated and as joined.  */</span>
      <span class="n">pd</span><span class="o">-&gt;</span><span class="n">tid</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

      <span class="cm">/* Store the return value if the caller is interested.  */</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">thread_return</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
	<span class="o">*</span><span class="n">thread_return</span> <span class="o">=</span> <span class="n">pd_result</span><span class="p">;</span>

      <span class="cm">/* Free the TCB.  */</span>
      <span class="n">__nptl_free_tcb</span> <span class="p">(</span><span class="n">pd</span><span class="p">);</span> <span class="c1">// 释放 TCB，即 pthread 结构体</span>
    <span class="p">}</span>

  <span class="c1">// ......</span>
<span class="p">}</span>

</pre></table></code></div></div><p>通过 JOIN 的这部分关键代码，可以推测出这几个重要信息：</p><ul><li>glibc 上 pthread_join 等待子线程完成，并不是通过传统的 wait/waitpid 实现的，而是由 pthread 自己再维护了一个 futex （在这里作为「线程执行完毕」的条件变量 condition variable），通过等待这个 futex 实现。<li>通过 <code class="language-plaintext highlighter-rouge">__nptl_free_tcb(pd)</code> 可以知道，所谓的 “TCB” 这个概念实际上就是 pthread 结构体本身（pthread_t 是指向其的指针），并且是存储在用户态的，由 glibc/nptl 管理，而不是在内核态管理。<li>pthread_join 只负责释放用户态 pthread 结构体（pd），而和释放线程在内核中占用的资源没有关系。</ul><p>综合「pthread_join 不负责回收（reap）内核态线程」以及「观察到子线程在执行完成后，在主线程什么都没有做的情况下自己消失了」这两个信息，进一步猜测子线程是退出后被内核自动 reap 掉了。</p><p>但是按照正常进程来说，除非是父进程设置了 <code class="language-plaintext highlighter-rouge">signal(SIGCHLD, SIG_IGN);</code>，否则操作系统是不会自动 reap 掉子进程的，假设内核不区分进程和线程，对线程而言应该也是这个行为（需要等待父进程 reap，否则就处于 ZOMBIE 状态）才对。</p><p>由此猜测有可能是两种可能性中的一种：</p><ol><li>内核可能对线程 task 有一定的特殊照顾/特殊处理，使得线程的 task 会在退出时自动 reap，而进程则等待父进程回收。<li>也有一种可能性是 pthread 自己在子线程执行末尾做了特殊处理，让操作系统 reap 掉自己（真的可能做到吗？）</ol><p>后面的内容和探究都是围绕尝试检验这两个猜想展开的。</p><h2 id="线程创建-pthread_create"><span class="mr-2">线程创建 pthread_create()</span><a href="#线程创建-pthread_create" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>由于已知线程 task 不是由 pthread_join 回收的，必然是内核或者 pthread 在什么其他地方进行了回收，故追踪整个线程 pthread 从创建开始的生命周期：</p><p><a href="https://codebrowser.dev/glibc/glibc/nptl/pthread_create.c.html">https://codebrowser.dev/glibc/glibc/nptl/pthread_create.c.html</a></p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
</pre><td class="rouge-code"><pre><span class="c1">// pthread_create.c:619</span>
<span class="kt">int</span>
<span class="nf">__pthread_create_2_1</span> <span class="p">(</span><span class="n">pthread_t</span> <span class="o">*</span><span class="n">newthread</span><span class="p">,</span> <span class="k">const</span> <span class="n">pthread_attr_t</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
		      <span class="kt">void</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="n">start_routine</span><span class="p">)</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">),</span> <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">void</span> <span class="o">*</span><span class="n">stackaddr</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
  <span class="kt">size_t</span> <span class="n">stacksize</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

  <span class="c1">// ......</span>

  <span class="c1">// 分配 TCB （pthread 结构体）和线程栈空间</span>
  <span class="k">struct</span> <span class="n">pthread</span> <span class="o">*</span><span class="n">pd</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="n">allocate_stack</span> <span class="p">(</span><span class="n">iattr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">stackaddr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">stacksize</span><span class="p">);</span>
  <span class="kt">int</span> <span class="n">retval</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

  <span class="c1">// ......</span>
  
  <span class="c1">// 初始化 TCB</span>
  <span class="n">pd</span><span class="o">-&gt;</span><span class="n">start_routine</span> <span class="o">=</span> <span class="n">start_routine</span><span class="p">;</span> <span class="c1">// 子线程入口</span>
  <span class="n">pd</span><span class="o">-&gt;</span><span class="n">arg</span> <span class="o">=</span> <span class="n">arg</span><span class="p">;</span> <span class="c1">// 子线程入口参数</span>
  <span class="n">pd</span><span class="o">-&gt;</span><span class="n">c11</span> <span class="o">=</span> <span class="n">c11</span><span class="p">;</span>

  <span class="c1">// ......</span>

  <span class="cm">/* Setup tcbhead.  */</span>
  <span class="n">tls_setup_tcbhead</span> <span class="p">(</span><span class="n">pd</span><span class="p">);</span>

  <span class="cm">/* Pass the descriptor to the caller.  */</span>
  <span class="o">*</span><span class="n">newthread</span> <span class="o">=</span> <span class="p">(</span><span class="n">pthread_t</span><span class="p">)</span> <span class="n">pd</span><span class="p">;</span>

  <span class="c1">// ......</span>

  <span class="c1">// .......some more signal related stuff</span>

  <span class="cm">/* Start the thread.  */</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">__glibc_unlikely</span> <span class="p">(</span><span class="n">report_thread_creation</span> <span class="p">(</span><span class="n">pd</span><span class="p">)))</span> <span class="c1">// 如果需要报告 TD_CREATE 事件</span>
    <span class="p">{</span>
      <span class="c1">// ......在我们的例子中不会走到这里，忽略</span>
      <span class="c1">// event 是 debug 时用的，例如用来通知 gdb 线程已经创建</span>
    <span class="p">}</span>
  <span class="k">else</span>
    <span class="c1">// ！！创建内核态线程 task！！</span>
    <span class="n">retval</span> <span class="o">=</span> <span class="n">create_thread</span> <span class="p">(</span><span class="n">pd</span><span class="p">,</span> <span class="n">iattr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">stopped_start</span><span class="p">,</span> <span class="n">stackaddr</span><span class="p">,</span>
			    <span class="n">stacksize</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">thread_ran</span><span class="p">);</span>

  <span class="c1">// ......</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">__glibc_unlikely</span> <span class="p">(</span><span class="n">retval</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">))</span>
    <span class="p">{</span>
      <span class="c1">// ......错误处理，忽略</span>
    <span class="p">}</span>
  <span class="k">else</span>
    <span class="p">{</span>
	  <span class="c1">// 放开 pd 上的锁，让子线程自由运行</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">stopped_start</span><span class="p">)</span> <span class="n">lll_unlock</span> <span class="p">(</span><span class="n">pd</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">LLL_PRIVATE</span><span class="p">);</span>

      <span class="c1">// ......</span>
    <span class="p">}</span>

 <span class="nl">out:</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">destroy_default_attr</span><span class="p">)</span>
    <span class="n">__pthread_attr_destroy</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">default_attr</span><span class="p">.</span><span class="n">external</span><span class="p">);</span>

  <span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

</pre></table></code></div></div><p>pthread_create 做的事情并不复杂：</p><ol><li>为子线程分配栈空间和 TCB（pd）<li>准备/配置好 TCB 各项参数，包括子线程入口和入口参数<li>调用 <code class="language-plaintext highlighter-rouge">create_thread()</code> 启动子线程 task</ol><h2 id="线程-task-创建-create_thread"><span class="mr-2">线程 task 创建 create_thread()</span><a href="#线程-task-创建-create_thread" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>这个函数在 <code class="language-plaintext highlighter-rouge">pthread_create()</code> 中负责为子线程创建实际的内核态 task，通过调用 clone 实现（<code class="language-plaintext highlighter-rouge">__clone_internal()</code> 是 clone/clone2/clone3 的简单封装）。</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
</pre><td class="rouge-code"><pre><span class="c1">// pthread_create.c:231</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">create_thread</span> <span class="p">(</span><span class="k">struct</span> <span class="n">pthread</span> <span class="o">*</span><span class="n">pd</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">pthread_attr</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
			  <span class="n">bool</span> <span class="o">*</span><span class="n">stopped_start</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">stackaddr</span><span class="p">,</span>
			  <span class="kt">size_t</span> <span class="n">stacksize</span><span class="p">,</span> <span class="n">bool</span> <span class="o">*</span><span class="n">thread_ran</span><span class="p">)</span>
<span class="p">{</span>
  <span class="c1">// ......</span>
  
  <span class="cm">/* We rely heavily on various flags the CLONE function understands:

     CLONE_VM, CLONE_FS, CLONE_FILES
	These flags select semantics with shared address space and
	file descriptors according to what POSIX requires.

     ...... 篇幅原因缩略，查看原始文件或 `man clone` 查询每个 flag 作用

     The termination signal is chosen to be zero which means no signal
     is sent.  */</span>
  <span class="k">const</span> <span class="kt">int</span> <span class="n">clone_flags</span> <span class="o">=</span> <span class="p">(</span><span class="n">CLONE_VM</span> <span class="o">|</span> <span class="n">CLONE_FS</span> <span class="o">|</span> <span class="n">CLONE_FILES</span> <span class="o">|</span> <span class="n">CLONE_SYSVSEM</span>
			   <span class="o">|</span> <span class="n">CLONE_SIGHAND</span> <span class="o">|</span> <span class="n">CLONE_THREAD</span> <span class="c1">// ！！注意到这个 CLONE_THREAD flag</span>
			   <span class="o">|</span> <span class="n">CLONE_SETTLS</span> <span class="o">|</span> <span class="n">CLONE_PARENT_SETTID</span>
			   <span class="o">|</span> <span class="n">CLONE_CHILD_CLEARTID</span>
			   <span class="o">|</span> <span class="mi">0</span><span class="p">);</span>

  <span class="n">TLS_DEFINE_INIT_TP</span> <span class="p">(</span><span class="n">tp</span><span class="p">,</span> <span class="n">pd</span><span class="p">);</span>

  <span class="k">struct</span> <span class="n">clone_args</span> <span class="n">args</span> <span class="o">=</span>
    <span class="p">{</span>
      <span class="p">.</span><span class="n">flags</span> <span class="o">=</span> <span class="n">clone_flags</span><span class="p">,</span> <span class="c1">// clone flags</span>
      <span class="p">.</span><span class="n">pidfd</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uintptr_t</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">pd</span><span class="o">-&gt;</span><span class="n">tid</span><span class="p">,</span>
      <span class="p">.</span><span class="n">parent_tid</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uintptr_t</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">pd</span><span class="o">-&gt;</span><span class="n">tid</span><span class="p">,</span> <span class="c1">// CLONE_PARENT_SETTID</span>
      <span class="p">.</span><span class="n">child_tid</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uintptr_t</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">pd</span><span class="o">-&gt;</span><span class="n">tid</span><span class="p">,</span>
      <span class="p">.</span><span class="n">stack</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uintptr_t</span><span class="p">)</span> <span class="n">stackaddr</span><span class="p">,</span>
      <span class="p">.</span><span class="n">stack_size</span> <span class="o">=</span> <span class="n">stacksize</span><span class="p">,</span>
      <span class="p">.</span><span class="n">tls</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uintptr_t</span><span class="p">)</span> <span class="n">tp</span><span class="p">,</span>              <span class="c1">// CLONE_SETTLS</span>
    <span class="p">};</span>
  <span class="c1">// clone，子线程从 start_thread() 开始执行</span>
  <span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">__clone_internal</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">args</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">start_thread</span><span class="p">,</span> <span class="n">pd</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">__glibc_unlikely</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">errno</span><span class="p">;</span>

  <span class="c1">// ......</span>

  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

</pre></table></code></div></div><p>这里注意到，调用 clone 的时候，传递给内核的 flags 中含有 CLONE_THREAD 这个 flag。</p><p>这个 flag 意味着用户态显式地告知了内核，克隆出来的 task 应该被作为一个线程看待。先不管这个 flag 的具体影响是什么，传递这个 flag 这件事情本身足以说明，内核实际上对普通进程 task 和线程 task 还是有专门的区分的，并不是除了资源共享程度不同以外其他都完全一模一样。</p><p>我们前面针对子线程的 task 会被自动 reap 掉这件事，做出了两种猜想：可能是内核特殊处理了线程 task，也可能是 pthread 自己在子线程末尾回收了子线程。</p><p>CLONE_THREAD 这个 flag 的存在加大了第一种猜想正确的可能性，不过并不完全排除第二种猜想，要排除第二种猜想，需要看子线程的用户例程执行完毕后，在 pthread 中都做了什么，有没有回收掉子线程 task。</p><h2 id="子线程-task-执行入口-start_thread"><span class="mr-2">子线程 task 执行入口 start_thread()</span><a href="#子线程-task-执行入口-start_thread" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p><code class="language-plaintext highlighter-rouge">create_thread()</code> 创建的子线程的执行入口固定为 <code class="language-plaintext highlighter-rouge">start_thread()</code>，这个函数再从 <code class="language-plaintext highlighter-rouge">pd-&gt;start_routine</code> 和 <code class="language-plaintext highlighter-rouge">pd-&gt;args</code> 获得用户函数的地址和参数，并跳转到用户函数开始执行。</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
</pre><td class="rouge-code"><pre><span class="cm">/* Local function to start thread and handle cleanup.  */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="k">_Noreturn</span>
<span class="nf">start_thread</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">struct</span> <span class="n">pthread</span> <span class="o">*</span><span class="n">pd</span> <span class="o">=</span> <span class="n">arg</span><span class="p">;</span>

  <span class="c1">// ......</span>

  <span class="c1">// ......thread local storage and stuff</span>

  <span class="c1">// ......unwinders and stuff, for cancellation and/or exception handling</span>

  <span class="c1">// ......</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">__glibc_likely</span> <span class="p">(</span><span class="o">!</span> <span class="n">not_first_call</span><span class="p">))</span>
    <span class="p">{</span>
      <span class="cm">/* Store the new cleanup handler info.  */</span>
      <span class="n">THREAD_SETMEM</span> <span class="p">(</span><span class="n">pd</span><span class="p">,</span> <span class="n">cleanup_jmp_buf</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">unwind_buf</span><span class="p">);</span>

      <span class="n">__libc_signal_restore_set</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">pd</span><span class="o">-&gt;</span><span class="n">sigmask</span><span class="p">);</span>

      <span class="n">LIBC_PROBE</span> <span class="p">(</span><span class="n">pthread_start</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="p">(</span><span class="n">pthread_t</span><span class="p">)</span> <span class="n">pd</span><span class="p">,</span> <span class="n">pd</span><span class="o">-&gt;</span><span class="n">start_routine</span><span class="p">,</span> <span class="n">pd</span><span class="o">-&gt;</span><span class="n">arg</span><span class="p">);</span>

      <span class="cm">/* Run the code the user provided.  */</span>
      <span class="kt">void</span> <span class="o">*</span><span class="n">ret</span><span class="p">;</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">pd</span><span class="o">-&gt;</span><span class="n">c11</span><span class="p">)</span>
	<span class="p">{</span>
	  <span class="c1">// ......c11 标准下多了一个类型转换问题，我们不使用 c11 标准，不走到这里，略</span>
	<span class="p">}</span>
      <span class="k">else</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">pd</span><span class="o">-&gt;</span><span class="n">start_routine</span> <span class="p">(</span><span class="n">pd</span><span class="o">-&gt;</span><span class="n">arg</span><span class="p">);</span> <span class="c1">// 使用用户提供的参数，调用用户函数，得到返回值 ret</span>
      <span class="n">THREAD_SETMEM</span> <span class="p">(</span><span class="n">pd</span><span class="p">,</span> <span class="n">result</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span> <span class="c1">// 用户函数返回值 ret 存入到 pd-&gt;result</span>
    <span class="p">}</span>

  <span class="c1">// ======= 到这里，用户函数已经执行完毕，子线程任务完成，进入结束阶段 ======</span>

  <span class="c1">// thread local storage、thread local data 析构</span>
<span class="cp">#ifndef SHARED
</span>  <span class="k">if</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">__call_tls_dtors</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
<span class="cp">#endif
</span>    <span class="n">__call_tls_dtors</span> <span class="p">();</span>

  <span class="cm">/* Run the destructor for the thread-local data.  */</span>
  <span class="n">__nptl_deallocate_tsd</span> <span class="p">();</span>

  <span class="cm">/* Clean up any state libc stored in thread-local variables.  */</span>
  <span class="n">__libc_thread_freeres</span> <span class="p">();</span>

  <span class="cm">/* Report the death of the thread if this is wanted.  */</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">__glibc_unlikely</span> <span class="p">(</span><span class="n">pd</span><span class="o">-&gt;</span><span class="n">report_events</span><span class="p">))</span>
    <span class="p">{</span>
    <span class="c1">// ......在需要时，报告 TD_DEATH 事件，略</span>
    <span class="c1">// event 是 debug 时用的，例如用来通知 gdb 线程已经退出</span>
    <span class="p">}</span>

  <span class="c1">// ......</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">__glibc_unlikely</span> <span class="p">(</span><span class="n">atomic_decrement_and_test</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">__nptl_nthreads</span><span class="p">)))</span>
    <span class="cm">/* This was the last thread.  */</span>
    <span class="n">exit</span> <span class="p">(</span><span class="mi">0</span><span class="p">);</span> <span class="c1">// 如果这个线程是最后一个线程，退出整个线程组（thread group）</span>

  <span class="c1">// ......signal and mutex and stuff</span>

  <span class="c1">// ......如果栈空间是 pthread 分配的（而不是用户创建线程时提供的），则回收栈空间</span>

  <span class="c1">// ......</span>

  <span class="c1">// 如果线程被 pthread_detach 过，则顺便回收 TCB（注意 TCB 不是 task_struct，是用户态 pthread 结构体）</span>
  <span class="c1">// 默认行为是不在这里回收 TCB，我们的例子中也是默认情况，即不会在这里执行 `__nptl_free_tcb(pd)`，而是需要等到 pthread_join() 时才会回收 TCB</span>
  <span class="c1">// 这是由于 pd 结构体中含有用户态返回值 pd-&gt;result 可能会被父线程需要；pthread_detach 则意味着父线程不关心子线程的执行结果。</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">IS_DETACHED</span> <span class="p">(</span><span class="n">pd</span><span class="p">))</span>
    <span class="cm">/* Free the TCB.  */</span>
    <span class="n">__nptl_free_tcb</span> <span class="p">(</span><span class="n">pd</span><span class="p">);</span>

<span class="nl">out:</span>
  <span class="c1">// 子线程完全结束，最后一步：调用 sys_exit 系统调用，结束【子线程】（不是整个进程）</span>
  <span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">INTERNAL_SYSCALL_CALL</span> <span class="p">(</span><span class="n">exit</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

  <span class="cm">/* NOTREACHED */</span>
<span class="p">}</span>
</pre></table></code></div></div><p>注意到最后一步 <code class="language-plaintext highlighter-rouge">sys_exit</code> 和常见的 <code class="language-plaintext highlighter-rouge">exit()/_exit()</code> 不同，前者是系统调用，后者是由 libc 提供的用户态包装方法。</p><p>两者的作用效果也不一样：</p><ul><li><code class="language-plaintext highlighter-rouge">sys_exit</code> 是退出当前【调度单元】，即 task，在这里是指当前【线程】<li>而 <code class="language-plaintext highlighter-rouge">exit()/_exit()</code> 实际上包装的是 <code class="language-plaintext highlighter-rouge">sys_exit_group</code> 系统调用，代表退出整个【线程组】，即整个进程的所有线程。</ul><blockquote><p>命名的混乱是历史原因，由于一开始 Linux 只支持多进程，最初 <code class="language-plaintext highlighter-rouge">exit()/_exit()</code> 也的确封装的是 sys_exit。</p><p>而后来加入多线程后，Linux 在内核态内引入了一个新概念：thread group。原来的进程变成了 task，<code class="language-plaintext highlighter-rouge">task_struct-&gt;pid</code> 变成了线程 id（<code class="language-plaintext highlighter-rouge">gettid()</code> 返回 <code class="language-plaintext highlighter-rouge">task_struct-&gt;pid</code>），而现在常说的进程 id，则是新的<code class="language-plaintext highlighter-rouge">task_struct-&gt;tgid</code>（thread group id，<code class="language-plaintext highlighter-rouge">getpid()</code> 返回 <code class="language-plaintext highlighter-rouge">task_struct-&gt;tgid</code> ）。同时，libc 的 <code class="language-plaintext highlighter-rouge">exit()/_exit()</code> 也被改为调用新的 sys_exit_group，即结束整个线程组。原来的 sys_exit 的作用不变，依然是结束一个调度单元 task，只是「调度单元」的概念改变了而已。</p><p>这个比较 hack 的方式，使得 linux 以较小的改动，实现了对线程的支持，坏处就是导致用户态的 “pid” 的概念和内核态中的 “pid” 的含义不一致，不留意的话容易混淆。</p></blockquote><p>可以看到，子线程的入口函数 <code class="language-plaintext highlighter-rouge">start_thread()</code>，在执行完用户函数后，销毁了栈和 thread local storage，然后执行了 sys_exit 结束子线程 task。</p><p>这个过程和多进程模型中一个子进程调用 <code class="language-plaintext highlighter-rouge">exit()</code> 退出线程是类似的，并不保证一定清理掉 task_struct，而是理论上有可能使 task 进入 ZOMBIE 状态。而且这里可以看到，pthread 也没有让子进程做（诸如自己 wait 自己？）之类的魔法来显式清理掉子进程的 task。</p><p>这说明我们之前的猜想2是不正确的，子线程的内核 task_struct 并不是 pthread 在子线程退出后进行特殊处理 reap 回收的。只能是 sys_exit 系统调用中，退出子线程 task 的时候，内核自己决定要直接 reap 掉这个 task。</p><blockquote><p>实际上猜想2本身也不可能，一个 task 不可能自己回收自己的资源，因为只有已经结束的 task 才能被回收，但是已经结束的 task 就无法执行任何代码了，也就没法回收自己。</p></blockquote><h2 id="退出子线程-sys_exit-系统调用"><span class="mr-2">退出子线程 sys_exit 系统调用</span><a href="#退出子线程-sys_exit-系统调用" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>前面通过排除，将我们子线程的 task 被 reap 的准确位置定位到了 sys_exit 中了。我们从用户态的 glibc 以及 pthread，继续进入到内核态代码的范围中。</p><p>前一小节结尾提到，我们发现子线程的 task 在用户态是正常 sys_exit 退出的，但是 sys_exit 后 pid 以及 task_struct 被马上回收掉，而不是像普通进程一样进入僵尸状态，这里看到内核 <code class="language-plaintext highlighter-rouge">do_exit()</code> 方法（sys_exit 系统调用的内核态处理函数）：</p><p><a href="https://elixir.bootlin.com/linux/v5.15/source/kernel/exit.c">https://elixir.bootlin.com/linux/v5.15/source/kernel/exit.c</a></p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
</pre><td class="rouge-code"><pre><span class="c1">// kernel/exit.c:727</span>
<span class="c1">// 不用仔细看这个函数的每一步，这里全放出来只是为了体现步骤有多么多而已</span>
<span class="kt">void</span> <span class="n">__noreturn</span> <span class="nf">do_exit</span><span class="p">(</span><span class="kt">long</span> <span class="n">code</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span> <span class="o">=</span> <span class="n">current</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">group_dead</span><span class="p">;</span>

	<span class="c1">// ......</span>

	<span class="n">profile_task_exit</span><span class="p">(</span><span class="n">tsk</span><span class="p">);</span>
	<span class="n">kcov_task_exit</span><span class="p">(</span><span class="n">tsk</span><span class="p">);</span>

	<span class="n">ptrace_event</span><span class="p">(</span><span class="n">PTRACE_EVENT_EXIT</span><span class="p">,</span> <span class="n">code</span><span class="p">);</span>

	<span class="n">validate_creds_for_do_exit</span><span class="p">(</span><span class="n">tsk</span><span class="p">);</span>

	<span class="c1">// ......</span>
	
	<span class="n">io_uring_files_cancel</span><span class="p">();</span>
	<span class="n">exit_signals</span><span class="p">(</span><span class="n">tsk</span><span class="p">);</span>  <span class="cm">/* sets PF_EXITING */</span>

	<span class="cm">/* sync mm's RSS info before statistics gathering */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tsk</span><span class="o">-&gt;</span><span class="n">mm</span><span class="p">)</span>
		<span class="n">sync_mm_rss</span><span class="p">(</span><span class="n">tsk</span><span class="o">-&gt;</span><span class="n">mm</span><span class="p">);</span>
	<span class="n">acct_update_integrals</span><span class="p">(</span><span class="n">tsk</span><span class="p">);</span>
	<span class="n">group_dead</span> <span class="o">=</span> <span class="n">atomic_dec_and_test</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tsk</span><span class="o">-&gt;</span><span class="n">signal</span><span class="o">-&gt;</span><span class="n">live</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">group_dead</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*
		 * If the last thread of global init has exited, panic
		 * immediately to get a useable coredump.
		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">is_global_init</span><span class="p">(</span><span class="n">tsk</span><span class="p">)))</span>
			<span class="n">panic</span><span class="p">(</span><span class="s">"Attempted to kill init! exitcode=0x%08x</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
				<span class="n">tsk</span><span class="o">-&gt;</span><span class="n">signal</span><span class="o">-&gt;</span><span class="n">group_exit_code</span> <span class="o">?:</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">code</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_POSIX_TIMERS
</span>		<span class="n">hrtimer_cancel</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tsk</span><span class="o">-&gt;</span><span class="n">signal</span><span class="o">-&gt;</span><span class="n">real_timer</span><span class="p">);</span>
		<span class="n">exit_itimers</span><span class="p">(</span><span class="n">tsk</span><span class="o">-&gt;</span><span class="n">signal</span><span class="p">);</span>
<span class="cp">#endif
</span>		<span class="k">if</span> <span class="p">(</span><span class="n">tsk</span><span class="o">-&gt;</span><span class="n">mm</span><span class="p">)</span>
			<span class="n">setmax_mm_hiwater_rss</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tsk</span><span class="o">-&gt;</span><span class="n">signal</span><span class="o">-&gt;</span><span class="n">maxrss</span><span class="p">,</span> <span class="n">tsk</span><span class="o">-&gt;</span><span class="n">mm</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">acct_collect</span><span class="p">(</span><span class="n">code</span><span class="p">,</span> <span class="n">group_dead</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">group_dead</span><span class="p">)</span>
		<span class="n">tty_audit_exit</span><span class="p">();</span>
	<span class="n">audit_free</span><span class="p">(</span><span class="n">tsk</span><span class="p">);</span>

	<span class="n">tsk</span><span class="o">-&gt;</span><span class="n">exit_code</span> <span class="o">=</span> <span class="n">code</span><span class="p">;</span>
	<span class="n">taskstats_exit</span><span class="p">(</span><span class="n">tsk</span><span class="p">,</span> <span class="n">group_dead</span><span class="p">);</span>

	<span class="n">exit_mm</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">group_dead</span><span class="p">)</span>
		<span class="n">acct_process</span><span class="p">();</span>
	<span class="n">trace_sched_process_exit</span><span class="p">(</span><span class="n">tsk</span><span class="p">);</span>

	<span class="n">exit_sem</span><span class="p">(</span><span class="n">tsk</span><span class="p">);</span>
	<span class="n">exit_shm</span><span class="p">(</span><span class="n">tsk</span><span class="p">);</span>
	<span class="n">exit_files</span><span class="p">(</span><span class="n">tsk</span><span class="p">);</span>
	<span class="n">exit_fs</span><span class="p">(</span><span class="n">tsk</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">group_dead</span><span class="p">)</span>
		<span class="n">disassociate_ctty</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
	<span class="n">exit_task_namespaces</span><span class="p">(</span><span class="n">tsk</span><span class="p">);</span>
	<span class="n">exit_task_work</span><span class="p">(</span><span class="n">tsk</span><span class="p">);</span>
	<span class="n">exit_thread</span><span class="p">(</span><span class="n">tsk</span><span class="p">);</span>

	<span class="n">perf_event_exit_task</span><span class="p">(</span><span class="n">tsk</span><span class="p">);</span>

	<span class="n">sched_autogroup_exit_task</span><span class="p">(</span><span class="n">tsk</span><span class="p">);</span>
	<span class="n">cgroup_exit</span><span class="p">(</span><span class="n">tsk</span><span class="p">);</span>

	<span class="n">flush_ptrace_hw_breakpoint</span><span class="p">(</span><span class="n">tsk</span><span class="p">);</span>

	<span class="n">exit_tasks_rcu_start</span><span class="p">();</span>
	<span class="n">exit_notify</span><span class="p">(</span><span class="n">tsk</span><span class="p">,</span> <span class="n">group_dead</span><span class="p">);</span>
	<span class="n">proc_exit_connector</span><span class="p">(</span><span class="n">tsk</span><span class="p">);</span>
	<span class="n">mpol_put_task_policy</span><span class="p">(</span><span class="n">tsk</span><span class="p">);</span>
<span class="cp">#ifdef CONFIG_FUTEX
</span>	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">pi_state_cache</span><span class="p">))</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">pi_state_cache</span><span class="p">);</span>
<span class="cp">#endif
</span>	<span class="cm">/*
	 * Make sure we are holding no locks:
	 */</span>
	<span class="n">debug_check_no_locks_held</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tsk</span><span class="o">-&gt;</span><span class="n">io_context</span><span class="p">)</span>
		<span class="n">exit_io_context</span><span class="p">(</span><span class="n">tsk</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tsk</span><span class="o">-&gt;</span><span class="n">splice_pipe</span><span class="p">)</span>
		<span class="n">free_pipe_info</span><span class="p">(</span><span class="n">tsk</span><span class="o">-&gt;</span><span class="n">splice_pipe</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tsk</span><span class="o">-&gt;</span><span class="n">task_frag</span><span class="p">.</span><span class="n">page</span><span class="p">)</span>
		<span class="n">put_page</span><span class="p">(</span><span class="n">tsk</span><span class="o">-&gt;</span><span class="n">task_frag</span><span class="p">.</span><span class="n">page</span><span class="p">);</span>

	<span class="n">validate_creds_for_do_exit</span><span class="p">(</span><span class="n">tsk</span><span class="p">);</span>

	<span class="n">check_stack_usage</span><span class="p">();</span>
	<span class="n">preempt_disable</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tsk</span><span class="o">-&gt;</span><span class="n">nr_dirtied</span><span class="p">)</span>
		<span class="n">__this_cpu_add</span><span class="p">(</span><span class="n">dirty_throttle_leaks</span><span class="p">,</span> <span class="n">tsk</span><span class="o">-&gt;</span><span class="n">nr_dirtied</span><span class="p">);</span>
	<span class="n">exit_rcu</span><span class="p">();</span>
	<span class="n">exit_tasks_rcu_finish</span><span class="p">();</span>

	<span class="n">lockdep_free_task</span><span class="p">(</span><span class="n">tsk</span><span class="p">);</span>
	<span class="n">do_task_dead</span><span class="p">();</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">do_exit</span><span class="p">);</span>
</pre></table></code></div></div><p>可以看到一个 task 退出时需要清理/释放的资源种类非常之多，主流程<code class="language-plaintext highlighter-rouge">do_exit()</code>里的子流程函数调用就有好几十个了。</p><p>我们想要从中找到这个逻辑：exit 的时候，内核根据什么决定是否直接 reap 掉 task。</p><p>利用已知知识帮助快速定位到想要找的逻辑的代码：已知对于一般进程来说，如果父进程设置了忽略 SIGCHLD 信号（<code class="language-plaintext highlighter-rouge">signal(SIGCHLD, SIG_IGN)</code>），则子进程 exit 的时候会【reap 掉 task】，否则子进程会【进入 ZOMBIE 状态】。这实际上正是我们要找的「exit 决定是否直接 reap 掉 task」的决策过程的一部分。猜测对于线程 task 是否自动 reap 的决策逻辑也是在相同的位置或附近。</p><p>故以【进入 ZOMBIE 状态】为线索反查，直接搜索 ` = EXIT_ZOMBIE<code class="language-plaintext highlighter-rouge"> 尝试找所有将 task 状态设置为 ZOMBIE 的地方，快速定位到 </code>exit_notify()` 中：</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
</pre><td class="rouge-code"><pre><span class="cm">/*
 * Send signals to all our closest relatives so that they know
 * to properly mourn us..
 */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">exit_notify</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">,</span> <span class="kt">int</span> <span class="n">group_dead</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">bool</span> <span class="n">autoreap</span><span class="p">;</span> <span class="c1">// 是否自动 reap 掉 task</span>

	<span class="c1">// ......</span>

	<span class="n">tsk</span><span class="o">-&gt;</span><span class="n">exit_state</span> <span class="o">=</span> <span class="n">EXIT_ZOMBIE</span><span class="p">;</span> <span class="c1">// 默认将 task 置入 EXIT_ZOMBIE 状态</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">tsk</span><span class="o">-&gt;</span><span class="n">ptrace</span><span class="p">))</span> <span class="p">{</span> <span class="c1">// 如果启用了 ptrace（一般用于 debug）</span>
		<span class="kt">int</span> <span class="n">sig</span> <span class="o">=</span> <span class="c1">// ......</span>
		<span class="n">autoreap</span> <span class="o">=</span> <span class="n">do_notify_parent</span><span class="p">(</span><span class="n">tsk</span><span class="p">,</span> <span class="n">sig</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">thread_group_leader</span><span class="p">(</span><span class="n">tsk</span><span class="p">))</span> <span class="p">{</span> <span class="c1">// 如果是线程组组长，即主线程</span>
	    <span class="c1">// 并且整个线程组（进程）中所有线程都已经退出</span>
	    <span class="c1">// 则发送 SIGCHLD 给 parent，如果父进程 SIG_IGN 掉了 SIGCHLD，则自动 reap</span>
		<span class="n">autoreap</span> <span class="o">=</span> <span class="n">thread_group_empty</span><span class="p">(</span><span class="n">tsk</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			<span class="n">do_notify_parent</span><span class="p">(</span><span class="n">tsk</span><span class="p">,</span> <span class="n">tsk</span><span class="o">-&gt;</span><span class="n">exit_signal</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span> <span class="c1">// 其他任何情况，即：不是线程组组长（例如子线程）</span>
		<span class="n">autoreap</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span> <span class="c1">// 则均自动 reap</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">autoreap</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 自动 reap 的进程直接进入 EXIT_DEAD 状态</span>
		<span class="n">tsk</span><span class="o">-&gt;</span><span class="n">exit_state</span> <span class="o">=</span> <span class="n">EXIT_DEAD</span><span class="p">;</span>
		<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tsk</span><span class="o">-&gt;</span><span class="n">ptrace_entry</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dead</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="c1">// ......</span>
<span class="p">}</span>
</pre></table></code></div></div><p>这里证实了猜想1：当一个 task 不是一个线程组的组长的时候，内核会在 exit 的时候直接 reap 掉子线程的 task。所以在子线程执行完毕但是未 join 之间，ps 会看不到子线程，因为子线程 task 已经被内核回收了。</p><p>也就是说，<strong>只有一个线程组（也就是进程）的主线程可以进入僵尸状态，所有的子线程都不可能会有僵尸状态。子线程的 task 在用户程序代码执行完毕后，就马上退出并被回收了。</strong></p><p>而子线程的执行结果（返回值等）则保存在用户态 pthread 结构体中，供后续可能的 JOIN 使用。</p><h1 id="结论">结论</h1><p>对于 Linux 平台上的 pthread 线程，在子线程比父线程先退出且没被 JOIN 的情况下，不会产生和传统意义上的僵尸进程类似的“僵尸线程”（即 ps 不会看到有 defunct 的线程 task，子线程 task 会在 exit 时被内核直接回收掉，不等父进程 JOIN）。</p><p>但是并不意味着没有被 pthread_join 的线程完全不会占用资源。</p><p>没被回收的线程虽然不会占用内核的 task 资源，但是会在用户态留下 pthread 结构体（TCB）以及线程的栈（因为 pthread 结构体和线程栈是一起分配一起释放的），如果未被 JOIN 的线程累积过多，仍然可能会导致用户态资源耗尽而导致<strong>该进程</strong>无法创建新的线程。</p><p>与僵尸进程不同的是，“僵尸线程”堆积的影响只限制在一个进程之内，理论上不会导致系统上其他进程创建失败（因为不占用 task_struct 和 pid/tid）。</p><blockquote><p>注意到该结论只适用于 Linux，因为 Linux 实现线程的方式为内核轻改动，大多数线程相关的功能实现都在用户态中实现（glibc）。不排除其他 POSIX 系统可能内核级原生支持 pthread 线程。</p></blockquote><p><code class="language-plaintext highlighter-rouge">pthread_detach()</code> 过的线程，则 pthread 会在线程执行完成后自动释放 pthread 结构体以及栈，所以对不关心执行结果的线程，应当使用 <code class="language-plaintext highlighter-rouge">pthread_detach()</code> 进行脱离。若不进行脱离，则必须确保所有线程在合适的时间都能被 <code class="language-plaintext highlighter-rouge">pthread_join()</code> 回收。</p><blockquote><p>Reference:<br /> <a href="https://manpages.debian.org/bullseye/manpages-dev/clone.2.en.html#CLONE_THREAD">https://manpages.debian.org/bullseye/manpages-dev/clone.2.en.html#CLONE_THREAD</a><br /> <a href="https://codebrowser.dev/glibc/glibc/nptl/">https://codebrowser.dev/glibc/glibc/nptl/</a><br /> <a href="https://elixir.bootlin.com/linux/v5.15/source/kernel/exit.c">https://elixir.bootlin.com/linux/v5.15/source/kernel/exit.c</a></p></blockquote></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/linux/'>Linux</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/chinese/" class="post-tag no-text-decoration" >Chinese</a> <a href="/tags/linux/" class="post-tag no-text-decoration" >linux</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=Linux+%E6%98%AF%E5%90%A6%E6%9C%89+zombie+thread%EF%BC%9F%E4%BB%8Eglibc%E5%92%8C%E5%86%85%E6%A0%B8%E6%BA%90%E7%A0%81%E6%8E%A2%E7%A9%B6+-+Miigon%27s+blog&url=https%3A%2F%2Fblog.miigon.net%2Fposts%2Fdoes-linux-has-zombie-thread%2F" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=Linux+%E6%98%AF%E5%90%A6%E6%9C%89+zombie+thread%EF%BC%9F%E4%BB%8Eglibc%E5%92%8C%E5%86%85%E6%A0%B8%E6%BA%90%E7%A0%81%E6%8E%A2%E7%A9%B6+-+Miigon%27s+blog&u=https%3A%2F%2Fblog.miigon.net%2Fposts%2Fdoes-linux-has-zombie-thread%2F" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://t.me/share/url?url=https%3A%2F%2Fblog.miigon.net%2Fposts%2Fdoes-linux-has-zombie-thread%2F&text=Linux+%E6%98%AF%E5%90%A6%E6%9C%89+zombie+thread%EF%BC%9F%E4%BB%8Eglibc%E5%92%8C%E5%86%85%E6%A0%B8%E6%BA%90%E7%A0%81%E6%8E%A2%E7%A9%B6+-+Miigon%27s+blog" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i id="copy-link" class="fa-fw fas fa-link small" data-toggle="tooltip" data-placement="top" title="Copy link" data-title-succeed="Link copied successfully!"> </i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted"><div class="access"><div id="access-lastmod" class="post"><div class="panel-heading">Recently Updated</div><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/storing-hash-objects-on-filesystem/">[随笔]文件系统上存储哈希对象：哈希算法以及目录结构对性能的影响</a><li><a href="/posts/origin-of-git-feat-bitkeeper/">git的前世，和BitKeeper</a><li><a href="/posts/golang-loop-var-reference-problems-and-semantic-fix/">随笔：Golang 循环变量引用问题以及官方语义修复</a><li><a href="/posts/s081-lab6-copy-on-write-fork/">[mit6.s081] 笔记 Lab6: Copy-on-write fork | fork 懒拷贝</a><li><a href="/posts/mysql-prepare-slower-query-bug-analyze/">MySQL Prepare后语句查询性能降低 内核源码bug排查分析</a></ul></div><div id="access-tags"><div class="panel-heading">Trending Tags</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/operating-system/">operating system</a> <a class="post-tag" href="/tags/chinese/">Chinese</a> <a class="post-tag" href="/tags/system-design/">system design</a> <a class="post-tag" href="/tags/c/">C++</a> <a class="post-tag" href="/tags/course-recommendation/">course recommendation</a> <a class="post-tag" href="/tags/grpc/">gRPC</a> <a class="post-tag" href="/tags/translated/">translated</a> <a class="post-tag" href="/tags/announcement/">announcement</a> <a class="post-tag" href="/tags/c-standard/">c++ standard</a> <a class="post-tag" href="/tags/computer-system/">computer system</a></div></div><div id="access-links" class="post"><div class="panel-heading">Links</div><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="http://0xffff.one">0xffff.one 搬砖技术社区</a><li><a href="https://blog.izgq.net">ZGQ's Blog</a></ul></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"><div class="panel-heading pl-3 pt-2 mb-2">Contents</div><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div id="tail-wrapper" class="col-12 col-lg-11 col-xl-9 pl-3 pr-3 pr-xl-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/cn-translation-performance-best-practices-transactions-and-read-write-concerns/"><div class="card-body"> <em class="small" data-ts="1612357751" data-df="ll" > Feb 3, 2021 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>MongoDB 高性能最佳实践: 事务，读取关心程度与写入关心程度</h3><div class="text-muted small"><p> 本文章为翻译作品，原作者为 Mat Keep 与 Henrik Ingo 原文章发布日期 2020年02月25日 原文标题：Performance Best Practices: Transactions and Read / Write Concerns 原文链接：https://www.mongodb.com/blog/post/performance-best-practices...</p></div></div></a></div><div class="card"> <a href="/posts/cn-skip-bytes-while-copying-with-dd/"><div class="card-body"> <em class="small" data-ts="1613625600" data-df="ll" > Feb 18, 2021 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>原理分析：使用 dd 跳过开头若干字节快速拷贝文件</h3><div class="text-muted small"><p> 这篇文章是来自我在 0xffff.one 上的一个帖子 https://0xffff.one/d/900 的回复。 原帖内容： 在折腾一个超大的备份文件，需要把它的前 41 个字节删除掉，没有 WinHEX，想着用 dd 命令来实现 一开始这么干，发现速度奇慢，5分钟过去才复制40MB… dd if=input.bak bs=1 skip=41 &amp;gt; result....</p></div></div></a></div><div class="card"> <a href="/posts/cpp-ios-base-fixed-precision-loss/"><div class="card-body"> <em class="small" data-ts="1614168480" data-df="ll" > Feb 24, 2021 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>问题分析：ios_base::fixed 导致输出精度丢失？</h3><div class="text-muted small"><p> 这篇文章是来自我在 0xffff.one 上的一个帖子 https://0xffff.one/d/911/ 的回复。 原帖内容： 百度说是这行代码的作用是使用定点输出，同时输出小数点后6位(我试了好多数，仍然表示很迷) 为什么有这行代码有时候求两个数加减乘除的结果就不对，没有这行代码就对呢 比如55.25+11.17有上面那行代码结果是66.419998，没有就是66...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/mysql-prepare-slower-query-bug-analyze/" class="btn btn-outline-primary" prompt="Older"><p>MySQL Prepare后语句查询性能降低 内核源码bug排查分析</p></a> <a href="/posts/storing-hash-objects-on-filesystem/" class="btn btn-outline-primary" prompt="Newer"><p>[随笔]文件系统上存储哈希对象：哈希算法以及目录结构对性能的影响</p></a></div><script type="text/javascript"> $(function () { const origin = "https://giscus.app"; const iframe = "iframe.giscus-frame"; const lightTheme = "light"; const darkTheme = "dark_dimmed"; let initTheme = lightTheme; if ($("html[data-mode=dark]").length > 0 || ($("html[data-mode]").length == 0 && window.matchMedia("(prefers-color-scheme: dark)").matches)) { initTheme = darkTheme; } let giscusAttributes = { "src": "https://giscus.app/client.js", "data-repo": "Miigon/blog", "data-repo-id": "MDEwOlJlcG9zaXRvcnkzMjI1MjkwNzA=", "data-category": "BlogComments", "data-category-id": "DIC_kwDOEzlnLs4CQ6Y4", "data-mapping": "pathname", "data-reactions-enabled": "1", "data-emit-metadata": "0", "data-theme": initTheme, "data-input-position": "top", "data-lang": "en", "crossorigin": "anonymous", "async": "" }; let giscusScript = document.createElement("script"); Object.entries(giscusAttributes).forEach(([key, value]) => giscusScript.setAttribute(key, value)); document.getElementById("tail-wrapper").prepend(giscusScript); addEventListener("message", (event) => { if (event.source === window && event.data && event.data.direction === ModeToggle.ID) { /* global theme mode changed */ const mode = event.data.message; const theme = (mode === ModeToggle.DARK_MODE ? darkTheme : lightTheme); const message = { setConfig: { theme: theme } }; const giscus = document.querySelector(iframe).contentWindow; giscus.postMessage({ giscus: message }, origin); } }); }); </script></div></div><footer class="row pl-3 pr-3"><div class="col-12 d-flex justify-content-between align-items-center text-muted pl-0 pr-0"><div class="footer-left"><p class="mb-0"> © 2023 <a href="https://github.com/Miigon">Miigon</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Customized Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><div id="access-tags"><div class="panel-heading">Trending Tags</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/operating-system/">operating system</a> <a class="post-tag" href="/tags/chinese/">Chinese</a> <a class="post-tag" href="/tags/system-design/">system design</a> <a class="post-tag" href="/tags/c/">C++</a> <a class="post-tag" href="/tags/course-recommendation/">course recommendation</a> <a class="post-tag" href="/tags/grpc/">gRPC</a> <a class="post-tag" href="/tags/translated/">translated</a> <a class="post-tag" href="/tags/announcement/">announcement</a> <a class="post-tag" href="/tags/c-standard/">c++ standard</a> <a class="post-tag" href="/tags/computer-system/">computer system</a></div></div></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a><div id="notification" class="toast" role="alert" aria-live="assertive" aria-atomic="true" data-animation="true" data-autohide="false"><div class="toast-header"> <button type="button" class="ml-2 ml-auto close" data-dismiss="toast" aria-label="Close"> <span aria-hidden="true">&times;</span> </button></div><div class="toast-body text-center pt-0"><p class="pl-2 pr-2 mb-3">A new version of content is available.</p><button type="button" class="btn btn-primary" aria-label="Update"> Update </button></div></div><script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No results found.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/magnific-popup@1/dist/jquery.magnific-popup.min.js,npm/lozad/dist/lozad.min.js,npm/clipboard@2/dist/clipboard.min.js"></script> <script src="https://cdn.jsdelivr.net/combine/npm/dayjs@1/dayjs.min.js,npm/dayjs@1/locale/en.min.js,npm/dayjs@1/plugin/relativeTime.min.js,npm/dayjs@1/plugin/localizedFormat.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.bundle.min.js"></script> <script defer src="/app.js"></script>
