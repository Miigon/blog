<!DOCTYPE html><html lang="en" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="generator" content="Jekyll v4.2.2" /><meta property="og:title" content="MySQL Prepare后语句查询性能降低 内核源码bug排查分析" /><meta property="og:locale" content="en" /><meta name="description" content="源自于业务上遇到的一个先将某个语句Prepare再Execute查询效率很低的问题，而将查询中的参数直接嵌入到SQL语句内并以文本形式执行，则执行反而变得很快。" /><meta property="og:description" content="源自于业务上遇到的一个先将某个语句Prepare再Execute查询效率很低的问题，而将查询中的参数直接嵌入到SQL语句内并以文本形式执行，则执行反而变得很快。" /><link rel="canonical" href="https://blog.miigon.net/posts/mysql-prepare-slower-query-bug-analyze/" /><meta property="og:url" content="https://blog.miigon.net/posts/mysql-prepare-slower-query-bug-analyze/" /><meta property="og:site_name" content="Miigon’s blog" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2022-11-18T18:00:00+08:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="MySQL Prepare后语句查询性能降低 内核源码bug排查分析" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2022-11-25T14:22:25+08:00","datePublished":"2022-11-18T18:00:00+08:00","description":"源自于业务上遇到的一个先将某个语句Prepare再Execute查询效率很低的问题，而将查询中的参数直接嵌入到SQL语句内并以文本形式执行，则执行反而变得很快。","headline":"MySQL Prepare后语句查询性能降低 内核源码bug排查分析","mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.miigon.net/posts/mysql-prepare-slower-query-bug-analyze/"},"url":"https://blog.miigon.net/posts/mysql-prepare-slower-query-bug-analyze/"}</script><title>MySQL Prepare后语句查询性能降低 内核源码bug排查分析 | Miigon's blog</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="Miigon's blog"><meta name="application-name" content="Miigon's blog"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link rel="dns-prefetch" href="https://fonts.gstatic.com" crossorigin><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://cdn.jsdelivr.net" ><link rel="dns-prefetch" href="https://cdn.jsdelivr.net" ><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Lato&family=Source+Sans+Pro:wght@400;600;700;900&display=swap"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get MODE_ATTR() { return "data-mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } static get ID() { return "mode-toggle"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } let self = this; /* always follow the system prefers */ this.sysDarkPrefers.addEventListener("change", () => { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.notify(); }); } /* constructor() */ get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode === ModeToggle.DARK_MODE; } get isLightMode() { return this.mode === ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer)) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } setDark() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_ATTR); sessionStorage.removeItem(ModeToggle.MODE_KEY); } /* Notify another plugins that the theme mode has changed */ notify() { window.postMessage({ direction: ModeToggle.ID, message: this.modeStatus }, "*"); } } /* ModeToggle */ const toggle = new ModeToggle(); function flipMode() { if (toggle.hasMode) { if (toggle.isSysDarkPrefer) { if (toggle.isLightMode) { toggle.clearMode(); } else { toggle.setLight(); } } else { if (toggle.isDarkMode) { toggle.clearMode(); } else { toggle.setDark(); } } } else { if (toggle.isSysDarkPrefer) { toggle.setLight(); } else { toggle.setDark(); } } toggle.notify(); } /* flipMode() */ </script><body data-spy="scroll" data-target="#toc" data-topbar-visible="true"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" class="mx-auto"> <img src="/assets/img/avatar.png" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">Miigon's blog</a></div><div class="site-subtitle font-italic">My ideas, thoughts and experiences</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tag ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info-circle ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center align-items-center"> <button class="mode-toggle btn" aria-label="Switch Mode"> <i class="fas fa-adjust"></i> </button> <span class="icon-border"></span> <a href="https://github.com/Miigon" aria-label="github" target="_blank" rel="noopener"> <i class="fab fa-github-alt"></i> </a> <a href="https://twitter.com/" aria-label="twitter" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['miigon.pg','gmail.com'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="https://stackoverflow.com/users/7509248/miigon" aria-label="stack-overflow" target="_blank" rel="noopener"> <i class="fab fa-stack-overflow"></i> </a></div></div><div id="topbar-wrapper"><div id="topbar" class="container d-flex align-items-center justify-content-between h-100 pl-3 pr-3 pl-md-4 pr-md-4"> <span id="breadcrumb"> <span> <a href="/"> Home </a> </span> <span>MySQL Prepare后语句查询性能降低 内核源码bug排查分析</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..."> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper" class="d-flex justify-content-center"><div id="main" class="container pl-xl-4 pr-xl-4"><div class="row"><div id="core-wrapper" class="col-12 col-lg-11 col-xl-9 pr-xl-4"><div class="post pl-1 pr-1 pl-md-2 pr-md-2"><h1 data-toc-skip>MySQL Prepare后语句查询性能降低 内核源码bug排查分析</h1><div class="post-meta text-muted"> <span> Posted <em class="" data-ts="1668765600" data-df="ll" data-toggle="tooltip" data-placement="bottom"> Nov 18, 2022 </em> </span> <span> Updated <em class="" data-ts="1669357345" data-df="ll" data-toggle="tooltip" data-placement="bottom"> Nov 25, 2022 </em> </span><div class="d-flex justify-content-between"> <span> By <em> <a href="https://github.com/Miigon">Miigon</a> </em> </span><div> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="4676 words"> <em>25 min</em> read</span></div></div></div><div class="post-content"><p>源自于业务上遇到的一个先将某个语句Prepare再Execute查询效率很低的问题，而将查询中的参数直接嵌入到SQL语句内并以文本形式执行，则执行反而变得很快。</p><p>测试环境：腾讯云 MySQL 服务（txsql8.0.22）、MySQL 源码编译（refs/tags/mysql-8.0.22）</p><h1 id="问题描述">问题描述</h1><h2 id="背景"><span class="mr-2">背景</span><a href="#背景" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>MySQL 中，语句执行有两种方式，分别是 <a href="https://dev.mysql.com/doc/dev/mysql-server/latest/page_protocol_com_query.html">Text Protocol</a> 和 <a href="https://dev.mysql.com/doc/dev/mysql-server/latest/page_protocol_command_phase_ps.html">Prepared Statement</a>。两者主要的差别是传参方式的不同（返回包格式也不同，这里不展开）。</p><ul><li>Text Protocol 是直接将语句中的参数嵌入到 SQL 语句中，以文本的形式整个语句直接传递到数据库。（后面称为「文本SQL模式」）<li>Prepared Statement 则是先 <a href="https://dev.mysql.com/doc/dev/mysql-server/latest/page_protocol_com_stmt_prepare.html">COM_STMT_PREPARE</a> 一个查询语句的模板，如 <code class="language-plaintext highlighter-rouge">SELECT * FROM t1 WHERE a = ? AND b = ?</code>，然后再执行 <a href="https://dev.mysql.com/doc/dev/mysql-server/latest/page_protocol_com_stmt_execute.html">COM_STMT_EXECUTE</a>，将实际的参数传入，替换掉占位符 <code class="language-plaintext highlighter-rouge">?</code> 并执行。（后面称为「Prepare/Execute模式」）</ul><h2 id="问题"><span class="mr-2">问题</span><a href="#问题" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>定位并简化问题查询，得到最小可复现样例：</p><p>表结构：</p><div class="language-sql highlighter-rouge"><div class="code-header"> <span data-label-text="Sql"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="k">CREATE</span> <span class="k">TABLE</span> <span class="n">t1</span> <span class="p">(</span>
	<span class="n">col1</span> <span class="nb">BIGINT</span> <span class="k">NOT</span> <span class="k">NULL</span><span class="p">,</span>
	
	<span class="k">KEY</span> <span class="n">idx_t1_col1</span><span class="p">(</span><span class="n">col1</span><span class="p">)</span>
<span class="p">);</span>
</pre></table></code></div></div><p>查询：</p><div class="language-sql highlighter-rouge"><div class="code-header"> <span data-label-text="Sql"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">t1</span> <span class="k">WHERE</span> <span class="n">col1</span><span class="o">=</span><span class="mi">10036</span> <span class="k">ORDER</span> <span class="k">BY</span> <span class="n">col1</span> <span class="k">ASC</span> <span class="k">LIMIT</span> <span class="mi">5</span><span class="p">;</span>
</pre></table></code></div></div><p>可以看到，这个查询限定结果集中 <code class="language-plaintext highlighter-rouge">col1 = 10036</code>，然后要求结果按照 col1 排序实际上 <strong><code class="language-plaintext highlighter-rouge">ORDER BY col1 ASC</code> 是冗余的</strong>，因为结果中所有的 col1 的值都是一样的（10036）。</p><p>问题在于：这个查询，在表数据量较大（200w）时，Prepare/Execute模式下的速度非常慢（~100ms），而文本SQL模式则很快（0.7ms）。</p><p>这个是比较反直觉的，因为 Prepare/Execute模式的优势之一就是传递数据更高效，并且可以避免重复解析语句，每次执行只需要插入参数（<code class="language-plaintext highlighter-rouge">Prepared_statement::insert_params()</code>）并优化即可执行，理论上应该比文本SQL模式更快。</p><blockquote><p>相比之下 <code class="language-plaintext highlighter-rouge">SELECT * FROM t1 ORDER BY col1 ASC LIMIT 5</code>（删掉Where，只保留 Order By）只要0.7ms，也就是 Where 和 Order By 同时存在的时候，同一个语句，Prepare/Execute模式的性能出现了明显降低，而文本SQL模式不受影响。</p></blockquote><h1 id="问题分析">问题分析</h1><p>由于执行的是同一个语句，排除了两种模式的RTT差异因素后，初步怀疑是「Prepare/Execute模式」和「文本SQL模式」下，优化器生成的执行计划出现了差异导致。</p><p>使用 <code class="language-plaintext highlighter-rouge">SET SESSION OPTIMIZER_TRACE='enabled=on';</code>，打开 optimizer trace，分别以prepare/execute和文本SQL形式执行该SQL，得到优化器 trace：</p><p><img data-src="/assets/img/database/mysql-prepare-slower-bug/Pasted image 20221117154221.png" alt="" data-proofer-ignore></p><p>可以看到 trace 中大多数优化流程和结果是完全一致的（符合预期，因为毕竟是同一个语句），但是在 <code class="language-plaintext highlighter-rouge">optimizing_distinct_group_by_order_by</code> ，即 ORDER BY 优化部分出现了差异。</p><h2 id="问题1-prepareexecute模式没有剔除冗余-order-by"><span class="mr-2">问题1 Prepare/Execute模式没有剔除冗余 ORDER BY</span><a href="#问题1-prepareexecute模式没有剔除冗余-order-by" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>前面提到在我们制定的查询条件 <code class="language-plaintext highlighter-rouge">col1 = 10036</code> 下，<code class="language-plaintext highlighter-rouge">ORDER BY col1 ASC</code> 实际上是冗余的，因为 col1 是常量，理论上该阶段优化器会剔除掉这个 ORDER BY。</p><ul><li>文本SQL模式执行时，优化器成功地发现了这一点（图中1），即<code class="language-plaintext highlighter-rouge">"equals_constant_in_where": true</code>，并正确地将该冗余 order by clause 优化掉，<code class="language-plaintext highlighter-rouge">resulting_clause</code> 为空。<li>Prepare/Execute模式下，优化器由于<em>某些原因</em>，并没有发现 col1 实际上恒等于一个常量，没有在这一阶段优化掉冗余的 order by（图中2）</ul><p>（最后结论是为 MySQL 8.22 的一个 bug）</p><h2 id="问题2-order-by-没有利用索引"><span class="mr-2">问题2 ORDER BY 没有利用索引</span><a href="#问题2-order-by-没有利用索引" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>但是这不是效率低的全部原因，因为即使优化器没有剔除掉冗余 ORDER BY，由于 col1 上有索引，对 col1 的 ORDER BY 也应该是不会产生排序操作的，理论上可以直接访问索引得到有序 col1，相比直接剔除 ORDER BY 也不应该会慢这么多（百倍）。</p><p>这里继续往下可以看到，Prepare/Execute模式下，优化器<em>出于某种原因</em>，在考虑 order by 的执行路径的时候，认为 col1 上的索引（<code class="language-plaintext highlighter-rouge">KEY idx_t1_col1(col1)</code>）无法满足我们要进行的排序条件（<code class="language-plaintext highlighter-rouge">"index_provides_order": false</code>）（图中3），这显然是错误的，导致了执行器不从索引上直接获得有序的 col1，而是自己又对所有数据进行了一次排序，导致效率低下。</p><p>这里注意到 <code class="language-plaintext highlighter-rouge">order_direction</code> 为 <code class="language-plaintext highlighter-rouge">undefined</code>，在 MySQL 8.0.22 源码上验证，没有成功复现，原版 MySQL 中 trace 出来的这个 key 的 <code class="language-plaintext highlighter-rouge">order_direction</code> 为 <code class="language-plaintext highlighter-rouge">asc</code>，并且能够正确使用索引来避免对 <code class="language-plaintext highlighter-rouge">col1</code> 进行排序。</p><h1 id="原因调查">原因调查</h1><h2 id="问题1-冗余-order-by-剔除"><span class="mr-2">问题1 冗余 ORDER BY 剔除</span><a href="#问题1-冗余-order-by-剔除" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>源码编译 <a href="https://github.com/mysql/mysql-server/tree/mysql-8.0.22">mysql 8.0.22</a>，并挂载 gdb，由于 optimizer trace 中体现出来的差异是 <code class="language-plaintext highlighter-rouge">equals_constant_in_where</code> （where条件等于常量）是否为 true，全局搜索这个关键字，发现是在 JOIN 语句优化部分的 <code class="language-plaintext highlighter-rouge">JOIN::remove_const</code> 函数中，该函数被 <code class="language-plaintext highlighter-rouge">JOIN::optimize_distinct_group_order</code> 函数调用，即这部分逻辑是在判断 ORDER BY 中是否存在按常量列排序的 clause，如果存在则剔除掉（符合预期）。</p><h3 id="部分调用栈"><span class="mr-2">部分调用栈</span><a href="#部分调用栈" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre>#0  const_expression_in_where           at sql/sql_select.cc:3798
#1  JOIN::remove_const                  at sql/sql_optimizer.cc:9865
#2  JOIN::optimize_distinct_group_order at sql/sql_optimizer.cc:1261
#3  JOIN::optimize                      at sql/sql_optimizer.cc:614
#4  SELECT_LEX::optimize                at sql/sql_select.cc:1905
#5  SELECT_LEX_UNIT::optimize           at sql/sql_union.cc:680
#6  Sql_cmd_dml::execute_inner          at sql/sql_select.cc:924
#7  Sql_cmd_dml::execute                at sql/sql_select.cc:725
#8  mysql_execute_command               at sql/sql_parse.cc:4344
#9  Prepared_statement::execute         at sql/sql_prepare.cc:3487
#10 Prepared_statement::execute_loop    at sql/sql_prepare.cc:2994
#11 mysqld_stmt_execute                 at sql/sql_prepare.cc:1891
# ......
</pre></table></code></div></div><h3 id="joinremove_const-函数"><span class="mr-2">JOIN::remove_const() 函数</span><a href="#joinremove_const-函数" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><blockquote><p>优化器JOIN语句优化阶段，移除常量的 order by 或 group by 条件</p></blockquote><div class="language-cpp highlighter-rouge"><div class="code-header"> <span data-label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
</pre><td class="rouge-code"><pre><span class="c1">// sql/sql_optimizer.cc:9774</span>
<span class="n">ORDER</span> <span class="o">*</span><span class="n">JOIN</span><span class="o">::</span><span class="n">remove_const</span><span class="p">(</span><span class="n">ORDER</span> <span class="o">*</span><span class="n">first_order</span><span class="p">,</span> <span class="n">Item</span> <span class="o">*</span><span class="n">cond</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">change_list</span><span class="p">,</span>
                          <span class="kt">bool</span> <span class="o">*</span><span class="n">simple_order</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">group_by</span><span class="p">)</span> <span class="p">{</span>

  <span class="c1">// ......</span>
  <span class="c1">// line 9812</span>
  
  <span class="c1">// 对于每一个 order_by 条件</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">order</span> <span class="o">=</span> <span class="n">first_order</span><span class="p">;</span> <span class="n">order</span><span class="p">;</span> <span class="n">order</span> <span class="o">=</span> <span class="n">order</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">Opt_trace_object</span> <span class="n">trace_one_item</span><span class="p">(</span><span class="n">trace</span><span class="p">);</span>
    <span class="n">trace_one_item</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="s">"item"</span><span class="p">,</span> <span class="n">order</span><span class="o">-&gt;</span><span class="n">item</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
    <span class="n">table_map</span> <span class="n">order_tables</span> <span class="o">=</span> <span class="n">order</span><span class="o">-&gt;</span><span class="n">item</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">used_tables</span><span class="p">();</span>

    <span class="k">if</span> <span class="p">(</span><span class="cm">/* ......aggregation检查 */</span><span class="p">)</span>
      <span class="c1">// ......</span>
    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="cm">/* ......子查询优化 */</span><span class="p">)</span> <span class="p">{</span>
      <span class="c1">// ......</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="cm">/* ......重复排序检查 */</span><span class="p">)</span> <span class="p">{</span>
      <span class="c1">// ......</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="cm">/* ......检测子查询 */</span><span class="p">)</span>
      <span class="c1">// ......</span>
    <span class="k">else</span> <span class="p">{</span> <span class="c1">// line 9861</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">order_tables</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">RAND_TABLE_BIT</span> <span class="o">|</span> <span class="n">OUTER_REF_TABLE_BIT</span><span class="p">))</span>
        <span class="o">*</span><span class="n">simple_order</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
      <span class="k">else</span> <span class="p">{</span>
        <span class="c1">// ！！检查排序的依据列是否是常数值，即所有行这一列的值都相等</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">cond</span> <span class="o">&amp;&amp;</span> <span class="n">const_expression_in_where</span><span class="p">(</span><span class="n">cond</span><span class="p">,</span> <span class="n">order</span><span class="o">-&gt;</span><span class="n">item</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span> <span class="p">{</span>
          <span class="n">trace_one_item</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="s">"equals_constant_in_where"</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
          <span class="k">continue</span><span class="p">;</span> <span class="c1">// 如果是，则跳过，忽略该 ORDER BY</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="p">((</span><span class="n">ref</span> <span class="o">=</span> <span class="n">order_tables</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">not_const_tables</span> <span class="o">^</span> <span class="n">first_table</span><span class="p">)))</span> <span class="p">{</span>
          <span class="c1">// ......</span>
        <span class="p">}</span>
      <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">change_list</span><span class="p">)</span> <span class="o">*</span><span class="n">prev_ptr</span> <span class="o">=</span> <span class="n">order</span><span class="p">;</span>  <span class="c1">// use this entry</span>
    <span class="n">prev_ptr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">order</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">// ......</span>

  <span class="k">return</span> <span class="n">first_order</span><span class="p">;</span>
<span class="p">}</span>

</pre></table></code></div></div><p>这里调用了 <code class="language-plaintext highlighter-rouge">const_expression_in_where(cond, order-&gt;item[0])</code> 函数，来判断 <code class="language-plaintext highlighter-rouge">cond</code> （也就是 WHERE 中指定的筛选条件）中是否有使得排序条件 <code class="language-plaintext highlighter-rouge">order-&gt;item[0]</code> 恒等于某个值的条件，从而决定是否剔除 <code class="language-plaintext highlighter-rouge">ORDER BY order-&gt;item[0]</code> 的排序条件 （比如 <code class="language-plaintext highlighter-rouge">col1 = 10036</code> 这样的条件）</p><h3 id="const_expression_in_where-函数"><span class="mr-2">const_expression_in_where() 函数</span><a href="#const_expression_in_where-函数" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><blockquote><p>8.0.24 后叫 check_field_is_const()</p><p>判断 WHERE 条件 cond 内是否有能使得结果集中 comp_item 恒为某个常数的条件。 如果有，则可以断言 ORDER BY comp_item 为冗余操作，可以剔除。</p></blockquote><div class="language-cpp highlighter-rouge"><div class="code-header"> <span data-label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
</pre><td class="rouge-code"><pre><span class="c1">// sql/sql_select.cc:3773</span>
<span class="kt">bool</span> <span class="nf">const_expression_in_where</span><span class="p">(</span><span class="n">Item</span> <span class="o">*</span><span class="n">cond</span><span class="p">,</span> <span class="n">Item</span> <span class="o">*</span><span class="n">comp_item</span><span class="p">,</span>
                               <span class="k">const</span> <span class="n">Field</span> <span class="o">*</span><span class="n">comp_field</span><span class="p">,</span> <span class="n">Item</span> <span class="o">**</span><span class="n">const_item</span><span class="p">)</span> <span class="p">{</span>
  
  <span class="c1">// ......</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">cond</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">()</span> <span class="o">==</span> <span class="n">Item</span><span class="o">::</span><span class="n">COND_ITEM</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// `a = ?` 这样的条件实际上是一个布尔比较函数，所以不是走到这个分支</span>
    <span class="c1">// ......</span>
  <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">cond</span><span class="o">-&gt;</span><span class="n">eq_cmp_result</span><span class="p">()</span> <span class="o">!=</span> <span class="n">Item</span><span class="o">::</span><span class="n">COND_OK</span><span class="p">)</span> <span class="p">{</span>  <span class="c1">// 布尔比较函数</span>
    <span class="n">Item_func</span> <span class="o">*</span><span class="n">func</span> <span class="o">=</span> <span class="p">(</span><span class="n">Item_func</span> <span class="o">*</span><span class="p">)</span><span class="n">cond</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">func</span><span class="o">-&gt;</span><span class="n">functype</span><span class="p">()</span> <span class="o">!=</span> <span class="n">Item_func</span><span class="o">::</span><span class="n">EQUAL_FUNC</span> <span class="o">&amp;&amp;</span>
        <span class="n">func</span><span class="o">-&gt;</span><span class="n">functype</span><span class="p">()</span> <span class="o">!=</span> <span class="n">Item_func</span><span class="o">::</span><span class="n">EQ_FUNC</span><span class="p">)</span>
      <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    <span class="c1">// 如果是等于比较（left = right）</span>
    <span class="n">Item</span> <span class="o">*</span><span class="n">left_item</span> <span class="o">=</span> <span class="p">((</span><span class="n">Item_func</span> <span class="o">*</span><span class="p">)</span><span class="n">cond</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">arguments</span><span class="p">()[</span><span class="mi">0</span><span class="p">];</span>
    <span class="n">Item</span> <span class="o">*</span><span class="n">right_item</span> <span class="o">=</span> <span class="p">((</span><span class="n">Item_func</span> <span class="o">*</span><span class="p">)</span><span class="n">cond</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">arguments</span><span class="p">()[</span><span class="mi">1</span><span class="p">];</span>
    <span class="c1">// 且 left 或 right 其中有一个是要检查的目标 comp_item</span>
    <span class="c1">// 则检查 `left = right` 这个条件是否足够保证 comp_item 的值的唯一性</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">equal</span><span class="p">(</span><span class="n">left_item</span><span class="p">,</span> <span class="n">comp_item</span><span class="p">,</span> <span class="n">comp_field</span><span class="p">))</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">test_if_equality_guarantees_uniqueness</span><span class="p">(</span><span class="n">left_item</span><span class="p">,</span> <span class="n">right_item</span><span class="p">))</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">const_item</span><span class="p">)</span> <span class="k">return</span> <span class="n">right_item</span><span class="o">-&gt;</span><span class="n">eq</span><span class="p">(</span><span class="o">*</span><span class="n">const_item</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
        <span class="o">*</span><span class="n">const_item</span> <span class="o">=</span> <span class="n">right_item</span><span class="p">;</span>
        <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">equal</span><span class="p">(</span><span class="n">right_item</span><span class="p">,</span> <span class="n">comp_item</span><span class="p">,</span> <span class="n">comp_field</span><span class="p">))</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">test_if_equality_guarantees_uniqueness</span><span class="p">(</span><span class="n">right_item</span><span class="p">,</span> <span class="n">left_item</span><span class="p">))</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">const_item</span><span class="p">)</span> <span class="k">return</span> <span class="n">left_item</span><span class="o">-&gt;</span><span class="n">eq</span><span class="p">(</span><span class="o">*</span><span class="n">const_item</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
        <span class="o">*</span><span class="n">const_item</span> <span class="o">=</span> <span class="n">left_item</span><span class="p">;</span>
        <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>原理是对于每一个 <code class="language-plaintext highlighter-rouge">WHERE col = xxx</code> 的条件，检查 <code class="language-plaintext highlighter-rouge">col = xxx</code> 条件成立能否保证 <code class="language-plaintext highlighter-rouge">col</code> 在结果集中的值唯一（test_if_equality_guarantees_uniqueness），这里需要检查：</p><ol><li>右侧的量 <code class="language-plaintext highlighter-rouge">xxx</code> 是否是个常量（不能是引用其他的列，也不能是一个子查询）<li>是否类型一致，如果是字符串，编码是否一致</ol><blockquote><p>注（与主问题无关）：仅仅满足 <code class="language-plaintext highlighter-rouge">xxx</code> 是常量并不足以保证结果集中的 <code class="language-plaintext highlighter-rouge">col</code> 的值唯一，因为在 <code class="language-plaintext highlighter-rouge">col</code> 的类型和 <code class="language-plaintext highlighter-rouge">xxx</code> 不一致的时候，会出现 type cast 自动类型转换。 比如当 <code class="language-plaintext highlighter-rouge">col</code> 的类型是 string，而 <code class="language-plaintext highlighter-rouge">xxx</code> 是个 int 的时候，可能会出现如下情况：</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre>mysql&gt; insert into t2 values("123"),("123a"),("123bbbc");
Query OK, 3 rows affected (0.01 sec)

mysql&gt; select * from t2 where col = 123;
+---------+
| col     |
+---------+
| 123     |
| 123a    |
| 123bbbc |
+---------+
3 rows in set (0.03 sec)
</pre></table></code></div></div><p>这是由于 col 的值在和 123 做比较的时候，会将两者都 typecast 成 double，然后再进行比较，string cast 到 double 的时候，会丢弃掉尾部无效字符，<code class="language-plaintext highlighter-rouge">123bbbc</code> 会只剩下 <code class="language-plaintext highlighter-rouge">123</code>，导致<code class="language-plaintext highlighter-rouge">"123bbbc" = 123</code> 结果为 true。 这里的条件 <code class="language-plaintext highlighter-rouge">col = 123</code> 就是一个等号右侧为常量，但是还是无法保证结果集中该列的「值唯一」的例子。 https://dev.mysql.com/doc/refman/8.0/en/type-conversion.html</p></blockquote><h3 id="test_if_equality_guarantees_uniqueness-函数"><span class="mr-2">test_if_equality_guarantees_uniqueness() 函数</span><a href="#test_if_equality_guarantees_uniqueness-函数" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><blockquote><p>8.0.24 后叫 check_field_is_const() 检查 「<code class="language-plaintext highlighter-rouge">l = r</code> 条件成立」能否推出「结果集中 <code class="language-plaintext highlighter-rouge">l</code> 的<strong>值</strong>唯一」</p></blockquote><p>需要检查：</p><ol><li><strong><code class="language-plaintext highlighter-rouge">r</code> 是否是个常量（<code class="language-plaintext highlighter-rouge">r-&gt;const_item()</code> 是否为 true）</strong><li>是否类型一致，如果是字符串，编码是否一致</ol><div class="language-cpp highlighter-rouge"><div class="code-header"> <span data-label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre><span class="c1">// sql/sql_select.cc:3730</span>
<span class="k">static</span> <span class="kt">bool</span> <span class="nf">test_if_equality_guarantees_uniqueness</span><span class="p">(</span><span class="k">const</span> <span class="n">Item</span> <span class="o">*</span><span class="n">l</span><span class="p">,</span>
                                                   <span class="k">const</span> <span class="n">Item</span> <span class="o">*</span><span class="n">r</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">const_item</span><span class="p">()</span> <span class="o">&amp;&amp;</span>
         <span class="cm">/* elements must be compared as dates */</span>
         <span class="p">(</span><span class="n">Arg_comparator</span><span class="o">::</span><span class="n">can_compare_as_dates</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span> <span class="o">||</span>
          <span class="cm">/* or of the same result type */</span>
          <span class="p">(</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">result_type</span><span class="p">()</span> <span class="o">==</span> <span class="n">l</span><span class="o">-&gt;</span><span class="n">result_type</span><span class="p">()</span> <span class="o">&amp;&amp;</span>
           <span class="cm">/* and must have the same collation if compared as strings */</span>
           <span class="p">(</span><span class="n">l</span><span class="o">-&gt;</span><span class="n">result_type</span><span class="p">()</span> <span class="o">!=</span> <span class="n">STRING_RESULT</span> <span class="o">||</span>
            <span class="n">l</span><span class="o">-&gt;</span><span class="n">collation</span><span class="p">.</span><span class="n">collation</span> <span class="o">==</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">collation</span><span class="p">.</span><span class="n">collation</span><span class="p">)));</span>
<span class="p">}</span>
</pre></table></code></div></div><p>这里检查「<code class="language-plaintext highlighter-rouge">r</code> 是否是个常量」的方法是 <code class="language-plaintext highlighter-rouge">r-&gt;const_item()</code>，继续跟踪发现，这个方法判断的是 <strong><code class="language-plaintext highlighter-rouge">r</code> 在整个 Prepared_statement 中是否恒定为常量</strong>。</p><h3 id="itemconst_item-函数"><span class="mr-2">Item::const_item() 函数</span><a href="#itemconst_item-函数" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><blockquote><p>该 item 是否是个常量（要求在整个表达式中自始至终都是常量，不管执行状态如何）</p></blockquote><p>这里是问题所在。</p><p>回到一开始的例子中：</p><div class="language-sql highlighter-rouge"><div class="code-header"> <span data-label-text="Sql"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">t1</span> <span class="k">WHERE</span> <span class="n">col1</span> <span class="o">=</span> <span class="mi">10036</span> <span class="k">ORDER</span> <span class="k">BY</span> <span class="n">col1</span> <span class="k">ASC</span> <span class="k">LIMIT</span> <span class="mi">5</span><span class="p">;</span>
</pre></table></code></div></div><h4 id="prepareexecute-模式"><span class="mr-2">Prepare/Execute 模式</span><a href="#prepareexecute-模式" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>这个查询中的条件 <code class="language-plaintext highlighter-rouge">col1 = 10036</code>，Prepare/Execute模式下，在优化器眼里其实是 <code class="language-plaintext highlighter-rouge">col1 = ?</code>，使用 gdb 打出 <code class="language-plaintext highlighter-rouge">left_item</code> 和 <code class="language-plaintext highlighter-rouge">right_item</code> 可以验证这一点： <img data-src="/assets/img/database/mysql-prepare-slower-bug/Pasted image 20221117171533.png" alt="" data-proofer-ignore></p><p>而占位符 <code class="language-plaintext highlighter-rouge">?</code>，由于实际的值需要 execute 阶段才传入，prepare 阶段自然是不把它标记为常量的。</p><p>占位符对于这个表达式本身来说也的确不算常量（理由是每一次 execute 传入的实际值可能都不一样），最多只能说它在「某一次具体的执行过程」之中，才可以被认为是常量：</p><div class="language-bash highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="o">(</span>gdb<span class="o">)</span> p left_item-&gt;item_name.m_str <span class="c"># 左 item 名称（col1）</span>
<span class="nv">$76</span> <span class="o">=</span> 0x7f25a4024ef0 <span class="s2">"col1"</span>
<span class="o">(</span>gdb<span class="o">)</span> p right_item-&gt;item_name.m_str <span class="c"># 右 item 名称（?）</span>
<span class="nv">$77</span> <span class="o">=</span> 0x5b6de48 <span class="s2">"?"</span>
<span class="o">(</span>gdb<span class="o">)</span> p <span class="o">((</span>Item_param<span class="k">*</span><span class="o">)</span>right_item<span class="o">)</span>-&gt;value.integer <span class="c"># 右 item 代入值</span>
<span class="nv">$78</span> <span class="o">=</span> 10036
<span class="o">(</span>gdb<span class="o">)</span> p right_item-&gt;const_item<span class="o">()</span> <span class="c"># 右 item 在表达式中是否恒为常量</span>
<span class="nv">$79</span> <span class="o">=</span> <span class="nb">false</span>
</pre></table></code></div></div><p>即对于 <code class="language-plaintext highlighter-rouge">col1 = 10036</code> 条件，在 Prepare/Execute 模式下，实际上优化器看到的是 <code class="language-plaintext highlighter-rouge">col1 = ?</code> ，<code class="language-plaintext highlighter-rouge">right_item-&gt;const_item()</code> 会返回 false。这一点在 <code class="language-plaintext highlighter-rouge">Item::const_item()</code> 中也有提到：</p><div class="language-cpp highlighter-rouge"><div class="code-header"> <span data-label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre><span class="cm">/**
  Returns true if item is constant, regardless of query evaluation state.
  An expression is constant if it:
  - refers no tables.
  - refers no subqueries that refers any tables.
  - refers no non-deterministic functions.
  - refers no statement parameters.             -- 即 `?`
  - contains no group expression under rollup
*/</span>
<span class="kt">bool</span> <span class="nf">const_item</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="p">(</span><span class="n">used_tables</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span> <span class="p">}</span>
</pre></table></code></div></div><p>从而导致 <code class="language-plaintext highlighter-rouge">test_if_equality_guarantees_uniqueness()</code> 认为结果集中 <code class="language-plaintext highlighter-rouge">col1</code> 的值可能不唯一，所以认为需要保留（实际上是冗余的）<code class="language-plaintext highlighter-rouge">ORDER BY col1</code> 条件。</p><h4 id="文本sql模式"><span class="mr-2">文本SQL模式</span><a href="#文本sql模式" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>相比之下，如果我们用文本SQL方式执行，即 <code class="language-plaintext highlighter-rouge">col1 = 10036</code>，则这个条件的右参数 <code class="language-plaintext highlighter-rouge">10036</code> 在表达式解析 Prepare 的时候，值就已经确定下来了，所以 <code class="language-plaintext highlighter-rouge">right_item-&gt;const_item()</code> 为 true：</p><div class="language-bash highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="o">(</span>gdb<span class="o">)</span> p left_item-&gt;item_name.m_str <span class="c"># 左 item 名称（col1）</span>
<span class="nv">$80</span> <span class="o">=</span> 0x7f25a4024de0 <span class="s2">"col1"</span>
<span class="o">(</span>gdb<span class="o">)</span> p right_item-&gt;item_name.m_str <span class="c"># 右 item 名称（10036）</span>
<span class="nv">$81</span> <span class="o">=</span> 0x7f25900074b0 <span class="s2">"10036"</span>
<span class="o">(</span>gdb<span class="o">)</span> p right_item-&gt;const_item<span class="o">()</span> <span class="c"># 右 item 在表达式中是否恒为常量</span>
<span class="nv">$82</span> <span class="o">=</span> <span class="nb">true</span>
</pre></table></code></div></div><p>所以该模式下 <code class="language-plaintext highlighter-rouge">col1 = 10036</code> 能够通过 <code class="language-plaintext highlighter-rouge">test_if_equality_guarantees_uniqueness</code> 检查，优化器能够剔除掉冗余的 <code class="language-plaintext highlighter-rouge">ORDER BY col1</code>。</p><p>从而出现了同一个语句在「Prepare/Execute 模式」和「文本SQL模式」下产生了不同的执行计划的现象。</p><h3 id="分析--结论"><span class="mr-2">分析 &amp; 结论</span><a href="#分析--结论" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p><code class="language-plaintext highlighter-rouge">test_if_equality_guarantees_uniqueness()</code> 要做的，实际上是检查【在这次执行中】 某个 WHERE 条件能否确保结果集中的某一列唯一。所以<strong>其检查的第一个条件 <code class="language-plaintext highlighter-rouge">r-&gt;const_item()</code>（参数是否在整个表达式构造的时候就是 constant 的，无论执行状态）实际上是 overkill。</strong></p><p>（因为 Prepare/Execute 模式下每一次 Execute 都会用当次传入的参数重新跑一遍 optimize） 对于优化器来说，判断某个占位符 item 是否为常量，实际上并不需要关心这一次 Execute 的时候这个占位符的值是不是永远和之前每一次 Execute 的时候相同（即<code class="language-plaintext highlighter-rouge">r-&gt;const_item()</code>为 true），而只需要知道【同一次 Execute 过程内】该占位符 item 的值是常量就足够了。</p><p>Item类实际上也提供了一个方法用来判断某个 item 是不是同一次 execution 内是常量，这个就包括了 <code class="language-plaintext highlighter-rouge">?</code> 占位符的情况：</p><div class="language-sql highlighter-rouge"><div class="code-header"> <span data-label-text="Sql"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre><td class="rouge-code"><pre><span class="cm">/**
  Returns true if item is constant during one query execution.
  If const_for_execution() is true but const_item() is false, value is
  not available before tables have been locked and parameters have been
  assigned values. This applies to
  - statement parameters     &lt;---重点
  - non-dependent subqueries
  - deterministic stored functions that contain SQL code.
  For items where the default implementation of used_tables() and
  const_item() are effective, const_item() will always return true.
*/</span>
<span class="nb">bool</span> <span class="n">const_for_execution</span><span class="p">()</span> <span class="n">const</span> <span class="p">{</span>
  <span class="k">return</span> <span class="o">!</span><span class="p">(</span><span class="n">used_tables</span><span class="p">()</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">INNER_TABLE_BIT</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><p>使用 gdb 验证，<code class="language-plaintext highlighter-rouge">col1 = ?</code> 中的参数<code class="language-plaintext highlighter-rouge">?</code>（代入参数值10036）：</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre>(gdb) p right_item-&gt;item_name.m_str # item 名称
$77 = 0x5b6de48 "?"
(gdb) p ((Item_param*)right_item)-&gt;value.integer # 代入值
$78 = 10036
(gdb) p right_item-&gt;const_item() # 在表达式中是否恒为常量
$79 = false       
(gdb) p right_item-&gt;const_for_execution() # 在*某次具体执行*中是否是常量
$80 = true
</pre></table></code></div></div><p>解决方法就是用 <code class="language-plaintext highlighter-rouge">const_for_execution()</code> 替换 <code class="language-plaintext highlighter-rouge">test_if_equality_guarantees_uniqueness()</code> 中的 <code class="language-plaintext highlighter-rouge">const_item()</code> 判断：</p><div class="language-cpp highlighter-rouge"><div class="code-header"> <span data-label-text="Cpp"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre><span class="k">static</span> <span class="kt">bool</span> <span class="nf">test_if_equality_guarantees_uniqueness</span><span class="p">(</span><span class="k">const</span> <span class="n">Item</span> <span class="o">*</span><span class="n">l</span><span class="p">,</span>
                                                   <span class="k">const</span> <span class="n">Item</span> <span class="o">*</span><span class="n">r</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="cm">/* r-&gt;const_item() is overkill */</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">const_for_execution</span><span class="p">()</span> <span class="o">&amp;&amp;</span>
         <span class="cm">/* elements must be compared as dates */</span>
         <span class="p">(</span><span class="n">Arg_comparator</span><span class="o">::</span><span class="n">can_compare_as_dates</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span> <span class="o">||</span>
          <span class="cm">/* or of the same result type */</span>
          <span class="p">(</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">result_type</span><span class="p">()</span> <span class="o">==</span> <span class="n">l</span><span class="o">-&gt;</span><span class="n">result_type</span><span class="p">()</span> <span class="o">&amp;&amp;</span>
           <span class="cm">/* and must have the same collation if compared as strings */</span>
           <span class="p">(</span><span class="n">l</span><span class="o">-&gt;</span><span class="n">result_type</span><span class="p">()</span> <span class="o">!=</span> <span class="n">STRING_RESULT</span> <span class="o">||</span>
            <span class="n">l</span><span class="o">-&gt;</span><span class="n">collation</span><span class="p">.</span><span class="n">collation</span> <span class="o">==</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">collation</span><span class="p">.</span><span class="n">collation</span><span class="p">)));</span>
<span class="p">}</span>
</pre></table></code></div></div><p>幸运（不幸）的是，追踪代码库中这一行的提交历史，可以看到，这个 bug 在 mysql-8.0.24 中已经被修复了，修复方法就是使用 <code class="language-plaintext highlighter-rouge">const_for_execution()</code> 替换 <code class="language-plaintext highlighter-rouge">const_item()</code>，具体的 patch 是 <a href="https://github.com/mysql/mysql-server/commit/443384454fdbb365a20bfbf86f552ab914d1ea92#diff-16fd8e507582e428d933bc7ee3984394eab544410785220b536ab964d4e9e084L3671">443384454fdbb365a20bfbf86f552ab914d1ea92</a>。</p><p>changelog:</p><blockquote><p>Filesort was used for a query having an ORDER BY … DESC clause, even when an index on the descending column was available and used. This happened because an ORDER BY sub-clause was not removed due to matching a field in an equality predicate, even though it should have, so that the optimizer did not match the query with the descending index, leading to suboptimal performance. (<a href="https://bugs.mysql.com/bug.php?id=101220">Bug #101220</a>, Bug #32038406)</p></blockquote><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
</pre><td class="rouge-code"><pre>The problem here is that an ORDER BY sub-clause was not removed
due to matching a field in an equality predicate, even though it should.
Because of this, the optimizer fails to match the query with a
descending index, causing non-optimal performance.

The essence of the problem is that the function
test_if_equality_guarantees_uniqueness() returns false if collation of
left and right hand side of equality predicate are different.
However, this should not make a difference as long as the collation of
the column in the index matches the collation of the equality operation.
And these should be the same since they are both derived from the
collation of the column.

Thus, the main part of this bugfix is to pass down the actual operation
to the function, and perform an improved collation check.

The logic of the function was also further enhanced:

- It now accepts const values and const-for-execution values such
  as user variables and dynamic parameters.

- It is more specific on rejected predicates involving temporals and
  strings (it rejects predicates where the column is a string and the
  const value is a temporal).

Regression tests were added for these changes as well.
</pre></table></code></div></div><p>经过验证这个 bug 在 mysql-8.0.22 到 mysql-8.0.23 中存在 。腾讯云线上使用的是基于 mysql-8.0.22 的修改版本，所以存在这个缺陷。</p><blockquote><p>edit: 了解到这个 bug 是在 mysql 8.0.22 官方实现 prepare once 功能时引入的众多 bug 之一： https://dev.mysql.com/worklog/task/?id=9384</p></blockquote><h3 id="总结tldr"><span class="mr-2">总结（TLDR）</span><a href="#总结tldr" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>这个问题总结起来就是：优化器在优化 <code class="language-plaintext highlighter-rouge">ORDER BY col1</code> 的时候，有一个检查「WHERE 条件是否使得结果集中 <code class="language-plaintext highlighter-rouge">col1</code> 的值唯一」的检查，作用是如果有存在 <code class="language-plaintext highlighter-rouge">WHERE col1 = 10036</code> 这样的条件，则意味着结果中所有 col1 的值都会是 <code class="language-plaintext highlighter-rouge">10036</code>，那 <code class="language-plaintext highlighter-rouge">ORDER BY col1</code> 排序与否就没有任何差别了，可以直接优化掉。</p><p>这个检查的其中一个步骤，是检查 <code class="language-plaintext highlighter-rouge">col1 = xxx</code> 后面的 xxx 部分是不是一个常量，因为如果假设条件是 <code class="language-plaintext highlighter-rouge">col1 = RAND()</code> 之类，就不能保证结果集中 <code class="language-plaintext highlighter-rouge">col1</code> 的值还是唯一的了。</p><p>问题在于，这个检查在 Prepare/Execute 模式下，MySQL检查过严了，将 <code class="language-plaintext highlighter-rouge">col1 = ?</code> 中的占位符 <code class="language-plaintext highlighter-rouge">?</code> 认为不满足常量条件，不是一个常量，从而导致没能剔除冗余的 <code class="language-plaintext highlighter-rouge">ORDER BY col1</code>，使得执行计划非最优。</p><p>而文本模式下， <code class="language-plaintext highlighter-rouge">col1 = 10036</code> 中的 <code class="language-plaintext highlighter-rouge">10036</code> 是满足常量检查条件的，所以优化器成功剔除了冗余的 <code class="language-plaintext highlighter-rouge">ORDER BY</code>，产生了比 Prepare/Execute 模式更高效的执行计划。</p><h2 id="问题2-order-by-没有利用索引-1"><span class="mr-2">问题2 ORDER BY 没有利用索引</span><a href="#问题2-order-by-没有利用索引-1" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>问题1解释了为何 「Prepare/Execute 模式」下产生的执行计划会比「文本SQL模式」多一个排序的步骤，但是这并不能完整解释为何性能会差那么多，[[#问题分析]]中提到了，Prepare/Execute 模式下，不仅多出来了 ORDER BY 步骤，而且这个步骤本该能利用 col1 上的索引的，但是实际上并没有使用索引，而是进行了一次外排。</p><p>由于这个问题在 MySQL 8.0.22 上没能复现，认定为可能是 TXSQL 8.0.22 的问题，由于没有 TXSQL 8.0.22 的源码，联系内核的维护者协助调查。（WIP）</p><h1 id="解决方案">解决方案</h1><p>对于项目中遇到的场景，在指定 <code class="language-plaintext highlighter-rouge">WHERE col1 = xxx</code> 条件的时候，在构造SQL时就不添加 <code class="language-plaintext highlighter-rouge">ORDER BY col1</code> 条件，防止触发bug。</p><p>并且选择用文本SQL模式来执行请求，规避潜在的问题。</p></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/backend/'>Backend</a>, <a href='/categories/database/'>Database</a>, <a href='/categories/mysql/'>MySQL</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/chinese/" class="post-tag no-text-decoration" >Chinese</a> <a href="/tags/mysql/" class="post-tag no-text-decoration" >MySQL</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=MySQL+Prepare%E5%90%8E%E8%AF%AD%E5%8F%A5%E6%9F%A5%E8%AF%A2%E6%80%A7%E8%83%BD%E9%99%8D%E4%BD%8E+%E5%86%85%E6%A0%B8%E6%BA%90%E7%A0%81bug%E6%8E%92%E6%9F%A5%E5%88%86%E6%9E%90+-+Miigon%27s+blog&url=https%3A%2F%2Fblog.miigon.net%2Fposts%2Fmysql-prepare-slower-query-bug-analyze%2F" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=MySQL+Prepare%E5%90%8E%E8%AF%AD%E5%8F%A5%E6%9F%A5%E8%AF%A2%E6%80%A7%E8%83%BD%E9%99%8D%E4%BD%8E+%E5%86%85%E6%A0%B8%E6%BA%90%E7%A0%81bug%E6%8E%92%E6%9F%A5%E5%88%86%E6%9E%90+-+Miigon%27s+blog&u=https%3A%2F%2Fblog.miigon.net%2Fposts%2Fmysql-prepare-slower-query-bug-analyze%2F" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://t.me/share/url?url=https%3A%2F%2Fblog.miigon.net%2Fposts%2Fmysql-prepare-slower-query-bug-analyze%2F&text=MySQL+Prepare%E5%90%8E%E8%AF%AD%E5%8F%A5%E6%9F%A5%E8%AF%A2%E6%80%A7%E8%83%BD%E9%99%8D%E4%BD%8E+%E5%86%85%E6%A0%B8%E6%BA%90%E7%A0%81bug%E6%8E%92%E6%9F%A5%E5%88%86%E6%9E%90+-+Miigon%27s+blog" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i id="copy-link" class="fa-fw fas fa-link small" data-toggle="tooltip" data-placement="top" title="Copy link" data-title-succeed="Link copied successfully!"> </i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted"><div class="access"><div id="access-lastmod" class="post"><div class="panel-heading">Recently Updated</div><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/storing-hash-objects-on-filesystem/">[随笔]文件系统上存储哈希对象：哈希算法以及目录结构对性能的影响</a><li><a href="/posts/origin-of-git-feat-bitkeeper/">git的前世，和BitKeeper</a><li><a href="/posts/golang-loop-var-reference-problems-and-semantic-fix/">随笔：Golang 循环变量引用问题以及官方语义修复</a><li><a href="/posts/s081-lab6-copy-on-write-fork/">[mit6.s081] 笔记 Lab6: Copy-on-write fork | fork 懒拷贝</a><li><a href="/posts/mysql-prepare-slower-query-bug-analyze/">MySQL Prepare后语句查询性能降低 内核源码bug排查分析</a></ul></div><div id="access-tags"><div class="panel-heading">Trending Tags</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/operating-system/">operating system</a> <a class="post-tag" href="/tags/chinese/">Chinese</a> <a class="post-tag" href="/tags/system-design/">system design</a> <a class="post-tag" href="/tags/c/">C++</a> <a class="post-tag" href="/tags/course-recommendation/">course recommendation</a> <a class="post-tag" href="/tags/grpc/">gRPC</a> <a class="post-tag" href="/tags/translated/">translated</a> <a class="post-tag" href="/tags/announcement/">announcement</a> <a class="post-tag" href="/tags/c-standard/">c++ standard</a> <a class="post-tag" href="/tags/computer-system/">computer system</a></div></div><div id="access-links" class="post"><div class="panel-heading">Links</div><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="http://0xffff.one">0xffff.one 搬砖技术社区</a><li><a href="https://blog.izgq.net">ZGQ's Blog</a></ul></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"><div class="panel-heading pl-3 pt-2 mb-2">Contents</div><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div id="tail-wrapper" class="col-12 col-lg-11 col-xl-9 pl-3 pr-3 pr-xl-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/cn-translation-performance-best-practices-transactions-and-read-write-concerns/"><div class="card-body"> <em class="small" data-ts="1612357751" data-df="ll" > Feb 3, 2021 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>MongoDB 高性能最佳实践: 事务，读取关心程度与写入关心程度</h3><div class="text-muted small"><p> 本文章为翻译作品，原作者为 Mat Keep 与 Henrik Ingo 原文章发布日期 2020年02月25日 原文标题：Performance Best Practices: Transactions and Read / Write Concerns 原文链接：https://www.mongodb.com/blog/post/performance-best-practices...</p></div></div></a></div><div class="card"> <a href="/posts/Decoding-Django-Sessions-in-PostgreSQL/"><div class="card-body"> <em class="small" data-ts="1626067260" data-df="ll" > Jul 12, 2021 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>在 PostgreSQL 中解码 Django Session</h3><div class="text-muted small"><p> 原文地址：Decoding Django Sessions in PostgreSQL 原文作者：Daniel Lifflander 译文出自：掘金翻译计划 本文永久链接：https://github.com/xitu/gold-miner/blob/master/article/2021/Decoding-Django-Sessions-in-Pos...</p></div></div></a></div><div class="card"> <a href="/posts/cn-skip-bytes-while-copying-with-dd/"><div class="card-body"> <em class="small" data-ts="1613625600" data-df="ll" > Feb 18, 2021 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>原理分析：使用 dd 跳过开头若干字节快速拷贝文件</h3><div class="text-muted small"><p> 这篇文章是来自我在 0xffff.one 上的一个帖子 https://0xffff.one/d/900 的回复。 原帖内容： 在折腾一个超大的备份文件，需要把它的前 41 个字节删除掉，没有 WinHEX，想着用 dd 命令来实现 一开始这么干，发现速度奇慢，5分钟过去才复制40MB… dd if=input.bak bs=1 skip=41 &amp;gt; result....</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/mit6830-database-systems/" class="btn btn-outline-primary" prompt="Older"><p>MIT6.830 Database Systems | 数据库系统</p></a> <a href="/posts/does-linux-has-zombie-thread/" class="btn btn-outline-primary" prompt="Newer"><p>Linux 是否有 zombie thread？从glibc和内核源码探究</p></a></div><script type="text/javascript"> $(function () { const origin = "https://giscus.app"; const iframe = "iframe.giscus-frame"; const lightTheme = "light"; const darkTheme = "dark_dimmed"; let initTheme = lightTheme; if ($("html[data-mode=dark]").length > 0 || ($("html[data-mode]").length == 0 && window.matchMedia("(prefers-color-scheme: dark)").matches)) { initTheme = darkTheme; } let giscusAttributes = { "src": "https://giscus.app/client.js", "data-repo": "Miigon/blog", "data-repo-id": "MDEwOlJlcG9zaXRvcnkzMjI1MjkwNzA=", "data-category": "BlogComments", "data-category-id": "DIC_kwDOEzlnLs4CQ6Y4", "data-mapping": "pathname", "data-reactions-enabled": "1", "data-emit-metadata": "0", "data-theme": initTheme, "data-input-position": "top", "data-lang": "en", "crossorigin": "anonymous", "async": "" }; let giscusScript = document.createElement("script"); Object.entries(giscusAttributes).forEach(([key, value]) => giscusScript.setAttribute(key, value)); document.getElementById("tail-wrapper").prepend(giscusScript); addEventListener("message", (event) => { if (event.source === window && event.data && event.data.direction === ModeToggle.ID) { /* global theme mode changed */ const mode = event.data.message; const theme = (mode === ModeToggle.DARK_MODE ? darkTheme : lightTheme); const message = { setConfig: { theme: theme } }; const giscus = document.querySelector(iframe).contentWindow; giscus.postMessage({ giscus: message }, origin); } }); }); </script></div></div><footer class="row pl-3 pr-3"><div class="col-12 d-flex justify-content-between align-items-center text-muted pl-0 pr-0"><div class="footer-left"><p class="mb-0"> © 2023 <a href="https://github.com/Miigon">Miigon</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Customized Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><div id="access-tags"><div class="panel-heading">Trending Tags</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/operating-system/">operating system</a> <a class="post-tag" href="/tags/chinese/">Chinese</a> <a class="post-tag" href="/tags/system-design/">system design</a> <a class="post-tag" href="/tags/c/">C++</a> <a class="post-tag" href="/tags/course-recommendation/">course recommendation</a> <a class="post-tag" href="/tags/grpc/">gRPC</a> <a class="post-tag" href="/tags/translated/">translated</a> <a class="post-tag" href="/tags/announcement/">announcement</a> <a class="post-tag" href="/tags/c-standard/">c++ standard</a> <a class="post-tag" href="/tags/computer-system/">computer system</a></div></div></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a><div id="notification" class="toast" role="alert" aria-live="assertive" aria-atomic="true" data-animation="true" data-autohide="false"><div class="toast-header"> <button type="button" class="ml-2 ml-auto close" data-dismiss="toast" aria-label="Close"> <span aria-hidden="true">&times;</span> </button></div><div class="toast-body text-center pt-0"><p class="pl-2 pr-2 mb-3">A new version of content is available.</p><button type="button" class="btn btn-primary" aria-label="Update"> Update </button></div></div><script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No results found.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/magnific-popup@1/dist/jquery.magnific-popup.min.js,npm/lozad/dist/lozad.min.js,npm/clipboard@2/dist/clipboard.min.js"></script> <script src="https://cdn.jsdelivr.net/combine/npm/dayjs@1/dayjs.min.js,npm/dayjs@1/locale/en.min.js,npm/dayjs@1/plugin/relativeTime.min.js,npm/dayjs@1/plugin/localizedFormat.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.bundle.min.js"></script> <script defer src="/app.js"></script>
