<!DOCTYPE html><html lang="en" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="generator" content="Jekyll v4.2.2" /><meta property="og:title" content="[mit6.s081] 笔记 Lab2: System calls 系统调用" /><meta property="og:locale" content="en" /><meta name="description" content="这是我自学 MIT6.S081 操作系统课程的 lab 代码笔记第二篇：System calls。此 lab 大致耗时：4小时。 课程地址：https://pdos.csail.mit.edu/6.S081/2020/schedule.html Lab 地址：https://pdos.csail.mit.edu/6.S081/2020/labs/syscall.html 我的代码地址：https://github.com/Miigon/my-xv6-labs-2020/tree/syscall Commits: https://github.com/Miigon/my-xv6-labs-2020/commits/syscall 本文中代码注释是编写博客的时候加入的，原仓库中的代码可能缺乏注释或代码不完全相同。" /><meta property="og:description" content="这是我自学 MIT6.S081 操作系统课程的 lab 代码笔记第二篇：System calls。此 lab 大致耗时：4小时。 课程地址：https://pdos.csail.mit.edu/6.S081/2020/schedule.html Lab 地址：https://pdos.csail.mit.edu/6.S081/2020/labs/syscall.html 我的代码地址：https://github.com/Miigon/my-xv6-labs-2020/tree/syscall Commits: https://github.com/Miigon/my-xv6-labs-2020/commits/syscall 本文中代码注释是编写博客的时候加入的，原仓库中的代码可能缺乏注释或代码不完全相同。" /><link rel="canonical" href="https://blog.miigon.net/posts/s081-lab2-system-calls/" /><meta property="og:url" content="https://blog.miigon.net/posts/s081-lab2-system-calls/" /><meta property="og:site_name" content="Miigon’s blog" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2021-09-09T19:00:00+08:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="[mit6.s081] 笔记 Lab2: System calls 系统调用" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2021-09-09T19:00:00+08:00","datePublished":"2021-09-09T19:00:00+08:00","description":"这是我自学 MIT6.S081 操作系统课程的 lab 代码笔记第二篇：System calls。此 lab 大致耗时：4小时。 课程地址：https://pdos.csail.mit.edu/6.S081/2020/schedule.html Lab 地址：https://pdos.csail.mit.edu/6.S081/2020/labs/syscall.html 我的代码地址：https://github.com/Miigon/my-xv6-labs-2020/tree/syscall Commits: https://github.com/Miigon/my-xv6-labs-2020/commits/syscall 本文中代码注释是编写博客的时候加入的，原仓库中的代码可能缺乏注释或代码不完全相同。","headline":"[mit6.s081] 笔记 Lab2: System calls 系统调用","mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.miigon.net/posts/s081-lab2-system-calls/"},"url":"https://blog.miigon.net/posts/s081-lab2-system-calls/"}</script><title>[mit6.s081] 笔记 Lab2: System calls | 系统调用 | Miigon's blog</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="Miigon's blog"><meta name="application-name" content="Miigon's blog"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link rel="dns-prefetch" href="https://fonts.gstatic.com" crossorigin><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://cdn.jsdelivr.net" ><link rel="dns-prefetch" href="https://cdn.jsdelivr.net" ><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Lato&family=Source+Sans+Pro:wght@400;600;700;900&display=swap"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get MODE_ATTR() { return "data-mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } static get ID() { return "mode-toggle"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } let self = this; /* always follow the system prefers */ this.sysDarkPrefers.addEventListener("change", () => { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.notify(); }); } /* constructor() */ get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode === ModeToggle.DARK_MODE; } get isLightMode() { return this.mode === ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer)) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } setDark() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_ATTR); sessionStorage.removeItem(ModeToggle.MODE_KEY); } /* Notify another plugins that the theme mode has changed */ notify() { window.postMessage({ direction: ModeToggle.ID, message: this.modeStatus }, "*"); } } /* ModeToggle */ const toggle = new ModeToggle(); function flipMode() { if (toggle.hasMode) { if (toggle.isSysDarkPrefer) { if (toggle.isLightMode) { toggle.clearMode(); } else { toggle.setLight(); } } else { if (toggle.isDarkMode) { toggle.clearMode(); } else { toggle.setDark(); } } } else { if (toggle.isSysDarkPrefer) { toggle.setLight(); } else { toggle.setDark(); } } toggle.notify(); } /* flipMode() */ </script><body data-spy="scroll" data-target="#toc" data-topbar-visible="true"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" class="mx-auto"> <img src="/assets/img/avatar.png" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">Miigon's blog</a></div><div class="site-subtitle font-italic">My ideas, thoughts and experiences</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tag ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info-circle ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center align-items-center"> <button class="mode-toggle btn" aria-label="Switch Mode"> <i class="fas fa-adjust"></i> </button> <span class="icon-border"></span> <a href="https://github.com/Miigon" aria-label="github" target="_blank" rel="noopener"> <i class="fab fa-github-alt"></i> </a> <a href="https://twitter.com/" aria-label="twitter" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['miigon.pg','gmail.com'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="https://stackoverflow.com/users/7509248/miigon" aria-label="stack-overflow" target="_blank" rel="noopener"> <i class="fab fa-stack-overflow"></i> </a></div></div><div id="topbar-wrapper"><div id="topbar" class="container d-flex align-items-center justify-content-between h-100 pl-3 pr-3 pl-md-4 pr-md-4"> <span id="breadcrumb"> <span> <a href="/"> Home </a> </span> <span>[mit6.s081] 笔记 Lab2: System calls | 系统调用</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..."> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper" class="d-flex justify-content-center"><div id="main" class="container pl-xl-4 pr-xl-4"><div class="row"><div id="core-wrapper" class="col-12 col-lg-11 col-xl-9 pr-xl-4"><div class="post pl-1 pr-1 pl-md-2 pr-md-2"><h1 data-toc-skip>[mit6.s081] 笔记 Lab2: System calls | 系统调用</h1><div class="post-meta text-muted"> <span> Posted <em class="" data-ts="1631185200" data-df="ll" data-toggle="tooltip" data-placement="bottom"> Sep 9, 2021 </em> </span><div class="d-flex justify-content-between"> <span> By <em> <a href="https://github.com/Miigon">Miigon</a> </em> </span><div> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="3824 words"> <em>21 min</em> read</span></div></div></div><div class="post-content"><blockquote><p>这是我自学 MIT6.S081 操作系统课程的 lab 代码笔记第二篇：System calls。此 lab 大致耗时：4小时。</p><p>课程地址：<a href="https://pdos.csail.mit.edu/6.S081/2020/schedule.html">https://pdos.csail.mit.edu/6.S081/2020/schedule.html</a><br /> Lab 地址：<a href="https://pdos.csail.mit.edu/6.S081/2020/labs/syscall.html">https://pdos.csail.mit.edu/6.S081/2020/labs/syscall.html</a><br /> 我的代码地址：<a href="https://github.com/Miigon/my-xv6-labs-2020/tree/syscall">https://github.com/Miigon/my-xv6-labs-2020/tree/syscall</a><br /> Commits: <a href="https://github.com/Miigon/my-xv6-labs-2020/commits/syscall">https://github.com/Miigon/my-xv6-labs-2020/commits/syscall</a></p><p>本文中代码注释是编写博客的时候加入的，原仓库中的代码可能缺乏注释或代码不完全相同。</p></blockquote><h1 id="lab-2-system-calls">Lab 2: System calls</h1><p>In this lab you will add some new system calls to xv6, which will help you understand how they work and will expose you to some of the internals of the xv6 kernel. You will add more system calls in later labs.</p><p>对 xv6 添加一些新的系统调用，帮助加深对 xv6 内核的理解。</p><h1 id="system-call-tracing-moderate">System call tracing (moderate)</h1><p>准备环境，编译编译器、QEMU，克隆仓库，略过。</p><blockquote><p>In this assignment you will add a system call tracing feature that may help you when debugging later labs. You’ll create a new trace system call that will control tracing. It should take one argument, an integer “mask”, whose bits specify which system calls to trace. For example, to trace the fork system call, a program calls trace(1 « SYS_fork), where SYS_fork is a syscall number from kernel/syscall.h. You have to modify the xv6 kernel to print out a line when each system call is about to return, if the system call’s number is set in the mask. The line should contain the process id, the name of the system call and the return value; you don’t need to print the system call arguments. The trace system call should enable tracing for the process that calls it and any children that it subsequently forks, but should not affect other processes.</p></blockquote><p>添加一个系统调用 trace 的功能，为每个进程设定一个位 mask，用 mask 中设定的位来指定要为哪些系统调用输出调试信息。</p><h2 id="如何创建新系统调用"><span class="mr-2">如何创建新系统调用</span><a href="#如何创建新系统调用" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><ol><li>首先在内核中合适的位置（取决于要实现的功能属于什么模块，理论上随便放都可以，只是主要起归类作用），实现我们的内核调用（在这里是 trace 调用）：<div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre> <span class="c1">// kernel/sysproc.c</span>
 <span class="c1">// 这里着重理解如何添加系统调用，对于这个调用的具体代码细节在后面的部分分析</span>
 <span class="n">uint64</span>
 <span class="nf">sys_trace</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
 <span class="p">{</span>
 <span class="kt">int</span> <span class="n">mask</span><span class="p">;</span>

 <span class="k">if</span><span class="p">(</span><span class="n">argint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mask</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
     <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	
 <span class="n">myproc</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">syscall_trace</span> <span class="o">=</span> <span class="n">mask</span><span class="p">;</span>
 <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
 <span class="p">}</span>
</pre></table></code></div></div><p>这里因为我们的系统调用会对进程进行操作，所以放在 sysproc.c 较为合适。</p><li>在 syscall.h 中加入新 system call 的序号：<div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
</pre><td class="rouge-code"><pre> <span class="c1">// kernel/syscall.h</span>
 <span class="c1">// System call numbers</span>
 <span class="cp">#define SYS_fork    1
</span> <span class="cp">#define SYS_exit    2
</span> <span class="cp">#define SYS_wait    3
</span> <span class="cp">#define SYS_pipe    4
</span> <span class="cp">#define SYS_read    5
</span> <span class="cp">#define SYS_kill    6
</span> <span class="cp">#define SYS_exec    7
</span> <span class="cp">#define SYS_fstat   8
</span> <span class="cp">#define SYS_chdir   9
</span> <span class="cp">#define SYS_dup    10
</span> <span class="cp">#define SYS_getpid 11
</span> <span class="cp">#define SYS_sbrk   12
</span> <span class="cp">#define SYS_sleep  13
</span> <span class="cp">#define SYS_uptime 14
</span> <span class="cp">#define SYS_open   15
</span> <span class="cp">#define SYS_write  16
</span> <span class="cp">#define SYS_mknod  17
</span> <span class="cp">#define SYS_unlink 18
</span> <span class="cp">#define SYS_link   19
</span> <span class="cp">#define SYS_mkdir  20
</span> <span class="cp">#define SYS_close  21
</span> <span class="cp">#define SYS_trace  22 // here!!!!!
</span></pre></table></code></div></div><li>用 extern 全局声明新的内核调用函数，并且在 syscalls 映射表中，加入从前面定义的编号到系统调用函数指针的映射<div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
</pre><td class="rouge-code"><pre> <span class="c1">// kernel/syscall.c </span>
 <span class="k">extern</span> <span class="n">uint64</span> <span class="nf">sys_chdir</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
 <span class="k">extern</span> <span class="n">uint64</span> <span class="nf">sys_close</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
 <span class="k">extern</span> <span class="n">uint64</span> <span class="nf">sys_dup</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
 <span class="k">extern</span> <span class="n">uint64</span> <span class="nf">sys_exec</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
 <span class="k">extern</span> <span class="n">uint64</span> <span class="nf">sys_exit</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
 <span class="k">extern</span> <span class="n">uint64</span> <span class="nf">sys_fork</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
 <span class="k">extern</span> <span class="n">uint64</span> <span class="nf">sys_fstat</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
 <span class="k">extern</span> <span class="n">uint64</span> <span class="nf">sys_getpid</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
 <span class="k">extern</span> <span class="n">uint64</span> <span class="nf">sys_kill</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
 <span class="k">extern</span> <span class="n">uint64</span> <span class="nf">sys_link</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
 <span class="k">extern</span> <span class="n">uint64</span> <span class="nf">sys_mkdir</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
 <span class="k">extern</span> <span class="n">uint64</span> <span class="nf">sys_mknod</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
 <span class="k">extern</span> <span class="n">uint64</span> <span class="nf">sys_open</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
 <span class="k">extern</span> <span class="n">uint64</span> <span class="nf">sys_pipe</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
 <span class="k">extern</span> <span class="n">uint64</span> <span class="nf">sys_read</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
 <span class="k">extern</span> <span class="n">uint64</span> <span class="nf">sys_sbrk</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
 <span class="k">extern</span> <span class="n">uint64</span> <span class="nf">sys_sleep</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
 <span class="k">extern</span> <span class="n">uint64</span> <span class="nf">sys_unlink</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
 <span class="k">extern</span> <span class="n">uint64</span> <span class="nf">sys_wait</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
 <span class="k">extern</span> <span class="n">uint64</span> <span class="nf">sys_write</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
 <span class="k">extern</span> <span class="n">uint64</span> <span class="nf">sys_uptime</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
 <span class="k">extern</span> <span class="n">uint64</span> <span class="nf">sys_trace</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>   <span class="c1">// HERE</span>

 <span class="k">static</span> <span class="n">uint64</span> <span class="p">(</span><span class="o">*</span><span class="n">syscalls</span><span class="p">[])(</span><span class="kt">void</span><span class="p">)</span> <span class="o">=</span> <span class="p">{</span>
 <span class="p">[</span><span class="n">SYS_fork</span><span class="p">]</span>    <span class="n">sys_fork</span><span class="p">,</span>
 <span class="p">[</span><span class="n">SYS_exit</span><span class="p">]</span>    <span class="n">sys_exit</span><span class="p">,</span>
 <span class="p">[</span><span class="n">SYS_wait</span><span class="p">]</span>    <span class="n">sys_wait</span><span class="p">,</span>
 <span class="p">[</span><span class="n">SYS_pipe</span><span class="p">]</span>    <span class="n">sys_pipe</span><span class="p">,</span>
 <span class="p">[</span><span class="n">SYS_read</span><span class="p">]</span>    <span class="n">sys_read</span><span class="p">,</span>
 <span class="p">[</span><span class="n">SYS_kill</span><span class="p">]</span>    <span class="n">sys_kill</span><span class="p">,</span>
 <span class="p">[</span><span class="n">SYS_exec</span><span class="p">]</span>    <span class="n">sys_exec</span><span class="p">,</span>
 <span class="p">[</span><span class="n">SYS_fstat</span><span class="p">]</span>   <span class="n">sys_fstat</span><span class="p">,</span>
 <span class="p">[</span><span class="n">SYS_chdir</span><span class="p">]</span>   <span class="n">sys_chdir</span><span class="p">,</span>
 <span class="p">[</span><span class="n">SYS_dup</span><span class="p">]</span>     <span class="n">sys_dup</span><span class="p">,</span>
 <span class="p">[</span><span class="n">SYS_getpid</span><span class="p">]</span>  <span class="n">sys_getpid</span><span class="p">,</span>
 <span class="p">[</span><span class="n">SYS_sbrk</span><span class="p">]</span>    <span class="n">sys_sbrk</span><span class="p">,</span>
 <span class="p">[</span><span class="n">SYS_sleep</span><span class="p">]</span>   <span class="n">sys_sleep</span><span class="p">,</span>
 <span class="p">[</span><span class="n">SYS_uptime</span><span class="p">]</span>  <span class="n">sys_uptime</span><span class="p">,</span>
 <span class="p">[</span><span class="n">SYS_open</span><span class="p">]</span>    <span class="n">sys_open</span><span class="p">,</span>
 <span class="p">[</span><span class="n">SYS_write</span><span class="p">]</span>   <span class="n">sys_write</span><span class="p">,</span>
 <span class="p">[</span><span class="n">SYS_mknod</span><span class="p">]</span>   <span class="n">sys_mknod</span><span class="p">,</span>
 <span class="p">[</span><span class="n">SYS_unlink</span><span class="p">]</span>  <span class="n">sys_unlink</span><span class="p">,</span>
 <span class="p">[</span><span class="n">SYS_link</span><span class="p">]</span>    <span class="n">sys_link</span><span class="p">,</span>
 <span class="p">[</span><span class="n">SYS_mkdir</span><span class="p">]</span>   <span class="n">sys_mkdir</span><span class="p">,</span>
 <span class="p">[</span><span class="n">SYS_close</span><span class="p">]</span>   <span class="n">sys_close</span><span class="p">,</span>
 <span class="p">[</span><span class="n">SYS_trace</span><span class="p">]</span>   <span class="n">sys_trace</span><span class="p">,</span>  <span class="c1">// AND HERE</span>
 <span class="p">};</span>
</pre></table></code></div></div><p>这里 <code class="language-plaintext highlighter-rouge">[SYS_trace] sys_trace</code> 是 C 语言数组的一个语法，表示以方括号内的值作为元素下标。比如 <code class="language-plaintext highlighter-rouge">int arr[] = {[3] 2333, [6] 6666}</code> 代表 arr 的下标 3 的元素为 2333，下标 6 的元素为 6666，其他元素填充 0 的数组。（该语法在 C++ 中已不可用）</p><li>在 usys.pl 中，加入用户态到内核态的跳板函数。<div class="language-perl highlighter-rouge"><div class="code-header"> <span data-label-text="Perl"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
</pre><td class="rouge-code"><pre> <span class="c1"># user/usys.pl</span>

 <span class="nv">entry</span><span class="p">("</span><span class="s2">fork</span><span class="p">");</span>
 <span class="nv">entry</span><span class="p">("</span><span class="s2">exit</span><span class="p">");</span>
 <span class="nv">entry</span><span class="p">("</span><span class="s2">wait</span><span class="p">");</span>
 <span class="nv">entry</span><span class="p">("</span><span class="s2">pipe</span><span class="p">");</span>
 <span class="nv">entry</span><span class="p">("</span><span class="s2">read</span><span class="p">");</span>
 <span class="nv">entry</span><span class="p">("</span><span class="s2">write</span><span class="p">");</span>
 <span class="nv">entry</span><span class="p">("</span><span class="s2">close</span><span class="p">");</span>
 <span class="nv">entry</span><span class="p">("</span><span class="s2">kill</span><span class="p">");</span>
 <span class="nv">entry</span><span class="p">("</span><span class="s2">exec</span><span class="p">");</span>
 <span class="nv">entry</span><span class="p">("</span><span class="s2">open</span><span class="p">");</span>
 <span class="nv">entry</span><span class="p">("</span><span class="s2">mknod</span><span class="p">");</span>
 <span class="nv">entry</span><span class="p">("</span><span class="s2">unlink</span><span class="p">");</span>
 <span class="nv">entry</span><span class="p">("</span><span class="s2">fstat</span><span class="p">");</span>
 <span class="nv">entry</span><span class="p">("</span><span class="s2">link</span><span class="p">");</span>
 <span class="nv">entry</span><span class="p">("</span><span class="s2">mkdir</span><span class="p">");</span>
 <span class="nv">entry</span><span class="p">("</span><span class="s2">chdir</span><span class="p">");</span>
 <span class="nv">entry</span><span class="p">("</span><span class="s2">dup</span><span class="p">");</span>
 <span class="nv">entry</span><span class="p">("</span><span class="s2">getpid</span><span class="p">");</span>
 <span class="nv">entry</span><span class="p">("</span><span class="s2">sbrk</span><span class="p">");</span>
 <span class="nv">entry</span><span class="p">("</span><span class="s2">sleep</span><span class="p">");</span>
 <span class="nv">entry</span><span class="p">("</span><span class="s2">uptime</span><span class="p">");</span>
 <span class="nv">entry</span><span class="p">("</span><span class="s2">trace</span><span class="p">");</span>  <span class="c1"># HERE</span>
</pre></table></code></div></div><p>这个脚本在运行后会生成 usys.S 汇编文件，里面定义了每个 system call 的用户态跳板函数：</p><pre><code class="language-asm"> trace:		# 定义用户态跳板函数
 li a7, SYS_trace	# 将系统调用 id 存入 a7 寄存器
 ecall				# ecall，调用 system call ，跳到内核态的统一系统调用处理函数 syscall()  (syscall.c)
 ret
</code></pre><li>在用户态的头文件加入定义，使得用户态程序可以找到这个跳板入口函数。<div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
</pre><td class="rouge-code"><pre> <span class="c1">// user/user.h</span>
 <span class="c1">// system calls</span>
 <span class="kt">int</span> <span class="nf">fork</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
 <span class="kt">int</span> <span class="nf">exit</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">noreturn</span><span class="p">));</span>
 <span class="kt">int</span> <span class="nf">wait</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="p">);</span>
 <span class="kt">int</span> <span class="nf">pipe</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="p">);</span>
 <span class="kt">int</span> <span class="nf">write</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span><span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
 <span class="kt">int</span> <span class="nf">read</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">void</span><span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
 <span class="kt">int</span> <span class="nf">close</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>
 <span class="kt">int</span> <span class="nf">kill</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>
 <span class="kt">int</span> <span class="nf">exec</span><span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="p">,</span> <span class="kt">char</span><span class="o">**</span><span class="p">);</span>
 <span class="kt">int</span> <span class="nf">open</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
 <span class="kt">int</span> <span class="nf">mknod</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span><span class="p">,</span> <span class="kt">short</span><span class="p">,</span> <span class="kt">short</span><span class="p">);</span>
 <span class="kt">int</span> <span class="nf">unlink</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span><span class="p">);</span>
 <span class="kt">int</span> <span class="nf">fstat</span><span class="p">(</span><span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">stat</span><span class="o">*</span><span class="p">);</span>
 <span class="kt">int</span> <span class="nf">link</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span><span class="o">*</span><span class="p">);</span>
 <span class="kt">int</span> <span class="nf">mkdir</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span><span class="p">);</span>
 <span class="kt">int</span> <span class="nf">chdir</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span><span class="p">);</span>
 <span class="kt">int</span> <span class="nf">dup</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>
 <span class="kt">int</span> <span class="nf">getpid</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
 <span class="kt">char</span><span class="o">*</span> <span class="nf">sbrk</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>
 <span class="kt">int</span> <span class="nf">sleep</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>
 <span class="kt">int</span> <span class="nf">uptime</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
 <span class="kt">int</span> <span class="nf">trace</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>		<span class="c1">// HERE</span>
</pre></table></code></div></div></ol><h2 id="系统调用全流程"><span class="mr-2">系统调用全流程</span><a href="#系统调用全流程" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre>user/user.h:		用户态程序调用跳板函数 trace()
user/usys.S:		跳板函数 trace() 使用 CPU 提供的 ecall 指令，调用到内核态
kernel/syscall.c	到达内核态统一系统调用处理函数 syscall()，所有系统调用都会跳到这里来处理。
kernel/syscall.c	syscall() 根据跳板传进来的系统调用编号，查询 syscalls[] 表，找到对应的内核函数并调用。
kernel/sysproc.c	到达 sys_trace() 函数，执行具体内核操作
</pre></table></code></div></div><p>这么繁琐的调用流程的主要目的是实现用户态和内核态的良好隔离。</p><p>并且由于内核与用户进程的页表不同，寄存器也不互通，所以参数无法直接通过 C 语言参数的形式传过来，而是需要使用 argaddr、argint、argstr 等系列函数，从进程的 trapframe 中读取用户进程寄存器中的参数。</p><p>同时由于页表不同，指针也不能直接互通访问（也就是内核不能直接对用户态传进来的指针进行解引用），而是需要使用 copyin、copyout 方法结合进程的页表，才能顺利找到用户态指针（逻辑地址）对应的物理内存地址。（在本 lab 第二个实验会用到）</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre>struct proc *p = myproc(); // 获取调用该 system call 的进程的 proc 结构
copyout(p-&gt;pagetable, addr, (char *)&amp;data, sizeof(data)); // 将内核态的 data 变量（常为struct），结合进程的页表，写到进程内存空间内的 addr 地址处。
</pre></table></code></div></div><h2 id="该-lab-代码"><span class="mr-2">该 lab 代码</span><a href="#该-lab-代码" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>首先在 proc.h 中修改 proc 结构的定义，添加 syscall_trace field，用 mask 的方式记录要 trace 的 system call。</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
</pre><td class="rouge-code"><pre><span class="c1">// kernel/proc.h</span>
<span class="c1">// Per-process state</span>
<span class="k">struct</span> <span class="n">proc</span> <span class="p">{</span>
  <span class="k">struct</span> <span class="n">spinlock</span> <span class="n">lock</span><span class="p">;</span>

  <span class="c1">// p-&gt;lock must be held when using these:</span>
  <span class="k">enum</span> <span class="n">procstate</span> <span class="n">state</span><span class="p">;</span>        <span class="c1">// Process state</span>
  <span class="k">struct</span> <span class="n">proc</span> <span class="o">*</span><span class="n">parent</span><span class="p">;</span>         <span class="c1">// Parent process</span>
  <span class="kt">void</span> <span class="o">*</span><span class="n">chan</span><span class="p">;</span>                  <span class="c1">// If non-zero, sleeping on chan</span>
  <span class="kt">int</span> <span class="n">killed</span><span class="p">;</span>                  <span class="c1">// If non-zero, have been killed</span>
  <span class="kt">int</span> <span class="n">xstate</span><span class="p">;</span>                  <span class="c1">// Exit status to be returned to parent's wait</span>
  <span class="kt">int</span> <span class="n">pid</span><span class="p">;</span>                     <span class="c1">// Process ID</span>

  <span class="c1">// these are private to the process, so p-&gt;lock need not be held.</span>
  <span class="n">uint64</span> <span class="n">kstack</span><span class="p">;</span>               <span class="c1">// Virtual address of kernel stack</span>
  <span class="n">uint64</span> <span class="n">sz</span><span class="p">;</span>                   <span class="c1">// Size of process memory (bytes)</span>
  <span class="n">pagetable_t</span> <span class="n">pagetable</span><span class="p">;</span>       <span class="c1">// User page table</span>
  <span class="k">struct</span> <span class="n">trapframe</span> <span class="o">*</span><span class="n">trapframe</span><span class="p">;</span> <span class="c1">// data page for trampoline.S</span>
  <span class="k">struct</span> <span class="n">context</span> <span class="n">context</span><span class="p">;</span>      <span class="c1">// swtch() here to run process</span>
  <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">ofile</span><span class="p">[</span><span class="n">NOFILE</span><span class="p">];</span>  <span class="c1">// Open files</span>
  <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">cwd</span><span class="p">;</span>           <span class="c1">// Current directory</span>
  <span class="kt">char</span> <span class="n">name</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span>               <span class="c1">// Process name (debugging)</span>
  <span class="n">uint64</span> <span class="n">syscall_trace</span><span class="p">;</span>        <span class="c1">// Mask for syscall tracing (新添加的用于标识追踪哪些 system call 的 mask)</span>
<span class="p">};</span>
</pre></table></code></div></div><p>在 proc.c 中，创建新进程的时候，为新添加的 syscall_trace 附上默认值 0（否则初始状态下可能会有垃圾数据）。</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre><td class="rouge-code"><pre><span class="c1">// kernel/proc.c</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">proc</span><span class="o">*</span>
<span class="nf">allocproc</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
  <span class="p">......</span>

  <span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">context</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">context</span><span class="p">));</span>
  <span class="n">p</span><span class="o">-&gt;</span><span class="n">context</span><span class="p">.</span><span class="n">ra</span> <span class="o">=</span> <span class="p">(</span><span class="n">uint64</span><span class="p">)</span><span class="n">forkret</span><span class="p">;</span>
  <span class="n">p</span><span class="o">-&gt;</span><span class="n">context</span><span class="p">.</span><span class="n">sp</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">kstack</span> <span class="o">+</span> <span class="n">PGSIZE</span><span class="p">;</span>

  <span class="n">p</span><span class="o">-&gt;</span><span class="n">syscall_trace</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// (newly added) 为 syscall_trace 设置一个 0 的默认值</span>

  <span class="k">return</span> <span class="n">p</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>在 sysproc.c 中，实现 system call 的具体代码，也就是设置当前进程的 syscall_trace mask：</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre><span class="c1">// kernel/sysproc.c</span>
<span class="n">uint64</span>
<span class="nf">sys_trace</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">mask</span><span class="p">;</span>

  <span class="k">if</span><span class="p">(</span><span class="n">argint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mask</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="c1">// 通过读取进程的 trapframe，获得 mask 参数</span>
    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
  
  <span class="n">myproc</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">syscall_trace</span> <span class="o">=</span> <span class="n">mask</span><span class="p">;</span> <span class="c1">// 设置调用进程的 syscall_trace mask</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>修改 fork 函数，使得子进程可以继承父进程的 syscall_trace mask：</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre><td class="rouge-code"><pre><span class="c1">// kernel/proc.c</span>
<span class="kt">int</span>
<span class="nf">fork</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
  <span class="p">......</span>

  <span class="n">safestrcpy</span><span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">));</span>

  <span class="n">np</span><span class="o">-&gt;</span><span class="n">syscall_trace</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">syscall_trace</span><span class="p">;</span> <span class="c1">// HERE!!! 子进程继承父进程的 syscall_trace</span>

  <span class="n">pid</span> <span class="o">=</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">;</span>

  <span class="n">np</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">RUNNABLE</span><span class="p">;</span>

  <span class="n">release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

  <span class="k">return</span> <span class="n">pid</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>根据上方提到的系统调用的全流程，可以知道，所有的系统调用到达内核态后，都会进入到 syscall() 这个函数进行处理，所以要跟踪所有的内核函数，只需要在 syscall() 函数里埋点就行了。</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre><td class="rouge-code"><pre><span class="c1">// kernel/syscall.c</span>
<span class="kt">void</span>
<span class="nf">syscall</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">num</span><span class="p">;</span>
  <span class="k">struct</span> <span class="n">proc</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">myproc</span><span class="p">();</span>

  <span class="n">num</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">trapframe</span><span class="o">-&gt;</span><span class="n">a7</span><span class="p">;</span>
  <span class="k">if</span><span class="p">(</span><span class="n">num</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">num</span> <span class="o">&lt;</span> <span class="n">NELEM</span><span class="p">(</span><span class="n">syscalls</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">syscalls</span><span class="p">[</span><span class="n">num</span><span class="p">])</span> <span class="p">{</span> <span class="c1">// 如果系统调用编号有效</span>
    <span class="n">p</span><span class="o">-&gt;</span><span class="n">trapframe</span><span class="o">-&gt;</span><span class="n">a0</span> <span class="o">=</span> <span class="n">syscalls</span><span class="p">[</span><span class="n">num</span><span class="p">]();</span> <span class="c1">// 通过系统调用编号，获取系统调用处理函数的指针，调用并将返回值存到用户进程的 a0 寄存器中</span>
	<span class="c1">// 如果当前进程设置了对该编号系统调用的 trace，则打出 pid、系统调用名称和返回值。</span>
    <span class="k">if</span><span class="p">((</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">syscall_trace</span> <span class="o">&gt;&gt;</span> <span class="n">num</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">printf</span><span class="p">(</span><span class="s">"%d: syscall %s -&gt; %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">,</span> <span class="n">syscall_names</span><span class="p">[</span><span class="n">num</span><span class="p">],</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">trapframe</span><span class="o">-&gt;</span><span class="n">a0</span><span class="p">);</span> <span class="c1">// syscall_names[num]: 从 syscall 编号到 syscall 名的映射表</span>
    <span class="p">}</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"%d %s: unknown sys call %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
            <span class="n">p</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">,</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">num</span><span class="p">);</span>
    <span class="n">p</span><span class="o">-&gt;</span><span class="n">trapframe</span><span class="o">-&gt;</span><span class="n">a0</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><p>上面打出日志的过程还需要知道系统调用的名称字符串，在这里定义一个字符串数组进行映射：</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
</pre><td class="rouge-code"><pre><span class="c1">// kernel/syscall.c</span>
<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">syscall_names</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
<span class="p">[</span><span class="n">SYS_fork</span><span class="p">]</span>    <span class="s">"fork"</span><span class="p">,</span>
<span class="p">[</span><span class="n">SYS_exit</span><span class="p">]</span>    <span class="s">"exit"</span><span class="p">,</span>
<span class="p">[</span><span class="n">SYS_wait</span><span class="p">]</span>    <span class="s">"wait"</span><span class="p">,</span>
<span class="p">[</span><span class="n">SYS_pipe</span><span class="p">]</span>    <span class="s">"pipe"</span><span class="p">,</span>
<span class="p">[</span><span class="n">SYS_read</span><span class="p">]</span>    <span class="s">"read"</span><span class="p">,</span>
<span class="p">[</span><span class="n">SYS_kill</span><span class="p">]</span>    <span class="s">"kill"</span><span class="p">,</span>
<span class="p">[</span><span class="n">SYS_exec</span><span class="p">]</span>    <span class="s">"exec"</span><span class="p">,</span>
<span class="p">[</span><span class="n">SYS_fstat</span><span class="p">]</span>   <span class="s">"fstat"</span><span class="p">,</span>
<span class="p">[</span><span class="n">SYS_chdir</span><span class="p">]</span>   <span class="s">"chdir"</span><span class="p">,</span>
<span class="p">[</span><span class="n">SYS_dup</span><span class="p">]</span>     <span class="s">"dup"</span><span class="p">,</span>
<span class="p">[</span><span class="n">SYS_getpid</span><span class="p">]</span>  <span class="s">"getpid"</span><span class="p">,</span>
<span class="p">[</span><span class="n">SYS_sbrk</span><span class="p">]</span>    <span class="s">"sbrk"</span><span class="p">,</span>
<span class="p">[</span><span class="n">SYS_sleep</span><span class="p">]</span>   <span class="s">"sleep"</span><span class="p">,</span>
<span class="p">[</span><span class="n">SYS_uptime</span><span class="p">]</span>  <span class="s">"uptime"</span><span class="p">,</span>
<span class="p">[</span><span class="n">SYS_open</span><span class="p">]</span>    <span class="s">"open"</span><span class="p">,</span>
<span class="p">[</span><span class="n">SYS_write</span><span class="p">]</span>   <span class="s">"write"</span><span class="p">,</span>
<span class="p">[</span><span class="n">SYS_mknod</span><span class="p">]</span>   <span class="s">"mknod"</span><span class="p">,</span>
<span class="p">[</span><span class="n">SYS_unlink</span><span class="p">]</span>  <span class="s">"unlink"</span><span class="p">,</span>
<span class="p">[</span><span class="n">SYS_link</span><span class="p">]</span>    <span class="s">"link"</span><span class="p">,</span>
<span class="p">[</span><span class="n">SYS_mkdir</span><span class="p">]</span>   <span class="s">"mkdir"</span><span class="p">,</span>
<span class="p">[</span><span class="n">SYS_close</span><span class="p">]</span>   <span class="s">"close"</span><span class="p">,</span>
<span class="p">[</span><span class="n">SYS_trace</span><span class="p">]</span>   <span class="s">"trace"</span><span class="p">,</span>
<span class="p">};</span>
</pre></table></code></div></div><p>编译执行：</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre><td class="rouge-code"><pre>$ trace 32 grep hello README
3: syscall read -&gt; 1023
3: syscall read -&gt; 966
3: syscall read -&gt; 70
3: syscall read -&gt; 0
$
$ trace 2147483647 grep hello README
4: syscall trace -&gt; 0
4: syscall exec -&gt; 3
4: syscall open -&gt; 3
4: syscall read -&gt; 1023
4: syscall read -&gt; 966
4: syscall read -&gt; 70
4: syscall read -&gt; 0
4: syscall close -&gt; 0
$
</pre></table></code></div></div><p>成功追踪并打印出相应的系统调用。</p><h1 id="sysinfo-moderate">Sysinfo (moderate)</h1><blockquote><p>In this assignment you will add a system call, sysinfo, that collects information about the running system. The system call takes one argument: a pointer to a struct sysinfo (see kernel/sysinfo.h). The kernel should fill out the fields of this struct: the freemem field should be set to the number of bytes of free memory, and the nproc field should be set to the number of processes whose state is not UNUSED. We provide a test program sysinfotest; you pass this assignment if it prints “sysinfotest: OK”.</p></blockquote><p>添加一个系统调用，返回空闲的内存、以及已创建的进程数量。大多数步骤和上个实验是一样的，所以不再描述。唯一不同就是需要把结构体从内核内存拷贝到用户进程内存中。其他的难点可能就是在如何获取空闲内存和如何获取已创建进程上面了，因为涉及到了一些后面的知识。</p><h2 id="获取空闲内存"><span class="mr-2">获取空闲内存</span><a href="#获取空闲内存" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>在内核的头文件中声明计算空闲内存的函数，因为是内存相关的，所以放在 kalloc、kfree 等函数的的声明之后。</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="c1">// kernel/defs.h</span>
<span class="kt">void</span><span class="o">*</span>           <span class="nf">kalloc</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="kt">void</span>            <span class="nf">kfree</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">);</span>
<span class="kt">void</span>            <span class="nf">kinit</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="n">uint64</span> 			<span class="nf">count_free_mem</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span> <span class="c1">// here</span>
</pre></table></code></div></div><p>在 kalloc.c 中添加计算空闲内存的函数：</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre><td class="rouge-code"><pre><span class="c1">// kernel/kalloc.c</span>
<span class="n">uint64</span>
<span class="nf">count_free_mem</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="c1">// added for counting free memory in bytes (lab2)</span>
<span class="p">{</span>
  <span class="n">acquire</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kmem</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span> <span class="c1">// 必须先锁内存管理结构，防止竞态条件出现</span>
  
  <span class="c1">// 统计空闲页数，乘上页大小 PGSIZE 就是空闲的内存字节数</span>
  <span class="n">uint64</span> <span class="n">mem_bytes</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">struct</span> <span class="n">run</span> <span class="o">*</span><span class="n">r</span> <span class="o">=</span> <span class="n">kmem</span><span class="p">.</span><span class="n">freelist</span><span class="p">;</span>
  <span class="k">while</span><span class="p">(</span><span class="n">r</span><span class="p">){</span>
    <span class="n">mem_bytes</span> <span class="o">+=</span> <span class="n">PGSIZE</span><span class="p">;</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="n">release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kmem</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>

  <span class="k">return</span> <span class="n">mem_bytes</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>xv6 中，空闲内存页的记录方式是，将空虚内存页<strong>本身</strong>直接用作链表节点，形成一个空闲页链表，每次需要分配，就把链表根部对应的页分配出去。每次需要回收，就把这个页作为新的根节点，把原来的 freelist 链表接到后面。注意这里是<strong>直接使用空闲页本身</strong>作为链表节点，所以不需要使用额外空间来存储空闲页链表，在 kalloc() 里也可以看到，分配内存的最后一个阶段，是直接将 freelist 的根节点地址（物理地址）返回出去了：</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre><td class="rouge-code"><pre><span class="c1">// kernel/kalloc.c</span>
<span class="c1">// Allocate one 4096-byte page of physical memory.</span>
<span class="c1">// Returns a pointer that the kernel can use.</span>
<span class="c1">// Returns 0 if the memory cannot be allocated.</span>
<span class="kt">void</span> <span class="o">*</span>
<span class="nf">kalloc</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">struct</span> <span class="n">run</span> <span class="o">*</span><span class="n">r</span><span class="p">;</span>

  <span class="n">acquire</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kmem</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>
  <span class="n">r</span> <span class="o">=</span> <span class="n">kmem</span><span class="p">.</span><span class="n">freelist</span><span class="p">;</span> <span class="c1">// 获得空闲页链表的根节点</span>
  <span class="k">if</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
    <span class="n">kmem</span><span class="p">.</span><span class="n">freelist</span> <span class="o">=</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
  <span class="n">release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kmem</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>

  <span class="k">if</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
    <span class="n">memset</span><span class="p">((</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">r</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="n">PGSIZE</span><span class="p">);</span> <span class="c1">// fill with junk</span>
  <span class="k">return</span> <span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">r</span><span class="p">;</span> <span class="c1">// 把空闲页链表的根节点返回出去，作为内存页使用（长度是 4096）</span>
<span class="p">}</span>
</pre></table></code></div></div><p><strong>常见的记录空闲页的方法有：空闲表法、空闲链表法、位示图法（位图法）、成组链接法</strong>。这里 xv6 采用的是空闲链表法。</p><h2 id="获取运行的进程数"><span class="mr-2">获取运行的进程数</span><a href="#获取运行的进程数" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>同样在内核的头文件中添加函数声明：</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre><span class="c1">// kernel/defs.h</span>
<span class="p">......</span>
<span class="kt">void</span>            <span class="nf">sleep</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">spinlock</span><span class="o">*</span><span class="p">);</span>
<span class="kt">void</span>            <span class="nf">userinit</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="kt">int</span>             <span class="nf">wait</span><span class="p">(</span><span class="n">uint64</span><span class="p">);</span>
<span class="kt">void</span>            <span class="nf">wakeup</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">);</span>
<span class="kt">void</span>            <span class="nf">yield</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="kt">int</span>             <span class="nf">either_copyout</span><span class="p">(</span><span class="kt">int</span> <span class="n">user_dst</span><span class="p">,</span> <span class="n">uint64</span> <span class="n">dst</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">src</span><span class="p">,</span> <span class="n">uint64</span> <span class="n">len</span><span class="p">);</span>
<span class="kt">int</span>             <span class="nf">either_copyin</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">dst</span><span class="p">,</span> <span class="kt">int</span> <span class="n">user_src</span><span class="p">,</span> <span class="n">uint64</span> <span class="n">src</span><span class="p">,</span> <span class="n">uint64</span> <span class="n">len</span><span class="p">);</span>
<span class="kt">void</span>            <span class="nf">procdump</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="n">uint64</span>			<span class="nf">count_process</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span> <span class="c1">// here</span>
</pre></table></code></div></div><p>在 proc.c 中实现该函数：</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre><span class="n">uint64</span>
<span class="nf">count_process</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// added function for counting used process slots (lab2)</span>
  <span class="n">uint64</span> <span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">for</span><span class="p">(</span><span class="k">struct</span> <span class="n">proc</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">proc</span><span class="p">;</span> <span class="n">p</span> <span class="o">&lt;</span> <span class="o">&amp;</span><span class="n">proc</span><span class="p">[</span><span class="n">NPROC</span><span class="p">];</span> <span class="n">p</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// acquire(&amp;p-&gt;lock);</span>
    <span class="c1">// 不需要锁进程 proc 结构，因为我们只需要读取进程列表，不需要写</span>
    <span class="k">if</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">!=</span> <span class="n">UNUSED</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 不是 UNUSED 的进程位，就是已经分配的</span>
        <span class="n">cnt</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="n">cnt</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><h2 id="实现-sysinfo-系统调用"><span class="mr-2">实现 sysinfo 系统调用</span><a href="#实现-sysinfo-系统调用" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>添加系统调用的流程与实验 1 类似，不再赘述。</p><p>这是具体系统信息函数的实现，其中调用了前面实现的 count_free_mem() 和 count_process()：</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre><td class="rouge-code"><pre><span class="n">uint64</span>
<span class="nf">sys_sysinfo</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
  <span class="c1">// 从用户态读入一个指针，作为存放 sysinfo 结构的缓冲区</span>
  <span class="n">uint64</span> <span class="n">addr</span><span class="p">;</span>
  <span class="k">if</span><span class="p">(</span><span class="n">argaddr</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">addr</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
  
  <span class="k">struct</span> <span class="n">sysinfo</span> <span class="n">sinfo</span><span class="p">;</span>
  <span class="n">sinfo</span><span class="p">.</span><span class="n">freemem</span> <span class="o">=</span> <span class="n">count_free_mem</span><span class="p">();</span> <span class="c1">// kalloc.c</span>
  <span class="n">sinfo</span><span class="p">.</span><span class="n">nproc</span> <span class="o">=</span> <span class="n">count_process</span><span class="p">();</span> <span class="c1">// proc.c</span>
  
  <span class="c1">// 使用 copyout，结合当前进程的页表，获得进程传进来的指针（逻辑地址）对应的物理地址</span>
  <span class="c1">// 然后将 &amp;sinfo 中的数据复制到该指针所指位置，供用户进程使用。</span>
  <span class="k">if</span><span class="p">(</span><span class="n">copyout</span><span class="p">(</span><span class="n">myproc</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">pagetable</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">sinfo</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">sinfo</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>在 user.h 提供用户态入口：</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre>// user.h
char* sbrk(int);
int sleep(int);
int uptime(void);
int trace(int);
struct sysinfo; // 这里要声明一下 sysinfo 结构，供用户态使用。
int sysinfo(struct sysinfo *);
</pre></table></code></div></div><p>编译运行：</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre>$ sysinfotest
sysinfotest: start
sysinfotest: OK
</pre></table></code></div></div><h1 id="optional-challenges">Optional challenges</h1><p>Print the system call arguments for traced system calls (easy). （跳过）<br /> Compute the load average and export it through sysinfo(moderate). （跳过）</p></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/course-notes/'>Course Notes</a>, <a href='/categories/mit6-s081/'>MIT6.S081</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/operating-system/" class="post-tag no-text-decoration" >operating system</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=%5Bmit6.s081%5D+%E7%AC%94%E8%AE%B0+Lab2%3A+System+calls+%7C+%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8+-+Miigon%27s+blog&url=https%3A%2F%2Fblog.miigon.net%2Fposts%2Fs081-lab2-system-calls%2F" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=%5Bmit6.s081%5D+%E7%AC%94%E8%AE%B0+Lab2%3A+System+calls+%7C+%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8+-+Miigon%27s+blog&u=https%3A%2F%2Fblog.miigon.net%2Fposts%2Fs081-lab2-system-calls%2F" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://t.me/share/url?url=https%3A%2F%2Fblog.miigon.net%2Fposts%2Fs081-lab2-system-calls%2F&text=%5Bmit6.s081%5D+%E7%AC%94%E8%AE%B0+Lab2%3A+System+calls+%7C+%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8+-+Miigon%27s+blog" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i id="copy-link" class="fa-fw fas fa-link small" data-toggle="tooltip" data-placement="top" title="Copy link" data-title-succeed="Link copied successfully!"> </i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted"><div class="access"><div id="access-lastmod" class="post"><div class="panel-heading">Recently Updated</div><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/storing-hash-objects-on-filesystem/">[随笔]文件系统上存储哈希对象：哈希算法以及目录结构对性能的影响</a><li><a href="/posts/origin-of-git-feat-bitkeeper/">git的前世，和BitKeeper</a><li><a href="/posts/golang-loop-var-reference-problems-and-semantic-fix/">随笔：Golang 循环变量引用问题以及官方语义修复</a><li><a href="/posts/s081-lab6-copy-on-write-fork/">[mit6.s081] 笔记 Lab6: Copy-on-write fork | fork 懒拷贝</a><li><a href="/posts/mysql-prepare-slower-query-bug-analyze/">MySQL Prepare后语句查询性能降低 内核源码bug排查分析</a></ul></div><div id="access-tags"><div class="panel-heading">Trending Tags</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/operating-system/">operating system</a> <a class="post-tag" href="/tags/chinese/">Chinese</a> <a class="post-tag" href="/tags/system-design/">system design</a> <a class="post-tag" href="/tags/c/">C++</a> <a class="post-tag" href="/tags/course-recommendation/">course recommendation</a> <a class="post-tag" href="/tags/grpc/">gRPC</a> <a class="post-tag" href="/tags/translated/">translated</a> <a class="post-tag" href="/tags/announcement/">announcement</a> <a class="post-tag" href="/tags/c-standard/">c++ standard</a> <a class="post-tag" href="/tags/computer-system/">computer system</a></div></div><div id="access-links" class="post"><div class="panel-heading">Links</div><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="http://0xffff.one">0xffff.one 搬砖技术社区</a><li><a href="https://blog.izgq.net">ZGQ's Blog</a></ul></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"><div class="panel-heading pl-3 pt-2 mb-2">Contents</div><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div id="tail-wrapper" class="col-12 col-lg-11 col-xl-9 pl-3 pr-3 pr-xl-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/s081-lab1-unix-utilities/"><div class="card-body"> <em class="small" data-ts="1631005200" data-df="ll" > Sep 7, 2021 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>[mit6.s081] 笔记 Lab1: Unix utilities | Unix 实用工具</h3><div class="text-muted small"><p> 这是我自学 MIT6.S081 操作系统课程的 lab 代码笔记第一篇：Unix utilities。此 lab 大致耗时：4小时。 课程地址：https://pdos.csail.mit.edu/6.S081/2020/schedule.html Lab 地址：https://pdos.csail.mit.edu/6.S081/2020/labs/util.html 我的代码地...</p></div></div></a></div><div class="card"> <a href="/posts/s081-lab3-page-tables/"><div class="card-body"> <em class="small" data-ts="1631790000" data-df="ll" > Sep 16, 2021 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>[mit6.s081] 笔记 Lab3: Page tables | 页表</h3><div class="text-muted small"><p> 这是我自学 MIT6.S081 操作系统课程的 lab 代码笔记第三篇：Page tables。此 lab 大致耗时：19小时。 课程地址：https://pdos.csail.mit.edu/6.S081/2020/schedule.html Lab 地址：https://pdos.csail.mit.edu/6.S081/2020/labs/pgtbl.html 我的代码地址...</p></div></div></a></div><div class="card"> <a href="/posts/s081-lab4-traps/"><div class="card-body"> <em class="small" data-ts="1632283200" data-df="ll" > Sep 22, 2021 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>[mit6.s081] 笔记 Lab4: Traps | 中断陷阱</h3><div class="text-muted small"><p> 这是我自学 MIT6.S081 操作系统课程的 lab 代码笔记第四篇：Traps。此 lab 大致耗时：8小时。 课程地址：https://pdos.csail.mit.edu/6.S081/2020/schedule.html Lab 地址：https://pdos.csail.mit.edu/6.S081/2020/labs/traps.html 我的代码地址：https:...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/s081-lab1-unix-utilities/" class="btn btn-outline-primary" prompt="Older"><p>[mit6.s081] 笔记 Lab1: Unix utilities | Unix 实用工具</p></a> <a href="/posts/s081-lab3-page-tables/" class="btn btn-outline-primary" prompt="Newer"><p>[mit6.s081] 笔记 Lab3: Page tables | 页表</p></a></div><script type="text/javascript"> $(function () { const origin = "https://giscus.app"; const iframe = "iframe.giscus-frame"; const lightTheme = "light"; const darkTheme = "dark_dimmed"; let initTheme = lightTheme; if ($("html[data-mode=dark]").length > 0 || ($("html[data-mode]").length == 0 && window.matchMedia("(prefers-color-scheme: dark)").matches)) { initTheme = darkTheme; } let giscusAttributes = { "src": "https://giscus.app/client.js", "data-repo": "Miigon/blog", "data-repo-id": "MDEwOlJlcG9zaXRvcnkzMjI1MjkwNzA=", "data-category": "BlogComments", "data-category-id": "DIC_kwDOEzlnLs4CQ6Y4", "data-mapping": "pathname", "data-reactions-enabled": "1", "data-emit-metadata": "0", "data-theme": initTheme, "data-input-position": "top", "data-lang": "en", "crossorigin": "anonymous", "async": "" }; let giscusScript = document.createElement("script"); Object.entries(giscusAttributes).forEach(([key, value]) => giscusScript.setAttribute(key, value)); document.getElementById("tail-wrapper").prepend(giscusScript); addEventListener("message", (event) => { if (event.source === window && event.data && event.data.direction === ModeToggle.ID) { /* global theme mode changed */ const mode = event.data.message; const theme = (mode === ModeToggle.DARK_MODE ? darkTheme : lightTheme); const message = { setConfig: { theme: theme } }; const giscus = document.querySelector(iframe).contentWindow; giscus.postMessage({ giscus: message }, origin); } }); }); </script></div></div><footer class="row pl-3 pr-3"><div class="col-12 d-flex justify-content-between align-items-center text-muted pl-0 pr-0"><div class="footer-left"><p class="mb-0"> © 2023 <a href="https://github.com/Miigon">Miigon</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Customized Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><div id="access-tags"><div class="panel-heading">Trending Tags</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/operating-system/">operating system</a> <a class="post-tag" href="/tags/chinese/">Chinese</a> <a class="post-tag" href="/tags/system-design/">system design</a> <a class="post-tag" href="/tags/c/">C++</a> <a class="post-tag" href="/tags/course-recommendation/">course recommendation</a> <a class="post-tag" href="/tags/grpc/">gRPC</a> <a class="post-tag" href="/tags/translated/">translated</a> <a class="post-tag" href="/tags/announcement/">announcement</a> <a class="post-tag" href="/tags/c-standard/">c++ standard</a> <a class="post-tag" href="/tags/computer-system/">computer system</a></div></div></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a><div id="notification" class="toast" role="alert" aria-live="assertive" aria-atomic="true" data-animation="true" data-autohide="false"><div class="toast-header"> <button type="button" class="ml-2 ml-auto close" data-dismiss="toast" aria-label="Close"> <span aria-hidden="true">&times;</span> </button></div><div class="toast-body text-center pt-0"><p class="pl-2 pr-2 mb-3">A new version of content is available.</p><button type="button" class="btn btn-primary" aria-label="Update"> Update </button></div></div><script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No results found.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/magnific-popup@1/dist/jquery.magnific-popup.min.js,npm/lozad/dist/lozad.min.js,npm/clipboard@2/dist/clipboard.min.js"></script> <script src="https://cdn.jsdelivr.net/combine/npm/dayjs@1/dayjs.min.js,npm/dayjs@1/locale/en.min.js,npm/dayjs@1/plugin/relativeTime.min.js,npm/dayjs@1/plugin/localizedFormat.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.bundle.min.js"></script> <script defer src="/app.js"></script>
