<!DOCTYPE html><html lang="en" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="generator" content="Jekyll v4.2.2" /><meta property="og:title" content="[mit6.s081] 笔记 Lab5: Lazy Page Allocation 内存页懒分配" /><meta property="og:locale" content="en" /><meta name="description" content="这是我自学 MIT6.S081 操作系统课程的 lab 代码笔记第五篇：Lazy page allocation。此 lab 大致耗时：5小时。 课程地址：https://pdos.csail.mit.edu/6.S081/2020/schedule.html Lab 地址：https://pdos.csail.mit.edu/6.S081/2020/labs/lazy.html 我的代码地址：https://github.com/Miigon/my-xv6-labs-2020/tree/lazy Commits: https://github.com/Miigon/my-xv6-labs-2020/commits/lazy 本文中代码注释是编写博客的时候加入的，原仓库中的代码可能缺乏注释或代码不完全相同。" /><meta property="og:description" content="这是我自学 MIT6.S081 操作系统课程的 lab 代码笔记第五篇：Lazy page allocation。此 lab 大致耗时：5小时。 课程地址：https://pdos.csail.mit.edu/6.S081/2020/schedule.html Lab 地址：https://pdos.csail.mit.edu/6.S081/2020/labs/lazy.html 我的代码地址：https://github.com/Miigon/my-xv6-labs-2020/tree/lazy Commits: https://github.com/Miigon/my-xv6-labs-2020/commits/lazy 本文中代码注释是编写博客的时候加入的，原仓库中的代码可能缺乏注释或代码不完全相同。" /><link rel="canonical" href="https://blog.miigon.net/posts/s081-lab5-lazy-page-allocation/" /><meta property="og:url" content="https://blog.miigon.net/posts/s081-lab5-lazy-page-allocation/" /><meta property="og:site_name" content="Miigon’s blog" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2021-10-01T06:26:00+08:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="[mit6.s081] 笔记 Lab5: Lazy Page Allocation 内存页懒分配" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2021-10-01T06:33:31+08:00","datePublished":"2021-10-01T06:26:00+08:00","description":"这是我自学 MIT6.S081 操作系统课程的 lab 代码笔记第五篇：Lazy page allocation。此 lab 大致耗时：5小时。 课程地址：https://pdos.csail.mit.edu/6.S081/2020/schedule.html Lab 地址：https://pdos.csail.mit.edu/6.S081/2020/labs/lazy.html 我的代码地址：https://github.com/Miigon/my-xv6-labs-2020/tree/lazy Commits: https://github.com/Miigon/my-xv6-labs-2020/commits/lazy 本文中代码注释是编写博客的时候加入的，原仓库中的代码可能缺乏注释或代码不完全相同。","headline":"[mit6.s081] 笔记 Lab5: Lazy Page Allocation 内存页懒分配","mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.miigon.net/posts/s081-lab5-lazy-page-allocation/"},"url":"https://blog.miigon.net/posts/s081-lab5-lazy-page-allocation/"}</script><title>[mit6.s081] 笔记 Lab5: Lazy Page Allocation | 内存页懒分配 | Miigon's blog</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="Miigon's blog"><meta name="application-name" content="Miigon's blog"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link rel="dns-prefetch" href="https://fonts.gstatic.com" crossorigin><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://cdn.jsdelivr.net" ><link rel="dns-prefetch" href="https://cdn.jsdelivr.net" ><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Lato&family=Source+Sans+Pro:wght@400;600;700;900&display=swap"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get MODE_ATTR() { return "data-mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } static get ID() { return "mode-toggle"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } let self = this; /* always follow the system prefers */ this.sysDarkPrefers.addEventListener("change", () => { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.notify(); }); } /* constructor() */ get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode === ModeToggle.DARK_MODE; } get isLightMode() { return this.mode === ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer)) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } setDark() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_ATTR); sessionStorage.removeItem(ModeToggle.MODE_KEY); } /* Notify another plugins that the theme mode has changed */ notify() { window.postMessage({ direction: ModeToggle.ID, message: this.modeStatus }, "*"); } } /* ModeToggle */ const toggle = new ModeToggle(); function flipMode() { if (toggle.hasMode) { if (toggle.isSysDarkPrefer) { if (toggle.isLightMode) { toggle.clearMode(); } else { toggle.setLight(); } } else { if (toggle.isDarkMode) { toggle.clearMode(); } else { toggle.setDark(); } } } else { if (toggle.isSysDarkPrefer) { toggle.setLight(); } else { toggle.setDark(); } } toggle.notify(); } /* flipMode() */ </script><body data-spy="scroll" data-target="#toc" data-topbar-visible="true"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" class="mx-auto"> <img src="/assets/img/avatar.png" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">Miigon's blog</a></div><div class="site-subtitle font-italic">My ideas, thoughts and experiences</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tag ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info-circle ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center align-items-center"> <button class="mode-toggle btn" aria-label="Switch Mode"> <i class="fas fa-adjust"></i> </button> <span class="icon-border"></span> <a href="https://github.com/Miigon" aria-label="github" target="_blank" rel="noopener"> <i class="fab fa-github-alt"></i> </a> <a href="https://twitter.com/" aria-label="twitter" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['miigon.pg','gmail.com'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="https://stackoverflow.com/users/7509248/miigon" aria-label="stack-overflow" target="_blank" rel="noopener"> <i class="fab fa-stack-overflow"></i> </a></div></div><div id="topbar-wrapper"><div id="topbar" class="container d-flex align-items-center justify-content-between h-100 pl-3 pr-3 pl-md-4 pr-md-4"> <span id="breadcrumb"> <span> <a href="/"> Home </a> </span> <span>[mit6.s081] 笔记 Lab5: Lazy Page Allocation | 内存页懒分配</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..."> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper" class="d-flex justify-content-center"><div id="main" class="container pl-xl-4 pr-xl-4"><div class="row"><div id="core-wrapper" class="col-12 col-lg-11 col-xl-9 pr-xl-4"><div class="post pl-1 pr-1 pl-md-2 pr-md-2"><h1 data-toc-skip>[mit6.s081] 笔记 Lab5: Lazy Page Allocation | 内存页懒分配</h1><div class="post-meta text-muted"> <span> Posted <em class="" data-ts="1633040760" data-df="ll" data-toggle="tooltip" data-placement="bottom"> Oct 1, 2021 </em> </span> <span> Updated <em class="" data-ts="1633041211" data-df="ll" data-toggle="tooltip" data-placement="bottom"> Oct 1, 2021 </em> </span><div class="d-flex justify-content-between"> <span> By <em> <a href="https://github.com/Miigon">Miigon</a> </em> </span><div> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="1896 words"> <em>10 min</em> read</span></div></div></div><div class="post-content"><blockquote><p>这是我自学 MIT6.S081 操作系统课程的 lab 代码笔记第五篇：Lazy page allocation。此 lab 大致耗时：5小时。</p><p>课程地址：<a href="https://pdos.csail.mit.edu/6.S081/2020/schedule.html">https://pdos.csail.mit.edu/6.S081/2020/schedule.html</a><br /> Lab 地址：<a href="https://pdos.csail.mit.edu/6.S081/2020/labs/lazy.html">https://pdos.csail.mit.edu/6.S081/2020/labs/lazy.html</a><br /> 我的代码地址：<a href="https://github.com/Miigon/my-xv6-labs-2020/tree/lazy">https://github.com/Miigon/my-xv6-labs-2020/tree/lazy</a><br /> Commits: <a href="https://github.com/Miigon/my-xv6-labs-2020/commits/lazy">https://github.com/Miigon/my-xv6-labs-2020/commits/lazy</a></p><p>本文中代码注释是编写博客的时候加入的，原仓库中的代码可能缺乏注释或代码不完全相同。</p></blockquote><h1 id="lab-5-lazy-page-allocation">Lab 5: Lazy Page Allocation</h1><blockquote><p>One of the many neat tricks an O/S can play with page table hardware is lazy allocation of user-space heap memory. Xv6 applications ask the kernel for heap memory using the sbrk() system call. In the kernel we’ve given you, sbrk() allocates physical memory and maps it into the process’s virtual address space. It can take a long time for a kernel to allocate and map memory for a large request. Consider, for example, that a gigabyte consists of 262,144 4096-byte pages; that’s a huge number of allocations even if each is individually cheap. In addition, some programs allocate more memory than they actually use (e.g., to implement sparse arrays), or allocate memory well in advance of use. To allow sbrk() to complete more quickly in these cases, sophisticated kernels allocate user memory lazily. That is, sbrk() doesn’t allocate physical memory, but just remembers which user addresses are allocated and marks those addresses as invalid in the user page table. When the process first tries to use any given page of lazily-allocated memory, the CPU generates a page fault, which the kernel handles by allocating physical memory, zeroing it, and mapping it. You’ll add this lazy allocation feature to xv6 in this lab.</p></blockquote><p>实现一个内存页懒分配机制，在调用 sbrk() 的时候，不立即分配内存，而是只作记录。在访问到这一部分内存的时候才进行实际的物理内存分配。</p><p>本次 lab 分为三个部分，但其实都是属于同一个实验的不同步骤，所以本文将三点集合到一起：</p><p>Eliminate allocation from sbrk() (easy) Lazy allocation (moderate) Lazytests and Usertests (moderate)</p><h2 id="lazy-allocation--tests"><span class="mr-2">Lazy allocation &amp; Tests</span><a href="#lazy-allocation--tests" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>首先修改 sys_sbrk，使其不再调用 growproc()，而是只修改 p-&gt;sz 的值而不分配物理内存。</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre><td class="rouge-code"><pre><span class="c1">// kernel/sysproc.c</span>
<span class="n">uint64</span>
<span class="nf">sys_sbrk</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">addr</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">n</span><span class="p">;</span>
  <span class="k">struct</span> <span class="n">proc</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">myproc</span><span class="p">();</span>
  <span class="k">if</span><span class="p">(</span><span class="n">argint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">n</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
  <span class="n">addr</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">sz</span><span class="p">;</span>
  <span class="k">if</span><span class="p">(</span><span class="n">n</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">uvmdealloc</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">pagetable</span><span class="p">,</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">sz</span><span class="p">,</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">sz</span><span class="o">+</span><span class="n">n</span><span class="p">);</span> <span class="c1">// 如果是缩小空间，则马上释放</span>
  <span class="p">}</span>
  <span class="n">p</span><span class="o">-&gt;</span><span class="n">sz</span> <span class="o">+=</span> <span class="n">n</span><span class="p">;</span> <span class="c1">// 懒分配</span>
  <span class="k">return</span> <span class="n">addr</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>修改 usertrap 用户态 trap 处理函数，为缺页异常添加检测，如果为缺页异常（<code class="language-plaintext highlighter-rouge">(r_scause() == 13 || r_scause() == 15)</code>），且发生异常的地址是由于懒分配而没有映射的话，就为其分配物理内存，并在页表建立映射：</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
</pre><td class="rouge-code"><pre><span class="c1">// kernel/trap.c</span>

<span class="c1">//</span>
<span class="c1">// handle an interrupt, exception, or system call from user space.</span>
<span class="c1">// called from trampoline.S</span>
<span class="c1">//</span>
<span class="kt">void</span>
<span class="nf">usertrap</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
  <span class="c1">// ......</span>

    <span class="n">syscall</span><span class="p">();</span>
  <span class="p">}</span> <span class="k">else</span> <span class="nf">if</span><span class="p">((</span><span class="n">which_dev</span> <span class="o">=</span> <span class="n">devintr</span><span class="p">())</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">){</span>
    <span class="c1">// ok</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="n">uint64</span> <span class="n">va</span> <span class="o">=</span> <span class="n">r_stval</span><span class="p">();</span>
    <span class="k">if</span><span class="p">((</span><span class="n">r_scause</span><span class="p">()</span> <span class="o">==</span> <span class="mi">13</span> <span class="o">||</span> <span class="n">r_scause</span><span class="p">()</span> <span class="o">==</span> <span class="mi">15</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">uvmshouldtouch</span><span class="p">(</span><span class="n">va</span><span class="p">)){</span> <span class="c1">// 缺页异常，并且发生异常的地址进行过懒分配</span>
      <span class="n">uvmlazytouch</span><span class="p">(</span><span class="n">va</span><span class="p">);</span> <span class="c1">// 分配物理内存，并在页表创建映射</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span> <span class="c1">// 如果不是缺页异常，或者是在非懒加载地址上发生缺页异常，则抛出错误并杀死进程</span>
      <span class="n">printf</span><span class="p">(</span><span class="s">"usertrap(): unexpected scause %p pid=%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">r_scause</span><span class="p">(),</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">);</span>
      <span class="n">printf</span><span class="p">(</span><span class="s">"            sepc=%p stval=%p</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">r_sepc</span><span class="p">(),</span> <span class="n">r_stval</span><span class="p">());</span>
      <span class="n">p</span><span class="o">-&gt;</span><span class="n">killed</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="c1">// ......</span>

<span class="err">}</span>
</pre></table></code></div></div><p>uvmlazytouch 函数负责分配实际的物理内存并建立映射。懒分配的内存页在被 touch 后就可以被使用了。<br /> uvmshouldtouch 用于检测一个虚拟地址是不是一个需要被 touch 的懒分配内存地址，具体检测的是：</p><ol><li>处于 <code class="language-plaintext highlighter-rouge">[0, p-&gt;sz)</code>地址范围之中（进程申请的内存范围）<li>不是栈的 guard page（具体见 xv6 book，栈页的低一页故意留成不映射，作为哨兵用于捕捉 stack overflow 错误。懒分配不应该给这个地址分配物理页和建立映射，而应该直接抛出异常）<br /> （解决 usertests 中的 stacktest 失败的问题）<li>页表项不存在</ol><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
</pre><td class="rouge-code"><pre><span class="c1">// kernel/vm.c</span>

<span class="c1">// touch a lazy-allocated page so it's mapped to an actual physical page.</span>
<span class="kt">void</span> <span class="nf">uvmlazytouch</span><span class="p">(</span><span class="n">uint64</span> <span class="n">va</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">struct</span> <span class="n">proc</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">myproc</span><span class="p">();</span>
  <span class="kt">char</span> <span class="o">*</span><span class="n">mem</span> <span class="o">=</span> <span class="n">kalloc</span><span class="p">();</span>
  <span class="k">if</span><span class="p">(</span><span class="n">mem</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// failed to allocate physical memory</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"lazy alloc: out of memory</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="n">p</span><span class="o">-&gt;</span><span class="n">killed</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="n">memset</span><span class="p">(</span><span class="n">mem</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">PGSIZE</span><span class="p">);</span>
    <span class="k">if</span><span class="p">(</span><span class="n">mappages</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">pagetable</span><span class="p">,</span> <span class="n">PGROUNDDOWN</span><span class="p">(</span><span class="n">va</span><span class="p">),</span> <span class="n">PGSIZE</span><span class="p">,</span> <span class="p">(</span><span class="n">uint64</span><span class="p">)</span><span class="n">mem</span><span class="p">,</span> <span class="n">PTE_W</span><span class="o">|</span><span class="n">PTE_X</span><span class="o">|</span><span class="n">PTE_R</span><span class="o">|</span><span class="n">PTE_U</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">){</span>
      <span class="n">printf</span><span class="p">(</span><span class="s">"lazy alloc: failed to map page</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
      <span class="n">kfree</span><span class="p">(</span><span class="n">mem</span><span class="p">);</span>
      <span class="n">p</span><span class="o">-&gt;</span><span class="n">killed</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="c1">// printf("lazy alloc: %p, p-&gt;sz: %p\n", PGROUNDDOWN(va), p-&gt;sz);</span>
<span class="p">}</span>

<span class="c1">// whether a page is previously lazy-allocated and needed to be touched before use.</span>
<span class="kt">int</span> <span class="nf">uvmshouldtouch</span><span class="p">(</span><span class="n">uint64</span> <span class="n">va</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">pte_t</span> <span class="o">*</span><span class="n">pte</span><span class="p">;</span>
  <span class="k">struct</span> <span class="n">proc</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">myproc</span><span class="p">();</span>
  
  <span class="k">return</span> <span class="n">va</span> <span class="o">&lt;</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">sz</span> <span class="c1">// within size of memory for the process</span>
    <span class="o">&amp;&amp;</span> <span class="n">PGROUNDDOWN</span><span class="p">(</span><span class="n">va</span><span class="p">)</span> <span class="o">!=</span> <span class="n">r_sp</span><span class="p">()</span> <span class="c1">// not accessing stack guard page (it shouldn't be mapped)</span>
    <span class="o">&amp;&amp;</span> <span class="p">(((</span><span class="n">pte</span> <span class="o">=</span> <span class="n">walk</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">pagetable</span><span class="p">,</span> <span class="n">va</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span><span class="o">==</span><span class="mi">0</span><span class="p">)</span> <span class="o">||</span> <span class="p">((</span><span class="o">*</span><span class="n">pte</span> <span class="o">&amp;</span> <span class="n">PTE_V</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span><span class="p">));</span> <span class="c1">// page table entry does not exist</span>
<span class="p">}</span>

</pre></table></code></div></div><p>由于懒分配的页，在刚分配的时候是没有对应的映射的，所以要把一些原本在遇到无映射地址时会 panic 的函数的行为改为直接忽略这样的地址。</p><p>uvmummap()：取消虚拟地址映射</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
</pre><td class="rouge-code"><pre><span class="c1">// kernel/vm.c</span>
<span class="c1">// 修改这个解决了 proc_freepagetable 时的 panic</span>
<span class="kt">void</span>
<span class="nf">uvmunmap</span><span class="p">(</span><span class="n">pagetable_t</span> <span class="n">pagetable</span><span class="p">,</span> <span class="n">uint64</span> <span class="n">va</span><span class="p">,</span> <span class="n">uint64</span> <span class="n">npages</span><span class="p">,</span> <span class="kt">int</span> <span class="n">do_free</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">uint64</span> <span class="n">a</span><span class="p">;</span>
  <span class="n">pte_t</span> <span class="o">*</span><span class="n">pte</span><span class="p">;</span>

  <span class="k">if</span><span class="p">((</span><span class="n">va</span> <span class="o">%</span> <span class="n">PGSIZE</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">panic</span><span class="p">(</span><span class="s">"uvmunmap: not aligned"</span><span class="p">);</span>

  <span class="k">for</span><span class="p">(</span><span class="n">a</span> <span class="o">=</span> <span class="n">va</span><span class="p">;</span> <span class="n">a</span> <span class="o">&lt;</span> <span class="n">va</span> <span class="o">+</span> <span class="n">npages</span><span class="o">*</span><span class="n">PGSIZE</span><span class="p">;</span> <span class="n">a</span> <span class="o">+=</span> <span class="n">PGSIZE</span><span class="p">){</span>
    <span class="k">if</span><span class="p">((</span><span class="n">pte</span> <span class="o">=</span> <span class="n">walk</span><span class="p">(</span><span class="n">pagetable</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">continue</span><span class="p">;</span> <span class="c1">// 如果页表项不存在，跳过当前地址 （原本是直接panic）</span>
    <span class="p">}</span>
    <span class="k">if</span><span class="p">((</span><span class="o">*</span><span class="n">pte</span> <span class="o">&amp;</span> <span class="n">PTE_V</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">){</span>
      <span class="k">continue</span><span class="p">;</span> <span class="c1">// 如果页表项不存在，跳过当前地址 （原本是直接panic）</span>
    <span class="p">}</span>
    <span class="k">if</span><span class="p">(</span><span class="n">PTE_FLAGS</span><span class="p">(</span><span class="o">*</span><span class="n">pte</span><span class="p">)</span> <span class="o">==</span> <span class="n">PTE_V</span><span class="p">)</span>
      <span class="n">panic</span><span class="p">(</span><span class="s">"uvmunmap: not a leaf"</span><span class="p">);</span>
    <span class="k">if</span><span class="p">(</span><span class="n">do_free</span><span class="p">){</span>
      <span class="n">uint64</span> <span class="n">pa</span> <span class="o">=</span> <span class="n">PTE2PA</span><span class="p">(</span><span class="o">*</span><span class="n">pte</span><span class="p">);</span>
      <span class="n">kfree</span><span class="p">((</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">pa</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="o">*</span><span class="n">pte</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>

</pre></table></code></div></div><p>uvmcopy()：将父进程的页表以及内存拷贝到子进程</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
</pre><td class="rouge-code"><pre><span class="c1">// kernel/vm.c</span>
<span class="c1">// 修改这个解决了 fork 时的 panic</span>
<span class="kt">int</span>
<span class="nf">uvmcopy</span><span class="p">(</span><span class="n">pagetable_t</span> <span class="n">old</span><span class="p">,</span> <span class="n">pagetable_t</span> <span class="n">new</span><span class="p">,</span> <span class="n">uint64</span> <span class="n">sz</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">pte_t</span> <span class="o">*</span><span class="n">pte</span><span class="p">;</span>
  <span class="n">uint64</span> <span class="n">pa</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>
  <span class="n">uint</span> <span class="n">flags</span><span class="p">;</span>
  <span class="kt">char</span> <span class="o">*</span><span class="n">mem</span><span class="p">;</span>

  <span class="k">for</span><span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">sz</span><span class="p">;</span> <span class="n">i</span> <span class="o">+=</span> <span class="n">PGSIZE</span><span class="p">){</span>
    <span class="k">if</span><span class="p">((</span><span class="n">pte</span> <span class="o">=</span> <span class="n">walk</span><span class="p">(</span><span class="n">old</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
      <span class="k">continue</span><span class="p">;</span> <span class="c1">// 如果一个页不存在，则认为是懒加载的页，忽略即可</span>
    <span class="k">if</span><span class="p">((</span><span class="o">*</span><span class="n">pte</span> <span class="o">&amp;</span> <span class="n">PTE_V</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
      <span class="k">continue</span><span class="p">;</span> <span class="c1">// 如果一个页不存在，则认为是懒加载的页，忽略即可</span>
    <span class="n">pa</span> <span class="o">=</span> <span class="n">PTE2PA</span><span class="p">(</span><span class="o">*</span><span class="n">pte</span><span class="p">);</span>
    <span class="n">flags</span> <span class="o">=</span> <span class="n">PTE_FLAGS</span><span class="p">(</span><span class="o">*</span><span class="n">pte</span><span class="p">);</span>
    <span class="k">if</span><span class="p">((</span><span class="n">mem</span> <span class="o">=</span> <span class="n">kalloc</span><span class="p">())</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
      <span class="k">goto</span> <span class="n">err</span><span class="p">;</span>
    <span class="n">memmove</span><span class="p">(</span><span class="n">mem</span><span class="p">,</span> <span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">pa</span><span class="p">,</span> <span class="n">PGSIZE</span><span class="p">);</span>
    <span class="k">if</span><span class="p">(</span><span class="n">mappages</span><span class="p">(</span><span class="n">new</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">PGSIZE</span><span class="p">,</span> <span class="p">(</span><span class="n">uint64</span><span class="p">)</span><span class="n">mem</span><span class="p">,</span> <span class="n">flags</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">){</span>
      <span class="n">kfree</span><span class="p">(</span><span class="n">mem</span><span class="p">);</span>
      <span class="k">goto</span> <span class="n">err</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

 <span class="nl">err:</span>
  <span class="n">uvmunmap</span><span class="p">(</span><span class="n">new</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">i</span> <span class="o">/</span> <span class="n">PGSIZE</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
  <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>copyin() 和 copyout()：内核/用户态之间互相拷贝数据</p><p>由于这里可能会访问到懒分配但是还没实际分配的页，所以要加一个检测，确保 copy 之前，用户态地址对应的页都有被实际分配和映射。</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
</pre><td class="rouge-code"><pre><span class="c1">// kernel/vm.c</span>
<span class="c1">// 修改这个解决了 read/write 时的错误 (usertests 中的 sbrkarg 失败的问题)</span>
<span class="kt">int</span>
<span class="nf">copyout</span><span class="p">(</span><span class="n">pagetable_t</span> <span class="n">pagetable</span><span class="p">,</span> <span class="n">uint64</span> <span class="n">dstva</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">src</span><span class="p">,</span> <span class="n">uint64</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">uint64</span> <span class="n">n</span><span class="p">,</span> <span class="n">va0</span><span class="p">,</span> <span class="n">pa0</span><span class="p">;</span>

  <span class="k">if</span><span class="p">(</span><span class="n">uvmshouldtouch</span><span class="p">(</span><span class="n">dstva</span><span class="p">))</span>
    <span class="n">uvmlazytouch</span><span class="p">(</span><span class="n">dstva</span><span class="p">);</span>

  <span class="c1">// ......</span>

<span class="p">}</span>

<span class="kt">int</span>
<span class="nf">copyin</span><span class="p">(</span><span class="n">pagetable_t</span> <span class="n">pagetable</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">dst</span><span class="p">,</span> <span class="n">uint64</span> <span class="n">srcva</span><span class="p">,</span> <span class="n">uint64</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">uint64</span> <span class="n">n</span><span class="p">,</span> <span class="n">va0</span><span class="p">,</span> <span class="n">pa0</span><span class="p">;</span>

  <span class="k">if</span><span class="p">(</span><span class="n">uvmshouldtouch</span><span class="p">(</span><span class="n">srcva</span><span class="p">))</span>
    <span class="n">uvmlazytouch</span><span class="p">(</span><span class="n">srcva</span><span class="p">);</span>

  <span class="c1">// ......</span>

<span class="p">}</span>
</pre></table></code></div></div><p>至此修改完成，在 xv6 中运行 lazytests 和 usertests 都应该能够成功了。<br /> 如果在某一步出现了 remap 或者 leaf 之类的 panic，可能是由于页表项没有释放干净。可以从之前 pgtbl 实验中借用打印页表的函数 vmprint 的代码，并在可能有关的系统调用中打出，方便对页表进行调试。</p><blockquote><p>tip. 如果 usertests 某一步失败了，可以用 <code class="language-plaintext highlighter-rouge">usertests [测试名称]</code> 直接单独运行某个之前失败过的测试，例如 <code class="language-plaintext highlighter-rouge">usertests stacktest</code> 可以直接运行栈 guard page 的测试，而不用等待其他测试漫长的运行。</p></blockquote></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/course-notes/'>Course Notes</a>, <a href='/categories/mit6-s081/'>MIT6.S081</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/operating-system/" class="post-tag no-text-decoration" >operating system</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=%5Bmit6.s081%5D+%E7%AC%94%E8%AE%B0+Lab5%3A+Lazy+Page+Allocation+%7C+%E5%86%85%E5%AD%98%E9%A1%B5%E6%87%92%E5%88%86%E9%85%8D+-+Miigon%27s+blog&url=https%3A%2F%2Fblog.miigon.net%2Fposts%2Fs081-lab5-lazy-page-allocation%2F" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=%5Bmit6.s081%5D+%E7%AC%94%E8%AE%B0+Lab5%3A+Lazy+Page+Allocation+%7C+%E5%86%85%E5%AD%98%E9%A1%B5%E6%87%92%E5%88%86%E9%85%8D+-+Miigon%27s+blog&u=https%3A%2F%2Fblog.miigon.net%2Fposts%2Fs081-lab5-lazy-page-allocation%2F" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://t.me/share/url?url=https%3A%2F%2Fblog.miigon.net%2Fposts%2Fs081-lab5-lazy-page-allocation%2F&text=%5Bmit6.s081%5D+%E7%AC%94%E8%AE%B0+Lab5%3A+Lazy+Page+Allocation+%7C+%E5%86%85%E5%AD%98%E9%A1%B5%E6%87%92%E5%88%86%E9%85%8D+-+Miigon%27s+blog" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i id="copy-link" class="fa-fw fas fa-link small" data-toggle="tooltip" data-placement="top" title="Copy link" data-title-succeed="Link copied successfully!"> </i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted"><div class="access"><div id="access-lastmod" class="post"><div class="panel-heading">Recently Updated</div><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/storing-hash-objects-on-filesystem/">[随笔]文件系统上存储哈希对象：哈希算法以及目录结构对性能的影响</a><li><a href="/posts/origin-of-git-feat-bitkeeper/">git的前世，和BitKeeper</a><li><a href="/posts/golang-loop-var-reference-problems-and-semantic-fix/">随笔：Golang 循环变量引用问题以及官方语义修复</a><li><a href="/posts/s081-lab6-copy-on-write-fork/">[mit6.s081] 笔记 Lab6: Copy-on-write fork | fork 懒拷贝</a><li><a href="/posts/mysql-prepare-slower-query-bug-analyze/">MySQL Prepare后语句查询性能降低 内核源码bug排查分析</a></ul></div><div id="access-tags"><div class="panel-heading">Trending Tags</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/operating-system/">operating system</a> <a class="post-tag" href="/tags/chinese/">Chinese</a> <a class="post-tag" href="/tags/system-design/">system design</a> <a class="post-tag" href="/tags/c/">C++</a> <a class="post-tag" href="/tags/course-recommendation/">course recommendation</a> <a class="post-tag" href="/tags/grpc/">gRPC</a> <a class="post-tag" href="/tags/translated/">translated</a> <a class="post-tag" href="/tags/announcement/">announcement</a> <a class="post-tag" href="/tags/c-standard/">c++ standard</a> <a class="post-tag" href="/tags/computer-system/">computer system</a></div></div><div id="access-links" class="post"><div class="panel-heading">Links</div><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="http://0xffff.one">0xffff.one 搬砖技术社区</a><li><a href="https://blog.izgq.net">ZGQ's Blog</a></ul></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"><div class="panel-heading pl-3 pt-2 mb-2">Contents</div><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div id="tail-wrapper" class="col-12 col-lg-11 col-xl-9 pl-3 pr-3 pr-xl-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/s081-lab1-unix-utilities/"><div class="card-body"> <em class="small" data-ts="1631005200" data-df="ll" > Sep 7, 2021 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>[mit6.s081] 笔记 Lab1: Unix utilities | Unix 实用工具</h3><div class="text-muted small"><p> 这是我自学 MIT6.S081 操作系统课程的 lab 代码笔记第一篇：Unix utilities。此 lab 大致耗时：4小时。 课程地址：https://pdos.csail.mit.edu/6.S081/2020/schedule.html Lab 地址：https://pdos.csail.mit.edu/6.S081/2020/labs/util.html 我的代码地...</p></div></div></a></div><div class="card"> <a href="/posts/s081-lab2-system-calls/"><div class="card-body"> <em class="small" data-ts="1631185200" data-df="ll" > Sep 9, 2021 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>[mit6.s081] 笔记 Lab2: System calls | 系统调用</h3><div class="text-muted small"><p> 这是我自学 MIT6.S081 操作系统课程的 lab 代码笔记第二篇：System calls。此 lab 大致耗时：4小时。 课程地址：https://pdos.csail.mit.edu/6.S081/2020/schedule.html Lab 地址：https://pdos.csail.mit.edu/6.S081/2020/labs/syscall.html 我的代码...</p></div></div></a></div><div class="card"> <a href="/posts/s081-lab3-page-tables/"><div class="card-body"> <em class="small" data-ts="1631790000" data-df="ll" > Sep 16, 2021 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>[mit6.s081] 笔记 Lab3: Page tables | 页表</h3><div class="text-muted small"><p> 这是我自学 MIT6.S081 操作系统课程的 lab 代码笔记第三篇：Page tables。此 lab 大致耗时：19小时。 课程地址：https://pdos.csail.mit.edu/6.S081/2020/schedule.html Lab 地址：https://pdos.csail.mit.edu/6.S081/2020/labs/pgtbl.html 我的代码地址...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/s081-lab4-traps/" class="btn btn-outline-primary" prompt="Older"><p>[mit6.s081] 笔记 Lab4: Traps | 中断陷阱</p></a> <a href="/posts/s081-lab6-copy-on-write-fork/" class="btn btn-outline-primary" prompt="Newer"><p>[mit6.s081] 笔记 Lab6: Copy-on-write fork | fork 懒拷贝</p></a></div><script type="text/javascript"> $(function () { const origin = "https://giscus.app"; const iframe = "iframe.giscus-frame"; const lightTheme = "light"; const darkTheme = "dark_dimmed"; let initTheme = lightTheme; if ($("html[data-mode=dark]").length > 0 || ($("html[data-mode]").length == 0 && window.matchMedia("(prefers-color-scheme: dark)").matches)) { initTheme = darkTheme; } let giscusAttributes = { "src": "https://giscus.app/client.js", "data-repo": "Miigon/blog", "data-repo-id": "MDEwOlJlcG9zaXRvcnkzMjI1MjkwNzA=", "data-category": "BlogComments", "data-category-id": "DIC_kwDOEzlnLs4CQ6Y4", "data-mapping": "pathname", "data-reactions-enabled": "1", "data-emit-metadata": "0", "data-theme": initTheme, "data-input-position": "top", "data-lang": "en", "crossorigin": "anonymous", "async": "" }; let giscusScript = document.createElement("script"); Object.entries(giscusAttributes).forEach(([key, value]) => giscusScript.setAttribute(key, value)); document.getElementById("tail-wrapper").prepend(giscusScript); addEventListener("message", (event) => { if (event.source === window && event.data && event.data.direction === ModeToggle.ID) { /* global theme mode changed */ const mode = event.data.message; const theme = (mode === ModeToggle.DARK_MODE ? darkTheme : lightTheme); const message = { setConfig: { theme: theme } }; const giscus = document.querySelector(iframe).contentWindow; giscus.postMessage({ giscus: message }, origin); } }); }); </script></div></div><footer class="row pl-3 pr-3"><div class="col-12 d-flex justify-content-between align-items-center text-muted pl-0 pr-0"><div class="footer-left"><p class="mb-0"> © 2023 <a href="https://github.com/Miigon">Miigon</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Customized Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><div id="access-tags"><div class="panel-heading">Trending Tags</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/operating-system/">operating system</a> <a class="post-tag" href="/tags/chinese/">Chinese</a> <a class="post-tag" href="/tags/system-design/">system design</a> <a class="post-tag" href="/tags/c/">C++</a> <a class="post-tag" href="/tags/course-recommendation/">course recommendation</a> <a class="post-tag" href="/tags/grpc/">gRPC</a> <a class="post-tag" href="/tags/translated/">translated</a> <a class="post-tag" href="/tags/announcement/">announcement</a> <a class="post-tag" href="/tags/c-standard/">c++ standard</a> <a class="post-tag" href="/tags/computer-system/">computer system</a></div></div></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a><div id="notification" class="toast" role="alert" aria-live="assertive" aria-atomic="true" data-animation="true" data-autohide="false"><div class="toast-header"> <button type="button" class="ml-2 ml-auto close" data-dismiss="toast" aria-label="Close"> <span aria-hidden="true">&times;</span> </button></div><div class="toast-body text-center pt-0"><p class="pl-2 pr-2 mb-3">A new version of content is available.</p><button type="button" class="btn btn-primary" aria-label="Update"> Update </button></div></div><script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No results found.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/magnific-popup@1/dist/jquery.magnific-popup.min.js,npm/lozad/dist/lozad.min.js,npm/clipboard@2/dist/clipboard.min.js"></script> <script src="https://cdn.jsdelivr.net/combine/npm/dayjs@1/dayjs.min.js,npm/dayjs@1/locale/en.min.js,npm/dayjs@1/plugin/relativeTime.min.js,npm/dayjs@1/plugin/localizedFormat.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.bundle.min.js"></script> <script defer src="/app.js"></script>
