<!DOCTYPE html><html lang="en" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="generator" content="Jekyll v4.2.2" /><meta property="og:title" content="[mit6.s081] 笔记 Lab8: Locks 锁优化" /><meta property="og:locale" content="en" /><meta name="description" content="这是我自学 MIT6.S081 操作系统课程的 lab 代码笔记第八篇：Locks。此 lab 大致耗时：14小时。 课程地址：https://pdos.csail.mit.edu/6.S081/2020/schedule.html Lab 地址：https://pdos.csail.mit.edu/6.S081/2020/labs/lock.html 我的代码地址：https://github.com/Miigon/my-xv6-labs-2020/tree/lock Commits: https://github.com/Miigon/my-xv6-labs-2020/commits/lock 本文中代码注释是编写博客的时候加入的，原仓库中的代码可能缺乏注释或代码不完全相同。" /><meta property="og:description" content="这是我自学 MIT6.S081 操作系统课程的 lab 代码笔记第八篇：Locks。此 lab 大致耗时：14小时。 课程地址：https://pdos.csail.mit.edu/6.S081/2020/schedule.html Lab 地址：https://pdos.csail.mit.edu/6.S081/2020/labs/lock.html 我的代码地址：https://github.com/Miigon/my-xv6-labs-2020/tree/lock Commits: https://github.com/Miigon/my-xv6-labs-2020/commits/lock 本文中代码注释是编写博客的时候加入的，原仓库中的代码可能缺乏注释或代码不完全相同。" /><link rel="canonical" href="https://blog.miigon.net/posts/s081-lab8-locks/" /><meta property="og:url" content="https://blog.miigon.net/posts/s081-lab8-locks/" /><meta property="og:site_name" content="Miigon’s blog" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2021-10-15T22:48:00+08:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="[mit6.s081] 笔记 Lab8: Locks 锁优化" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2022-04-14T23:02:24+08:00","datePublished":"2021-10-15T22:48:00+08:00","description":"这是我自学 MIT6.S081 操作系统课程的 lab 代码笔记第八篇：Locks。此 lab 大致耗时：14小时。 课程地址：https://pdos.csail.mit.edu/6.S081/2020/schedule.html Lab 地址：https://pdos.csail.mit.edu/6.S081/2020/labs/lock.html 我的代码地址：https://github.com/Miigon/my-xv6-labs-2020/tree/lock Commits: https://github.com/Miigon/my-xv6-labs-2020/commits/lock 本文中代码注释是编写博客的时候加入的，原仓库中的代码可能缺乏注释或代码不完全相同。","headline":"[mit6.s081] 笔记 Lab8: Locks 锁优化","mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.miigon.net/posts/s081-lab8-locks/"},"url":"https://blog.miigon.net/posts/s081-lab8-locks/"}</script><title>[mit6.s081] 笔记 Lab8: Locks | 锁优化 | Miigon's blog</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="Miigon's blog"><meta name="application-name" content="Miigon's blog"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link rel="dns-prefetch" href="https://fonts.gstatic.com" crossorigin><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://cdn.jsdelivr.net" ><link rel="dns-prefetch" href="https://cdn.jsdelivr.net" ><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Lato&family=Source+Sans+Pro:wght@400;600;700;900&display=swap"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get MODE_ATTR() { return "data-mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } static get ID() { return "mode-toggle"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } let self = this; /* always follow the system prefers */ this.sysDarkPrefers.addEventListener("change", () => { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.notify(); }); } /* constructor() */ get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode === ModeToggle.DARK_MODE; } get isLightMode() { return this.mode === ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer)) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } setDark() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_ATTR); sessionStorage.removeItem(ModeToggle.MODE_KEY); } /* Notify another plugins that the theme mode has changed */ notify() { window.postMessage({ direction: ModeToggle.ID, message: this.modeStatus }, "*"); } } /* ModeToggle */ const toggle = new ModeToggle(); function flipMode() { if (toggle.hasMode) { if (toggle.isSysDarkPrefer) { if (toggle.isLightMode) { toggle.clearMode(); } else { toggle.setLight(); } } else { if (toggle.isDarkMode) { toggle.clearMode(); } else { toggle.setDark(); } } } else { if (toggle.isSysDarkPrefer) { toggle.setLight(); } else { toggle.setDark(); } } toggle.notify(); } /* flipMode() */ </script><body data-spy="scroll" data-target="#toc" data-topbar-visible="true"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" class="mx-auto"> <img src="/assets/img/avatar.png" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">Miigon's blog</a></div><div class="site-subtitle font-italic">My ideas, thoughts and experiences</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tag ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info-circle ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center align-items-center"> <button class="mode-toggle btn" aria-label="Switch Mode"> <i class="fas fa-adjust"></i> </button> <span class="icon-border"></span> <a href="https://github.com/Miigon" aria-label="github" target="_blank" rel="noopener"> <i class="fab fa-github-alt"></i> </a> <a href="https://twitter.com/" aria-label="twitter" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['miigon.pg','gmail.com'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="https://stackoverflow.com/users/7509248/miigon" aria-label="stack-overflow" target="_blank" rel="noopener"> <i class="fab fa-stack-overflow"></i> </a></div></div><div id="topbar-wrapper"><div id="topbar" class="container d-flex align-items-center justify-content-between h-100 pl-3 pr-3 pl-md-4 pr-md-4"> <span id="breadcrumb"> <span> <a href="/"> Home </a> </span> <span>[mit6.s081] 笔记 Lab8: Locks | 锁优化</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..."> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper" class="d-flex justify-content-center"><div id="main" class="container pl-xl-4 pr-xl-4"><div class="row"><div id="core-wrapper" class="col-12 col-lg-11 col-xl-9 pr-xl-4"><div class="post pl-1 pr-1 pl-md-2 pr-md-2"><h1 data-toc-skip>[mit6.s081] 笔记 Lab8: Locks | 锁优化</h1><div class="post-meta text-muted"> <span> Posted <em class="" data-ts="1634309280" data-df="ll" data-toggle="tooltip" data-placement="bottom"> Oct 15, 2021 </em> </span> <span> Updated <em class="" data-ts="1649948544" data-df="ll" data-toggle="tooltip" data-placement="bottom"> Apr 14, 2022 </em> </span><div class="d-flex justify-content-between"> <span> By <em> <a href="https://github.com/Miigon">Miigon</a> </em> </span><div> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="8963 words"> <em>49 min</em> read</span></div></div></div><div class="post-content"><blockquote><p>这是我自学 MIT6.S081 操作系统课程的 lab 代码笔记第八篇：Locks。此 lab 大致耗时：14小时。</p><p>课程地址：<a href="https://pdos.csail.mit.edu/6.S081/2020/schedule.html">https://pdos.csail.mit.edu/6.S081/2020/schedule.html</a><br /> Lab 地址：<a href="https://pdos.csail.mit.edu/6.S081/2020/labs/lock.html">https://pdos.csail.mit.edu/6.S081/2020/labs/lock.html</a><br /> 我的代码地址：<a href="https://github.com/Miigon/my-xv6-labs-2020/tree/lock">https://github.com/Miigon/my-xv6-labs-2020/tree/lock</a><br /> Commits: <a href="https://github.com/Miigon/my-xv6-labs-2020/commits/lock">https://github.com/Miigon/my-xv6-labs-2020/commits/lock</a></p><p>本文中代码注释是编写博客的时候加入的，原仓库中的代码可能缺乏注释或代码不完全相同。</p></blockquote><h1 id="lab-8-locks">Lab 8: Locks</h1><p>重新设计代码以降低锁竞争，提高多核机器上系统的并行性。</p><h2 id="memory-allocator-moderate"><span class="mr-2">Memory allocator (moderate)</span><a href="#memory-allocator-moderate" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>通过拆分 kmem 中的空闲内存链表，降低 kalloc 实现中的 kmem 锁竞争。</p><h3 id="原理与分析"><span class="mr-2">原理与分析</span><a href="#原理与分析" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>kalloc 原本的实现中，使用 freelist 链表，将空闲物理页<strong>本身</strong>直接用作链表项（这样可以不使用额外空间）连接成一个链表，在分配的时候，将物理页从链表中移除，回收时将物理页放回链表中。</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="c1">// kernel/kalloc.c</span>
<span class="k">struct</span> <span class="p">{</span>
  <span class="k">struct</span> <span class="n">spinlock</span> <span class="n">lock</span><span class="p">;</span>
  <span class="k">struct</span> <span class="n">run</span> <span class="o">*</span><span class="n">freelist</span><span class="p">;</span>
<span class="p">}</span> <span class="n">kmem</span><span class="p">;</span>
</pre></table></code></div></div><p>分配物理页的实现（原版）：</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre><td class="rouge-code"><pre><span class="c1">// kernel/kalloc.c</span>
<span class="kt">void</span> <span class="o">*</span>
<span class="nf">kalloc</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">struct</span> <span class="n">run</span> <span class="o">*</span><span class="n">r</span><span class="p">;</span>

  <span class="n">acquire</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kmem</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>
  <span class="n">r</span> <span class="o">=</span> <span class="n">kmem</span><span class="p">.</span><span class="n">freelist</span><span class="p">;</span> <span class="c1">// 取出一个物理页。页表项本身就是物理页。</span>
  <span class="k">if</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
    <span class="n">kmem</span><span class="p">.</span><span class="n">freelist</span> <span class="o">=</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
  <span class="n">release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kmem</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>

  <span class="k">if</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
    <span class="n">memset</span><span class="p">((</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">r</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="n">PGSIZE</span><span class="p">);</span> <span class="c1">// fill with junk</span>
  <span class="k">return</span> <span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">r</span><span class="p">;</span>
<span class="p">}</span>

</pre></table></code></div></div><p>在这里无论是分配物理页或释放物理页，都需要修改 freelist 链表。由于修改是多步操作，为了保持多线程一致性，必须加锁。但这样的设计也使得多线程无法并发申请内存，限制了并发效率。</p><p>证据是 kmem 锁上频繁的锁竞争：</p><div class="language-text highlighter-rouge"><div class="code-header"> <span data-label-text="Text"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre><td class="rouge-code"><pre>$ kalloctest
start test1
test1 results:
--- lock kmem/bcache stats
lock: kmem: #fetch-and-add 83375 #acquire() 433015
lock: bcache: #fetch-and-add 0 #acquire() 1260
--- top 5 contended locks:
lock: kmem: #fetch-and-add 83375 #acquire() 433015  // kmem 是整个系统中竞争最激烈的锁
lock: proc: #fetch-and-add 23737 #acquire() 130718
lock: virtio_disk: #fetch-and-add 11159 #acquire() 114
lock: proc: #fetch-and-add 5937 #acquire() 130786
lock: proc: #fetch-and-add 4080 #acquire() 130786
tot= 83375
test1 FAIL
</pre></table></code></div></div><p>这里体现了一个先 profile 再进行优化的思路。如果一个大锁并不会引起明显的性能问题，有时候大锁就足够了。只有在万分确定性能热点是在该锁的时候才进行优化，「过早优化是万恶之源」。</p><p>这里解决性能热点的思路是「将共享资源变为不共享资源」。锁竞争优化一般有几个思路：</p><ul><li>只在必须共享的时候共享（对应为将资源从 CPU 共享拆分为每个 CPU 独立）<li>必须共享时，尽量减少在关键区中停留的时间（对应“大锁化小锁”，降低锁的粒度）</ul><p>该 lab 的实验目标，即是为每个 CPU 分配独立的 freelist，这样多个 CPU 并发分配物理页就不再会互相排斥了，提高了并行性。</p><p>但由于在一个 CPU freelist 中空闲页不足的情况下，仍需要从其他 CPU 的 freelist 中“偷”内存页，所以一个 CPU 的 freelist 并不是只会被其对应 CPU 访问，还可能在“偷”内存页的时候被其他 CPU 访问，故仍然需要使用单独的锁来保护每个 CPU 的 freelist。但一个 CPU freelist 中空闲页不足的情况相对来说是比较稀有的，所以总体性能依然比单独 kmem 大锁要快。在最佳情况下，也就是没有发生跨 CPU “偷”页的情况下，这些小锁不会发生任何锁竞争。</p><h3 id="代码实现"><span class="mr-2">代码实现</span><a href="#代码实现" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
</pre><td class="rouge-code"><pre><span class="c1">// kernel/kalloc.c</span>
<span class="k">struct</span> <span class="p">{</span>
  <span class="k">struct</span> <span class="n">spinlock</span> <span class="n">lock</span><span class="p">;</span>
  <span class="k">struct</span> <span class="n">run</span> <span class="o">*</span><span class="n">freelist</span><span class="p">;</span>
<span class="p">}</span> <span class="n">kmem</span><span class="p">[</span><span class="n">NCPU</span><span class="p">];</span> <span class="c1">// 为每个 CPU 分配独立的 freelist，并用独立的锁保护它。</span>

<span class="kt">char</span> <span class="o">*</span><span class="n">kmem_lock_names</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
  <span class="s">"kmem_cpu_0"</span><span class="p">,</span>
  <span class="s">"kmem_cpu_1"</span><span class="p">,</span>
  <span class="s">"kmem_cpu_2"</span><span class="p">,</span>
  <span class="s">"kmem_cpu_3"</span><span class="p">,</span>
  <span class="s">"kmem_cpu_4"</span><span class="p">,</span>
  <span class="s">"kmem_cpu_5"</span><span class="p">,</span>
  <span class="s">"kmem_cpu_6"</span><span class="p">,</span>
  <span class="s">"kmem_cpu_7"</span><span class="p">,</span>
<span class="p">};</span>

<span class="kt">void</span>
<span class="nf">kinit</span><span class="p">()</span>
<span class="p">{</span>
  <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">NCPU</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 初始化所有锁</span>
    <span class="n">initlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kmem</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">lock</span><span class="p">,</span> <span class="n">kmem_lock_names</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
  <span class="p">}</span>
  <span class="n">freerange</span><span class="p">(</span><span class="n">end</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">PHYSTOP</span><span class="p">);</span>
<span class="p">}</span>

</pre></table></code></div></div><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
</pre><td class="rouge-code"><pre><span class="c1">// kernel/kalloc.c</span>
<span class="kt">void</span>
<span class="nf">kfree</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">pa</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">struct</span> <span class="n">run</span> <span class="o">*</span><span class="n">r</span><span class="p">;</span>

  <span class="k">if</span><span class="p">(((</span><span class="n">uint64</span><span class="p">)</span><span class="n">pa</span> <span class="o">%</span> <span class="n">PGSIZE</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">||</span> <span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">pa</span> <span class="o">&lt;</span> <span class="n">end</span> <span class="o">||</span> <span class="p">(</span><span class="n">uint64</span><span class="p">)</span><span class="n">pa</span> <span class="o">&gt;=</span> <span class="n">PHYSTOP</span><span class="p">)</span>
    <span class="n">panic</span><span class="p">(</span><span class="s">"kfree"</span><span class="p">);</span>

  <span class="c1">// Fill with junk to catch dangling refs.</span>
  <span class="n">memset</span><span class="p">(</span><span class="n">pa</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">PGSIZE</span><span class="p">);</span>

  <span class="n">r</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">run</span><span class="o">*</span><span class="p">)</span><span class="n">pa</span><span class="p">;</span>

  <span class="n">push_off</span><span class="p">();</span>

  <span class="kt">int</span> <span class="n">cpu</span> <span class="o">=</span> <span class="n">cpuid</span><span class="p">();</span>

  <span class="n">acquire</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kmem</span><span class="p">[</span><span class="n">cpu</span><span class="p">].</span><span class="n">lock</span><span class="p">);</span>
  <span class="n">r</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">kmem</span><span class="p">[</span><span class="n">cpu</span><span class="p">].</span><span class="n">freelist</span><span class="p">;</span>
  <span class="n">kmem</span><span class="p">[</span><span class="n">cpu</span><span class="p">].</span><span class="n">freelist</span> <span class="o">=</span> <span class="n">r</span><span class="p">;</span>
  <span class="n">release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kmem</span><span class="p">[</span><span class="n">cpu</span><span class="p">].</span><span class="n">lock</span><span class="p">);</span>

  <span class="n">pop_off</span><span class="p">();</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="o">*</span>
<span class="nf">kalloc</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">struct</span> <span class="n">run</span> <span class="o">*</span><span class="n">r</span><span class="p">;</span>

  <span class="n">push_off</span><span class="p">();</span>

  <span class="kt">int</span> <span class="n">cpu</span> <span class="o">=</span> <span class="n">cpuid</span><span class="p">();</span>

  <span class="n">acquire</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kmem</span><span class="p">[</span><span class="n">cpu</span><span class="p">].</span><span class="n">lock</span><span class="p">);</span>

  <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">kmem</span><span class="p">[</span><span class="n">cpu</span><span class="p">].</span><span class="n">freelist</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// no page left for this cpu</span>
    <span class="kt">int</span> <span class="n">steal_left</span> <span class="o">=</span> <span class="mi">64</span><span class="p">;</span> <span class="c1">// steal 64 pages from other cpu(s)</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">NCPU</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span><span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">cpu</span><span class="p">)</span> <span class="k">continue</span><span class="p">;</span> <span class="c1">// no self-robbery</span>
      <span class="n">acquire</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kmem</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">lock</span><span class="p">);</span>
      <span class="k">struct</span> <span class="n">run</span> <span class="o">*</span><span class="n">rr</span> <span class="o">=</span> <span class="n">kmem</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">freelist</span><span class="p">;</span>
      <span class="k">while</span><span class="p">(</span><span class="n">rr</span> <span class="o">&amp;&amp;</span> <span class="n">steal_left</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">kmem</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">freelist</span> <span class="o">=</span> <span class="n">rr</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
        <span class="n">rr</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">kmem</span><span class="p">[</span><span class="n">cpu</span><span class="p">].</span><span class="n">freelist</span><span class="p">;</span>
        <span class="n">kmem</span><span class="p">[</span><span class="n">cpu</span><span class="p">].</span><span class="n">freelist</span> <span class="o">=</span> <span class="n">rr</span><span class="p">;</span>
        <span class="n">rr</span> <span class="o">=</span> <span class="n">kmem</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">freelist</span><span class="p">;</span>
        <span class="n">steal_left</span><span class="o">--</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="n">release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kmem</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">lock</span><span class="p">);</span>
      <span class="k">if</span><span class="p">(</span><span class="n">steal_left</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="k">break</span><span class="p">;</span> <span class="c1">// done stealing</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="n">r</span> <span class="o">=</span> <span class="n">kmem</span><span class="p">[</span><span class="n">cpu</span><span class="p">].</span><span class="n">freelist</span><span class="p">;</span>
  <span class="k">if</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
    <span class="n">kmem</span><span class="p">[</span><span class="n">cpu</span><span class="p">].</span><span class="n">freelist</span> <span class="o">=</span> <span class="n">r</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
  <span class="n">release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kmem</span><span class="p">[</span><span class="n">cpu</span><span class="p">].</span><span class="n">lock</span><span class="p">);</span>

  <span class="n">pop_off</span><span class="p">();</span>

  <span class="k">if</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
    <span class="n">memset</span><span class="p">((</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">r</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="n">PGSIZE</span><span class="p">);</span> <span class="c1">// fill with junk</span>
  <span class="k">return</span> <span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">r</span><span class="p">;</span>
<span class="p">}</span>

</pre></table></code></div></div><p>这里选择在内存页不足的时候，从其他的 CPU “偷” 64 个页，这里的数值是随意取的，在现实场景中，最好进行测量后选取合适的数值，尽量使得“偷”页频率低。</p><p><strong>UPDATE 2022-04-14: 上述代码可能产生死锁（cpu_a 尝试偷 cpu_b，cpu_b 尝试偷 cpu_a），可能的解决方案看本文评论区或 <a href="https://github.com/Miigon/blog/issues/8">https://github.com/Miigon/blog/issues/8</a>。</strong></p><p>再次运行 kalloctest：</p><div class="language-text highlighter-rouge"><div class="code-header"> <span data-label-text="Text"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre><td class="rouge-code"><pre>$ kalloctest
start test1
test1 results:
--- lock kmem/bcache stats
lock: kmem_cpu_0: #fetch-and-add 0 #acquire() 35979
lock: kmem_cpu_1: #fetch-and-add 0 #acquire() 195945
lock: kmem_cpu_2: #fetch-and-add 0 #acquire() 201094
lock: bcache: #fetch-and-add 0 #acquire() 1248
--- top 5 contended locks:
lock: proc: #fetch-and-add 22486 #acquire() 132299
lock: virtio_disk: #fetch-and-add 16002 #acquire() 114
lock: proc: #fetch-and-add 11199 #acquire() 132301
lock: proc: #fetch-and-add 5330 #acquire() 132322
lock: proc: #fetch-and-add 4874 #acquire() 132345
tot= 0
test1 OK
start test2
total free number of pages: 32499 (out of 32768)
.....
test2 OK
</pre></table></code></div></div><p>可以看到，kmem 带来的锁竞争降低到了 0（从原本的 ~83375）。</p><h2 id="buffer-cache-hard"><span class="mr-2">Buffer cache (hard)</span><a href="#buffer-cache-hard" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><blockquote><p>If multiple processes use the file system intensively, they will likely contend for bcache.lock, which protects the disk block cache in kernel/bio.c. bcachetest creates several processes that repeatedly read different files in order to generate contention on bcache.lock;</p></blockquote><p>多个进程同时使用文件系统的时候，bcache.lock 上会发生严重的锁竞争。bcache.lock 锁用于保护磁盘区块缓存，在原本的设计中，由于该锁的存在，多个进程不能同时操作（申请、释放）磁盘缓存。</p><h3 id="原理"><span class="mr-2">原理</span><a href="#原理" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>因为不像 kalloc 中一个物理页分配后就只归单个进程所管，bcache 中的区块缓存是会被多个进程（进一步地，被多个 CPU）共享的（由于多个进程可以同时访问同一个区块）。所以 kmem 中为每个 CPU 预先分割一部分专属的页的方法在这里是行不通的。</p><p>前面提到的：</p><blockquote><p>锁竞争优化一般有几个思路：</p><ul><li>只在必须共享的时候共享（对应为将资源从 CPU 共享拆分为每个 CPU 独立）<li>必须共享时，尽量减少在关键区中停留的时间（对应“大锁化小锁”，降低锁的粒度）</ul></blockquote><p>在这里， bcache 属于“必须共享”的情况，所以需要用到第二个思路，降低锁的粒度，用更精细的锁 scheme 来降低出现竞争的概率。</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre><span class="c1">// kernel/bio.c</span>
<span class="k">struct</span> <span class="p">{</span>
  <span class="k">struct</span> <span class="n">spinlock</span> <span class="n">lock</span><span class="p">;</span>
  <span class="k">struct</span> <span class="n">buf</span> <span class="n">buf</span><span class="p">[</span><span class="n">NBUF</span><span class="p">];</span>

  <span class="c1">// Linked list of all buffers, through prev/next.</span>
  <span class="c1">// Sorted by how recently the buffer was used.</span>
  <span class="c1">// head.next is most recent, head.prev is least.</span>
  <span class="k">struct</span> <span class="n">buf</span> <span class="n">head</span><span class="p">;</span>
<span class="p">}</span> <span class="n">bcache</span><span class="p">;</span>
</pre></table></code></div></div><p>原版 xv6 的设计中，使用双向链表存储所有的区块缓存，每次尝试获取一个区块 blockno 的时候，会遍历链表，如果目标区块已经存在缓存中则直接返回，如果不存在则选取一个最近最久未使用的，且引用计数为 0 的 buf 块作为其区块缓存，并返回。</p><p>新的改进方案，可以<strong>建立一个从 blockno 到 buf 的哈希表，并为每个桶单独加锁</strong>。这样，仅有在两个进程同时访问的区块同时哈希到同一个桶的时候，才会发生锁竞争。当桶中的空闲 buf 不足的时候，从其他的桶中获取 buf。</p><p>思路上是很简单的，但是具体实现的时候，需要注意死锁问题。这里的许多死锁问题比较隐晦，而且 bcachetest 测试不出来，但是在实际运行的系统中，是有可能触发死锁的。网上看过许多其他通过了的同学的博客，代码中都没有注意到这一点。</p><h3 id="死锁问题"><span class="mr-2">死锁问题</span><a href="#死锁问题" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>考虑一下我们的新设计，首先在 bcache 中定义哈希表 bufmap，并为每个桶设置锁：</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre><span class="c1">// kernel/bio.h</span>
<span class="k">struct</span> <span class="p">{</span>
  <span class="k">struct</span> <span class="n">buf</span> <span class="n">buf</span><span class="p">[</span><span class="n">NBUF</span><span class="p">];</span>
  <span class="k">struct</span> <span class="n">spinlock</span> <span class="n">eviction_lock</span><span class="p">;</span>

  <span class="c1">// Hash map: dev and blockno to buf</span>
  <span class="k">struct</span> <span class="n">buf</span> <span class="n">bufmap</span><span class="p">[</span><span class="n">NBUFMAP_BUCKET</span><span class="p">];</span>
  <span class="k">struct</span> <span class="n">spinlock</span> <span class="n">bufmap_locks</span><span class="p">[</span><span class="n">NBUFMAP_BUCKET</span><span class="p">];</span>
<span class="p">}</span> <span class="n">bcache</span><span class="p">;</span>
</pre></table></code></div></div><p>bget(uint dev, uint blockno) 中，首先在 blockno 对应桶中扫描缓存是否存在，如果不存在，则在<strong>所有桶</strong>中寻找一个最近最久未使用的无引用 buf，进行缓存驱逐，然后将其重新移动到 blockno 对应的桶中（rehash），作为 blockno 的缓存返回。</p><p>这里很容易就会写出这样的代码：</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
</pre><td class="rouge-code"><pre><span class="n">bget</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">blockno</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">key</span> <span class="o">:=</span> <span class="n">hash</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">blockno</span><span class="p">);</span>

  <span class="n">acquire</span><span class="p">(</span><span class="n">bufmap_locks</span><span class="p">[</span><span class="n">key</span><span class="p">]);</span> <span class="c1">// 获取 key 桶的锁</span>
  
  <span class="c1">// 查找 blockno 的缓存是否存在，若是直接返回，若否继续执行</span>
  <span class="k">if</span><span class="p">(</span><span class="n">b</span> <span class="o">:=</span> <span class="n">look_for_blockno_in</span><span class="p">(</span><span class="n">bufmap</span><span class="p">[</span><span class="n">key</span><span class="p">]))</span> <span class="p">{</span>
    <span class="n">b</span><span class="o">-&gt;</span><span class="n">refcnt</span><span class="o">++</span>
    <span class="n">release</span><span class="p">(</span><span class="n">bufmap_locks</span><span class="p">[</span><span class="n">key</span><span class="p">]);</span>
    <span class="k">return</span> <span class="n">b</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">// 查找可驱逐缓存 b</span>
  
  <span class="n">least_recently</span> <span class="o">:=</span> <span class="nb">NULL</span><span class="p">;</span>
  
  <span class="k">for</span> <span class="n">i</span> <span class="o">:=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">NBUFMAP_BUCKET</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 遍历所有的桶</span>
    <span class="n">acquire</span><span class="p">(</span><span class="n">bufmap_locks</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>    <span class="c1">// 获取第 i 桶的锁</span>

    <span class="n">b</span> <span class="o">:=</span> <span class="n">look_for_least_recently_used_with_no_ref</span><span class="p">(</span><span class="n">bufmap</span><span class="p">[</span><span class="n">key</span><span class="p">]);</span>
    <span class="c1">// 如果找到未使用时间更长的空闲块</span>
    <span class="k">if</span><span class="p">(</span><span class="n">b</span><span class="p">.</span><span class="n">last_use</span> <span class="o">&lt;</span> <span class="n">least_recently</span><span class="p">.</span><span class="n">last_use</span><span class="p">)</span> <span class="p">{</span>  
      <span class="n">least_recently</span> <span class="o">:=</span> <span class="n">b</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">release</span><span class="p">(</span><span class="n">bufmap_locks</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>   <span class="c1">// 查找结束后，释放第 i 桶的锁</span>
  <span class="p">}</span>

  <span class="n">b</span> <span class="o">:=</span> <span class="n">least_recently</span><span class="p">;</span>

  <span class="c1">// 驱逐 b 原本存储的缓存（将其从原来的桶删除）</span>
  <span class="n">evict</span><span class="p">(</span><span class="n">b</span><span class="p">);</span>

  <span class="c1">// 将 b 加入到新的桶</span>
  <span class="n">append</span><span class="p">(</span><span class="n">bucket</span><span class="p">[</span><span class="n">key</span><span class="p">],</span> <span class="n">b</span><span class="p">);</span>

  <span class="n">release</span><span class="p">(</span><span class="n">bufmap_locks</span><span class="p">[</span><span class="n">key</span><span class="p">]);</span> <span class="c1">// 释放 key 桶的锁</span>

  <span class="c1">// 设置 b 的各个属性</span>
  <span class="n">setup</span><span class="p">(</span><span class="n">b</span><span class="p">);</span>
  <span class="k">return</span> <span class="n">b</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>上面的代码看起来很合理，但是却有两个问题，一个导致运行结果出错，一个导致死锁。</p><h3 id="问题1可驱逐-buf-在所对应桶锁释放后不保证仍可驱逐"><span class="mr-2">问题1：可驱逐 buf 在所对应桶锁释放后不保证仍可驱逐</span><a href="#问题1可驱逐-buf-在所对应桶锁释放后不保证仍可驱逐" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>第一个问题比较显而易见，后面进行缓存驱逐的时候，每扫描一个桶前会获取该桶的锁，但是每扫描完一个桶后又释放了该桶的锁。<strong>从释放锁的那一瞬间，获取出来的最近最久未使用的空闲 buf 就不再可靠了</strong>。因为在我们释放 b 原来所在的桶的锁后（<code class="language-plaintext highlighter-rouge">release(bufmap_locks[i]);</code> 后），但是从原桶删除 b 之前（<code class="language-plaintext highlighter-rouge">evict(b);</code> 前），另一个 CPU 完全可能会调用 bget 请求 b，使得 b 的引用计数变为不为零。此时我们对 b 进行驱逐就是不安全的了。</p><p>解决方法也并不复杂，只需要在扫描桶的时候，确保找到最近最久未使用的空闲 buf 后，不释放桶锁，继续持有其对应的桶的锁直到驱逐完成即可。</p><blockquote><p>这里维护的不变量（invariant）是：「扫描到的 buf 在驱逐完成前保持可驱逐」，以及「桶中若存在某个块的 buf，则这个 buf 可用，bget可以直接返回这个 buf」。</p></blockquote><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
</pre><td class="rouge-code"><pre><span class="n">bget</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">blockno</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">acquire</span><span class="p">(</span><span class="n">bufmap_locks</span><span class="p">[</span><span class="n">key</span><span class="p">]);</span> <span class="c1">// 获取 key 桶锁</span>
  
  <span class="c1">// 查找 blockno 的缓存是否存在，若是直接返回，若否继续执行</span>
  <span class="k">if</span><span class="p">(</span><span class="n">b</span> <span class="o">:=</span> <span class="n">look_for_blockno_in</span><span class="p">(</span><span class="n">bufmap</span><span class="p">[</span><span class="n">key</span><span class="p">]))</span> <span class="p">{</span>
    <span class="n">b</span><span class="o">-&gt;</span><span class="n">refcnt</span><span class="o">++</span>
    <span class="n">release</span><span class="p">(</span><span class="n">bufmap_locks</span><span class="p">[</span><span class="n">key</span><span class="p">]);</span>
    <span class="k">return</span> <span class="n">b</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">// 缓存不存在，查找可驱逐缓存 b</span>
  
  <span class="n">least_recently</span> <span class="o">:=</span> <span class="nb">NULL</span><span class="p">;</span>
  <span class="n">holding_bucket</span> <span class="o">:=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
  
  <span class="k">for</span> <span class="n">i</span> <span class="o">:=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">NBUFMAP_BUCKET</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 遍历所有的桶</span>
    <span class="n">acquire</span><span class="p">(</span><span class="n">bufmap_locks</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>    <span class="c1">// 获取第 i 桶的锁</span>

    <span class="n">b</span> <span class="o">:=</span> <span class="n">look_for_least_recently_used_with_no_ref</span><span class="p">(</span><span class="n">bufmap</span><span class="p">[</span><span class="n">key</span><span class="p">]);</span>
    <span class="c1">// 如果找到未使用时间更长的空闲块（新的 least_recently）</span>
    
    <span class="k">if</span><span class="p">(</span><span class="n">b</span><span class="p">.</span><span class="n">last_use</span> <span class="o">&gt;=</span> <span class="n">least_recently</span><span class="p">.</span><span class="n">last_use</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">release</span><span class="p">(</span><span class="n">bufmap_locks</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>   <span class="c1">// 该桶中没有找到新的 least_recently，释放该桶的锁</span>

    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="c1">// b.last_use &lt; least_recently.last_use</span>
      <span class="n">least_recently</span> <span class="o">:=</span> <span class="n">b</span><span class="p">;</span>

      <span class="c1">// 释放原本 holding 的锁（holding_bucket &lt; i）</span>
      <span class="k">if</span><span class="p">(</span><span class="n">holding_bucket</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">holding_bucket</span> <span class="o">!=</span> <span class="n">key</span><span class="p">)</span> <span class="n">release</span><span class="p">(</span><span class="n">bufmap_locks</span><span class="p">[</span><span class="n">holding_bucket</span><span class="p">]);</span>
      <span class="c1">// 保持第 i 桶的锁不释放......</span>
      <span class="n">holding_bucket</span> <span class="o">:=</span> <span class="n">i</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="n">b</span> <span class="o">:=</span> <span class="n">least_recently</span><span class="p">;</span>

  <span class="c1">// 此时，仍然持有 b 所在的桶的锁 bufmap_locks[holding_bucket]</span>
  <span class="c1">// 驱逐 b 原本存储的缓存（将其从原来的桶删除）</span>
  <span class="n">evict</span><span class="p">(</span><span class="n">b</span><span class="p">);</span>
  <span class="n">release</span><span class="p">(</span><span class="n">bufmap_locks</span><span class="p">[</span><span class="n">holding_bucket</span><span class="p">]);</span> <span class="c1">// 驱逐后再释放 b 原本所在桶的锁</span>

  <span class="c1">// 将 b 加入到新的桶</span>
  <span class="n">append</span><span class="p">(</span><span class="n">bucket</span><span class="p">[</span><span class="n">key</span><span class="p">],</span> <span class="n">b</span><span class="p">);</span>

  <span class="n">release</span><span class="p">(</span><span class="n">bufmap_locks</span><span class="p">[</span><span class="n">key</span><span class="p">]);</span> <span class="c1">// 释放 key 桶锁</span>

  <span class="c1">// 设置 b 的各个属性</span>
  <span class="n">setup</span><span class="p">(</span><span class="n">b</span><span class="p">);</span>
  <span class="k">return</span> <span class="n">b</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><h3 id="问题2两个请求形成环路死锁"><span class="mr-2">问题2：两个请求形成环路死锁</span><a href="#问题2两个请求形成环路死锁" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>这里出现的第二个问题就是，一开始我们在 blockno 对应的桶中遍历检查缓存是否存在时，获取了它的锁。而在我们发现 blockno 不存在缓存中之后，需要在拿着 key 桶锁的同时，<strong>遍历所有的桶并依次获取它们每个的锁</strong>，考虑这种情况：</p><div class="language-text highlighter-rouge"><div class="code-header"> <span data-label-text="Text"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
</pre><td class="rouge-code"><pre>假设块号 b1 的哈希值是 2，块号 b2 的哈希值是 5
并且两个块在运行前都没有被缓存
----------------------------------------
CPU1                  CPU2
----------------------------------------
bget(dev, b1)         bget(dev,b2)
    |                     |
    V                     V
获取桶 2 的锁           获取桶 5 的锁
    |                     |
    V                     V
缓存不存在，遍历所有桶    缓存不存在，遍历所有桶
    |                     |
    V                     V
  ......                遍历到桶 2
    |                尝试获取桶 2 的锁
    |                     |
    V                     V
  遍历到桶 5          桶 2 的锁由 CPU1 持有，等待释放
尝试获取桶 5 的锁
    |
    V
桶 5 的锁由 CPU2 持有，等待释放

!此时 CPU1 等待 CPU2，而 CPU2 在等待 CPU1，陷入死锁!

</pre></table></code></div></div><p>这里，由于 CPU1 持有锁 2 的情况下去申请锁 5，而 CPU2 持有锁 5 的情况下申请锁 2，造成了<strong>环路等待</strong>。</p><p>复习一下死锁的四个条件：</p><ol><li>互斥（一个资源在任何时候只能属于一个线程）<li>请求保持（线程在拿着一个锁的情况下，去申请另一个锁）<li>不剥夺（外力不强制剥夺一个线程已经拥有的资源）<li>环路等待（请求资源的顺序形成了一个环）</ol><p>只要破坏了四个条件中的任何一个，就能破坏死锁。为了尝试解决这个死锁问题，我们考虑破坏每一个条件的可行性：</p><ol><li>互斥：在这里一个桶只能同时被一个 CPU（线程）处理，互斥条件是必须的，无法破坏。<li>请求保持<li>不剥夺：遍历桶的时候，在环路请求出现时强行释放一方的锁？即使能检测，被强制释放锁的一方的 bget 请求会失败，造成文件系统相关系统调用失败，不可行。<li>环路等待：改变访问顺序，比如永远只遍历当前 key 左侧的桶，使得无论如何访问都不会出现环路？可解决死锁，但假设 blockno 哈希到第一个桶，并且 cache missed 时，将无法进行缓存驱逐来腾出新块供其使用（因为第一个桶左侧没有任何桶）。</ol><p>从「互斥」、「不剥夺」和「环路等待」条件入手都无法解决这个死锁问题，那只能考虑「请求保持」了。</p><p>这里死锁出现的原因是我们在拿着一个锁的情况下，去尝试申请另一个锁，并且请求顺序出现了环路。既然带环路的请求顺序是不可避免的，那唯一的选项就是<strong>在申请任何其他桶锁之前，先放弃之前持有的 key 的桶锁</strong>，在找到并驱逐最近最久未使用的空闲块 b 后，再重新获取 key 的桶锁，将 b 加入桶。</p><p>大致代码是这样：</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
</pre><td class="rouge-code"><pre><span class="n">bget</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">blockno</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">acquire</span><span class="p">(</span><span class="n">bufmap_locks</span><span class="p">[</span><span class="n">key</span><span class="p">]);</span> <span class="c1">// 获取 key 桶锁</span>
  
  <span class="c1">// 查找 blockno 的缓存是否存在，若是直接返回，若否继续执行</span>
  <span class="k">if</span><span class="p">(</span><span class="n">b</span> <span class="o">:=</span> <span class="n">look_for_blockno_in</span><span class="p">(</span><span class="n">bufmap</span><span class="p">[</span><span class="n">key</span><span class="p">]))</span> <span class="p">{</span>
    <span class="n">b</span><span class="o">-&gt;</span><span class="n">refcnt</span><span class="o">++</span>
    <span class="n">release</span><span class="p">(</span><span class="n">bufmap_locks</span><span class="p">[</span><span class="n">key</span><span class="p">]);</span>
    <span class="k">return</span> <span class="n">b</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="n">release</span><span class="p">(</span><span class="n">bufmap_locks</span><span class="p">[</span><span class="n">key</span><span class="p">]);</span> <span class="c1">// 先释放 key 桶锁，防止查找驱逐时出现环路等待</span>

  <span class="c1">// 缓存不存在，查找可驱逐缓存 b</span>
  
  <span class="n">holding_bucket</span> <span class="o">:=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
  <span class="k">for</span> <span class="n">i</span> <span class="o">:=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">NBUFMAP_BUCKET</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">acquire</span><span class="p">(</span><span class="n">bufmap_locks</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span> <span class="c1">// 请求时不持有 key 桶锁，不会出现环路等待</span>
    <span class="k">if</span><span class="p">(</span><span class="n">b</span> <span class="o">:=</span> <span class="n">look_for_least_recently_used_with_no_ref</span><span class="p">(</span><span class="n">bufmap</span><span class="p">[</span><span class="n">key</span><span class="p">]))</span> <span class="p">{</span>
      <span class="k">if</span><span class="p">(</span><span class="n">holding_bucket</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="n">release</span><span class="p">(</span><span class="n">bufmap_locks</span><span class="p">[</span><span class="n">holding_bucket</span><span class="p">]);</span>
      <span class="n">holding_bucket</span> <span class="o">:=</span> <span class="n">i</span><span class="p">;</span>
      <span class="c1">// 如果找到新的未使用时间更长的空闲块，则将原来的块所属桶的锁释放掉，保持新块所属桶的锁...</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="n">release</span><span class="p">(</span><span class="n">bufmap_locks</span><span class="p">[</span><span class="n">holding_bucket</span><span class="p">]);</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="c1">// 驱逐 b 原本存储的缓存（将其从原来的桶删除）</span>
  <span class="n">evict</span><span class="p">(</span><span class="n">b</span><span class="p">);</span>
  <span class="n">release</span><span class="p">(</span><span class="n">bufmap_locks</span><span class="p">[</span><span class="n">holding_bucket</span><span class="p">]);</span> <span class="c1">// 释放 b 原所在桶的锁</span>

  <span class="n">acquire</span><span class="p">(</span><span class="n">bufmap_locks</span><span class="p">[</span><span class="n">key</span><span class="p">]);</span> <span class="c1">// 再次获取 key 桶锁</span>
  <span class="n">append</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">bucket</span><span class="p">[</span><span class="n">key</span><span class="p">]);</span>     <span class="c1">// 将 b 加入到新的桶</span>
  <span class="n">release</span><span class="p">(</span><span class="n">bufmap_locks</span><span class="p">[</span><span class="n">key</span><span class="p">]);</span> <span class="c1">// 释放 key 桶锁</span>


  <span class="c1">// 设置 b 的各个属性</span>
  <span class="n">setup</span><span class="p">(</span><span class="n">b</span><span class="p">);</span>
  <span class="k">return</span> <span class="n">b</span><span class="p">;</span>
<span class="p">}</span>

</pre></table></code></div></div><p>这样以来，bget 中无论任何位置，获取桶锁的时候都要么没拿其他锁，要么只拿了其左侧的桶锁（遍历所有桶查找可驱逐缓存 b 的过程中，对桶的遍历固定从小到大访问），所以永远不会出现环路，死锁得到了避免。但是这样的方案又会带来新的问题。</p><h3 id="新的问题释放自身桶锁可能使得同-blockno-重复驱逐与分配"><span class="mr-2">新的问题：释放自身桶锁可能使得同 blockno 重复驱逐与分配</span><a href="#新的问题释放自身桶锁可能使得同-blockno-重复驱逐与分配" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>注意到我们开始「搜索所有桶寻找可驱逐的 buf」这个过程前，为了防止环路等待，而释放了 key 的桶锁（key 为请求的 blockno 的哈希值），直到遍历所有桶并驱逐最近最久未使用的空闲 buf 的过程完成后才重新获取 key 桶锁。问题在于，在释放掉 key 桶锁之后，第一块关键区（“查找 blockno 的缓存是否存在，若是直接返回，若否继续执行”的区域）就得不到锁保护了。这意味着在「释放掉 key 桶锁后」到「重新获取 key 桶锁前」的这个阶段，也就是我们进行驱逐+重分配时，另外一个 CPU 完全有可能访问同一个 blockno，获取到 key 的桶锁，通过了一开始「缓存不存在」的测试，然后也进入到驱逐+重分配中，导致「一个区块有多份缓存」的错误情况出现。</p><p>怎么保障同一个区块不会有两个缓存呢？</p><p>这个问题相对比较棘手，我们目前知道的限制条件有：</p><ul><li>在遍历桶查找可驱逐 buf 的过程中，不能持有 key 的桶锁，否则会出现死锁。<li>在遍历桶查找可驱逐 buf 的过程中，不持有 key 桶锁的话，可能会有其他 CPU 访问同一 blockno，并完成驱逐+重分配，导致同一 blockno 被重复缓存。</ul><p>这里不得不承认，我并没有想到什么特别好的方法，只想到了一个牺牲一点效率，但是能保证极端情况下安全的方案：</p><ul><li><p>添加 eviction_lock，将驱逐+重分配的过程限制为单线程</p><p>注意此处应该先释放桶锁后，再获取 eviction_lock。写反会导致 eviction_lock 和桶锁发生死锁。（线程 1 拿着桶 A 锁请求 eviction_lock， 线程 2 拿着 eviction_lock 驱逐时遍历请求到桶 A 锁）</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
</pre><td class="rouge-code"><pre><span class="n">bget</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">blockno</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">acquire</span><span class="p">(</span><span class="n">bufmap_locks</span><span class="p">[</span><span class="n">key</span><span class="p">]);</span> <span class="c1">// 获取 key 桶锁</span>
    
  <span class="c1">// 查找 blockno 的缓存是否存在，若是直接返回，若否继续执行</span>
  <span class="k">if</span><span class="p">(</span><span class="n">b</span> <span class="o">:=</span> <span class="n">look_for_blockno_in</span><span class="p">(</span><span class="n">bufmap</span><span class="p">[</span><span class="n">key</span><span class="p">]))</span> <span class="p">{</span>
    <span class="n">b</span><span class="o">-&gt;</span><span class="n">refcnt</span><span class="o">++</span>
    <span class="n">release</span><span class="p">(</span><span class="n">bufmap_locks</span><span class="p">[</span><span class="n">key</span><span class="p">]);</span>
    <span class="k">return</span> <span class="n">b</span><span class="p">;</span>
  <span class="p">}</span>
    
  <span class="c1">// 注意这里的 acquire 和 release 的顺序</span>
  <span class="n">release</span><span class="p">(</span><span class="n">bufmap_locks</span><span class="p">[</span><span class="n">key</span><span class="p">]);</span> <span class="c1">// 先释放 key 桶锁，防止查找驱逐时出现环路死锁</span>
  <span class="n">acquire</span><span class="p">(</span><span class="n">eviction_lock</span><span class="p">);</span>     <span class="c1">// 获得驱逐锁，防止多个 CPU 同时驱逐影响后续判断</span>

  <span class="c1">// 缓存不存在，查找可驱逐缓存 b</span>
    
  <span class="c1">// .......</span>

  <span class="n">acquire</span><span class="p">(</span><span class="n">bufmap_locks</span><span class="p">[</span><span class="n">key</span><span class="p">]);</span> <span class="c1">// 再次获取 key 桶锁</span>
  <span class="n">append</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">bucket</span><span class="p">[</span><span class="n">key</span><span class="p">]);</span>     <span class="c1">// 将 b 加入到新的桶</span>
  <span class="n">release</span><span class="p">(</span><span class="n">bufmap_locks</span><span class="p">[</span><span class="n">key</span><span class="p">]);</span> <span class="c1">// 释放 key 桶锁</span>

  <span class="n">release</span><span class="p">(</span><span class="n">eviction_lock</span><span class="p">);</span>     <span class="c1">// 释放驱逐锁</span>

  <span class="c1">// 设置 b 的各个属性</span>
  <span class="n">setup</span><span class="p">(</span><span class="n">b</span><span class="p">);</span>
  <span class="k">return</span> <span class="n">b</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><li><p>在获取 eviction_lock 之后，马上<strong>再次判断 blockno 的缓存是否存在</strong>，若是直接返回，若否继续执行</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
</pre><td class="rouge-code"><pre><span class="n">bget</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">blockno</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">acquire</span><span class="p">(</span><span class="n">bufmap_locks</span><span class="p">[</span><span class="n">key</span><span class="p">]);</span> <span class="c1">// 获取 key 桶锁</span>
    
  <span class="c1">// 查找 blockno 的缓存是否存在，若是直接返回，若否继续执行</span>
  <span class="k">if</span><span class="p">(</span><span class="n">b</span> <span class="o">:=</span> <span class="n">look_for_blockno_in</span><span class="p">(</span><span class="n">bufmap</span><span class="p">[</span><span class="n">key</span><span class="p">]))</span> <span class="p">{</span>
    <span class="n">b</span><span class="o">-&gt;</span><span class="n">refcnt</span><span class="o">++</span>
    <span class="n">release</span><span class="p">(</span><span class="n">bufmap_locks</span><span class="p">[</span><span class="n">key</span><span class="p">]);</span>
    <span class="k">return</span> <span class="n">b</span><span class="p">;</span>
  <span class="p">}</span>
    
  <span class="c1">// 注意这里的 acquire 和 release 的顺序</span>
  <span class="n">release</span><span class="p">(</span><span class="n">bufmap_locks</span><span class="p">[</span><span class="n">key</span><span class="p">]);</span> <span class="c1">// 先释放 key 桶锁，防止查找驱逐时出现环路死锁</span>
  <span class="n">acquire</span><span class="p">(</span><span class="n">eviction_lock</span><span class="p">);</span>     <span class="c1">// 获得驱逐锁，防止多个 CPU 同时驱逐影响后续判断</span>

  <span class="c1">// **再次查找 blockno 的缓存是否存在**，若是直接返回，若否继续执行</span>
  <span class="c1">// 这里由于持有 eviction_lock，没有任何其他线程能够进行驱逐操作，所以</span>
  <span class="c1">// 没有任何其他线程能够改变 bufmap[key] 桶链表的结构，所以这里不事先获取</span>
  <span class="c1">// 其相应桶锁而直接开始遍历是安全的。</span>
  <span class="k">if</span><span class="p">(</span><span class="n">b</span> <span class="o">:=</span> <span class="n">look_for_blockno_in</span><span class="p">(</span><span class="n">bufmap</span><span class="p">[</span><span class="n">key</span><span class="p">]))</span> <span class="p">{</span>
    <span class="n">acquire</span><span class="p">(</span><span class="n">bufmap_locks</span><span class="p">[</span><span class="n">key</span><span class="p">]);</span> <span class="c1">// 必须获取，保护非原子操作 `refcnt++`</span>
    <span class="n">b</span><span class="o">-&gt;</span><span class="n">refcnt</span><span class="o">++</span>
    <span class="n">release</span><span class="p">(</span><span class="n">bufmap_locks</span><span class="p">[</span><span class="n">key</span><span class="p">]);</span>

    <span class="n">release</span><span class="p">(</span><span class="n">eviction_lock</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">b</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">// 缓存不存在，查找可驱逐缓存 b</span>
    
  <span class="c1">// .......</span>

  <span class="n">acquire</span><span class="p">(</span><span class="n">bufmap_locks</span><span class="p">[</span><span class="n">key</span><span class="p">]);</span> <span class="c1">// 再次获取 key 桶锁</span>
  <span class="n">append</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">bucket</span><span class="p">[</span><span class="n">key</span><span class="p">]);</span>     <span class="c1">// 将 b 加入到新的桶</span>
  <span class="n">release</span><span class="p">(</span><span class="n">bufmap_locks</span><span class="p">[</span><span class="n">key</span><span class="p">]);</span> <span class="c1">// 释放 key 桶锁</span>

  <span class="n">release</span><span class="p">(</span><span class="n">eviction_lock</span><span class="p">);</span>     <span class="c1">// 释放驱逐锁</span>

  <span class="c1">// 设置 b 的各个属性</span>
  <span class="n">setup</span><span class="p">(</span><span class="n">b</span><span class="p">);</span>
  <span class="k">return</span> <span class="n">b</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div></ul><p>这样以来，即使有多个线程同时请求同一个 blockno，并且所有线程都碰巧通过了一开始的「blockno 的缓存是否存在」的判断且结果都为「缓存不存在」，则进入受 eviction_lock 保护的驱逐+重分配区代码后，能够实际进行驱逐+重分配的，也只有第一个进入的线程。</p><p>第一个线程进入并驱逐+重分配完毕后才释放 eviction_lock，此时 blockno 的缓存已经由不存在变为存在了，后续的所有线程此时进入后都会被第二次「blockno 缓存是否存在」的判断代码拦住，并直接返回已分配好的缓存 buf，而不会重复对同一个 blockno 进行驱逐+重分配。</p><p>这么做的好处是，保证了查找过程中不会出现死锁，并且不会出现极端情况下一个块产生多个缓存的情况。而坏处是，引入了全局 eviction_lock，使得原本可并发的遍历驱逐过程的并行性降低了。并且每一次 cache miss 的时候，都会多一次额外的桶遍历开销。</p><p>然而，cache miss 本身（hopefully）为比较稀有事件，并且对于 cache miss 的块，由于后续需要从<strong>磁盘</strong>中读入其数据，磁盘读入的耗时将比一次桶遍历的耗时多好几个数量级，所以我认为这样的方案的开销还是可以接受的。</p><blockquote><p>ps. 这样的设计，有一个名词称为「乐观锁（optimistic locking）」，即在冲突发生概率很小的关键区内，不使用独占的互斥锁，而是在提交操作前，检查一下操作的数据是否被其他线程修改（在这里，检测的是 blockno 的缓存是否已被加入），如果是，则代表冲突发生，需要特殊处理（在这里的特殊处理即为直接返回已加入的 buf）。这样的设计，相比较「悲观锁（pessimistic locking）」而言，可以在冲突概率较低的场景下（例如 bget），降低锁开销以及不必要的线性化，提升并行性（例如在 bget 中允许「缓存是否存在」的判断并行化）。有时候还能用于避免死锁。</p></blockquote><h3 id="完整伪代码"><span class="mr-2">完整伪代码</span><a href="#完整伪代码" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
</pre><td class="rouge-code"><pre><span class="n">bget</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">blockno</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">acquire</span><span class="p">(</span><span class="n">bufmap_locks</span><span class="p">[</span><span class="n">key</span><span class="p">]);</span> <span class="c1">// 获取 key 桶锁</span>
  
  <span class="c1">// 查找 blockno 的缓存是否存在，若是直接返回，若否继续执行</span>
  <span class="k">if</span><span class="p">(</span><span class="n">b</span> <span class="o">:=</span> <span class="n">look_for_blockno_in</span><span class="p">(</span><span class="n">bufmap</span><span class="p">[</span><span class="n">key</span><span class="p">]))</span> <span class="p">{</span>
    <span class="n">b</span><span class="o">-&gt;</span><span class="n">refcnt</span><span class="o">++</span>
    <span class="n">release</span><span class="p">(</span><span class="n">bufmap_locks</span><span class="p">[</span><span class="n">key</span><span class="p">]);</span>
    <span class="k">return</span> <span class="n">b</span><span class="p">;</span>
  <span class="p">}</span>
  
  <span class="c1">// 注意这里的 acquire 和 release 的顺序</span>
  <span class="n">release</span><span class="p">(</span><span class="n">bufmap_locks</span><span class="p">[</span><span class="n">key</span><span class="p">]);</span> <span class="c1">// 先释放 key 桶锁，防止查找驱逐时出现环路死锁</span>
  <span class="n">acquire</span><span class="p">(</span><span class="n">eviction_lock</span><span class="p">);</span>     <span class="c1">// 获得驱逐锁，防止多个 CPU 同时驱逐影响后续判断</span>

  <span class="c1">// **再次查找 blockno 的缓存是否存在**，若是直接返回，若否继续执行</span>
  <span class="c1">// 这里由于持有 eviction_lock，没有任何其他线程能够进行驱逐操作，所以</span>
  <span class="c1">// 没有任何其他线程能够改变 bufmap[key] 桶链表的结构，所以这里不事先获取</span>
  <span class="c1">// 其相应桶锁而直接开始遍历是安全的。</span>
  <span class="k">if</span><span class="p">(</span><span class="n">b</span> <span class="o">:=</span> <span class="n">look_for_blockno_in</span><span class="p">(</span><span class="n">bufmap</span><span class="p">[</span><span class="n">key</span><span class="p">]))</span> <span class="p">{</span>
    <span class="n">acquire</span><span class="p">(</span><span class="n">bufmap_locks</span><span class="p">[</span><span class="n">key</span><span class="p">]);</span> <span class="c1">// 必须获取，保护非原子操作 `refcnt++`</span>
    <span class="n">b</span><span class="o">-&gt;</span><span class="n">refcnt</span><span class="o">++</span>
    <span class="n">release</span><span class="p">(</span><span class="n">bufmap_locks</span><span class="p">[</span><span class="n">key</span><span class="p">]);</span>

    <span class="n">release</span><span class="p">(</span><span class="n">eviction_lock</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">b</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">// 缓存不存在，查找可驱逐缓存 b</span>
  
  <span class="n">holding_bucket</span> <span class="o">:=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="c1">// 当前持有的桶锁</span>
  <span class="k">for</span> <span class="n">i</span> <span class="o">:=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">NBUFMAP_BUCKET</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">acquire</span><span class="p">(</span><span class="n">bufmap_locks</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span> <span class="c1">// 请求时不持有 key 桶锁，不会出现环路等待</span>
    <span class="k">if</span><span class="p">(</span><span class="n">b</span> <span class="o">:=</span> <span class="n">look_for_least_recently_used_with_no_ref</span><span class="p">(</span><span class="n">bufmap</span><span class="p">[</span><span class="n">key</span><span class="p">]))</span> <span class="p">{</span>
      <span class="k">if</span><span class="p">(</span><span class="n">holding_bucket</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="n">release</span><span class="p">(</span><span class="n">bufmap_locks</span><span class="p">[</span><span class="n">holding_bucket</span><span class="p">]);</span>
      <span class="n">holding_bucket</span> <span class="o">:=</span> <span class="n">i</span><span class="p">;</span>
      <span class="c1">// 如果找到新的未使用时间更长的空闲块，则将原来的块所属桶的锁释放掉，保持新块所属桶的锁...</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="n">release</span><span class="p">(</span><span class="n">bufmap_locks</span><span class="p">[</span><span class="n">holding_bucket</span><span class="p">]);</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="n">acquire</span><span class="p">(</span><span class="n">bufmap_locks</span><span class="p">[</span><span class="n">key</span><span class="p">]);</span> <span class="c1">// 再次获取 key 桶锁</span>
  <span class="n">append</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">bucket</span><span class="p">[</span><span class="n">key</span><span class="p">]);</span>     <span class="c1">// 将 b 加入到新的桶</span>
  <span class="n">release</span><span class="p">(</span><span class="n">bufmap_locks</span><span class="p">[</span><span class="n">key</span><span class="p">]);</span> <span class="c1">// 释放 key 桶锁</span>

  <span class="n">release</span><span class="p">(</span><span class="n">eviction_lock</span><span class="p">);</span>     <span class="c1">// 释放驱逐锁</span>

  <span class="c1">// 设置 b 的各个属性</span>
  <span class="n">setup</span><span class="p">(</span><span class="n">b</span><span class="p">);</span>
  <span class="k">return</span> <span class="n">b</span><span class="p">;</span>
<span class="p">}</span>

</pre></table></code></div></div><h3 id="完整代码"><span class="mr-2">完整代码</span><a href="#完整代码" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre><span class="k">struct</span> <span class="n">buf</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">valid</span><span class="p">;</span>   <span class="c1">// has data been read from disk?</span>
  <span class="kt">int</span> <span class="n">disk</span><span class="p">;</span>    <span class="c1">// does disk "own" buf?</span>
  <span class="n">uint</span> <span class="n">dev</span><span class="p">;</span>
  <span class="n">uint</span> <span class="n">blockno</span><span class="p">;</span>
  <span class="k">struct</span> <span class="n">sleeplock</span> <span class="n">lock</span><span class="p">;</span>
  <span class="n">uint</span> <span class="n">refcnt</span><span class="p">;</span>
  <span class="n">uint</span> <span class="n">lastuse</span><span class="p">;</span> <span class="c1">// *newly added, used to keep track of the least-recently-used buf</span>
  <span class="k">struct</span> <span class="n">buf</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
  <span class="n">uchar</span> <span class="n">data</span><span class="p">[</span><span class="n">BSIZE</span><span class="p">];</span>
<span class="p">};</span>
</pre></table></code></div></div><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
152
153
154
155
156
157
158
159
160
161
162
163
164
165
166
167
168
169
170
171
172
173
174
175
176
177
178
179
180
181
182
183
184
185
186
187
188
</pre><td class="rouge-code"><pre><span class="c1">// kernel/bio.c</span>

<span class="c1">// bucket number for bufmap</span>
<span class="cp">#define NBUFMAP_BUCKET 13
</span><span class="c1">// hash function for bufmap</span>
<span class="cp">#define BUFMAP_HASH(dev, blockno) ((((dev)&lt;&lt;27)|(blockno))%NBUFMAP_BUCKET)
</span>
<span class="k">struct</span> <span class="p">{</span>
  <span class="k">struct</span> <span class="n">buf</span> <span class="n">buf</span><span class="p">[</span><span class="n">NBUF</span><span class="p">];</span>
  <span class="k">struct</span> <span class="n">spinlock</span> <span class="n">eviction_lock</span><span class="p">;</span>

  <span class="c1">// Hash map: dev and blockno to buf</span>
  <span class="k">struct</span> <span class="n">buf</span> <span class="n">bufmap</span><span class="p">[</span><span class="n">NBUFMAP_BUCKET</span><span class="p">];</span>
  <span class="k">struct</span> <span class="n">spinlock</span> <span class="n">bufmap_locks</span><span class="p">[</span><span class="n">NBUFMAP_BUCKET</span><span class="p">];</span>
<span class="p">}</span> <span class="n">bcache</span><span class="p">;</span>

<span class="kt">void</span>
<span class="nf">binit</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
  <span class="c1">// Initialize bufmap</span>
  <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">NBUFMAP_BUCKET</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">initlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bcache</span><span class="p">.</span><span class="n">bufmap_locks</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="s">"bcache_bufmap"</span><span class="p">);</span>
    <span class="n">bcache</span><span class="p">.</span><span class="n">bufmap</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">next</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">// Initialize buffers</span>
  <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">NBUF</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">){</span>
    <span class="k">struct</span> <span class="n">buf</span> <span class="o">*</span><span class="n">b</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">bcache</span><span class="p">.</span><span class="n">buf</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
    <span class="n">initsleeplock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="s">"buffer"</span><span class="p">);</span>
    <span class="n">b</span><span class="o">-&gt;</span><span class="n">lastuse</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">b</span><span class="o">-&gt;</span><span class="n">refcnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="c1">// put all the buffers into bufmap[0]</span>
    <span class="n">b</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">bcache</span><span class="p">.</span><span class="n">bufmap</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">next</span><span class="p">;</span>
    <span class="n">bcache</span><span class="p">.</span><span class="n">bufmap</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">next</span> <span class="o">=</span> <span class="n">b</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="n">initlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bcache</span><span class="p">.</span><span class="n">eviction_lock</span><span class="p">,</span> <span class="s">"bcache_eviction"</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// Look through buffer cache for block on device dev.</span>
<span class="c1">// If not found, allocate a buffer.</span>
<span class="c1">// In either case, return locked buffer.</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">buf</span><span class="o">*</span>
<span class="nf">bget</span><span class="p">(</span><span class="n">uint</span> <span class="n">dev</span><span class="p">,</span> <span class="n">uint</span> <span class="n">blockno</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">struct</span> <span class="n">buf</span> <span class="o">*</span><span class="n">b</span><span class="p">;</span>

  <span class="n">uint</span> <span class="n">key</span> <span class="o">=</span> <span class="n">BUFMAP_HASH</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">blockno</span><span class="p">);</span>

  <span class="n">acquire</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bcache</span><span class="p">.</span><span class="n">bufmap_locks</span><span class="p">[</span><span class="n">key</span><span class="p">]);</span>

  <span class="c1">// Is the block already cached?</span>
  <span class="k">for</span><span class="p">(</span><span class="n">b</span> <span class="o">=</span> <span class="n">bcache</span><span class="p">.</span><span class="n">bufmap</span><span class="p">[</span><span class="n">key</span><span class="p">].</span><span class="n">next</span><span class="p">;</span> <span class="n">b</span><span class="p">;</span> <span class="n">b</span> <span class="o">=</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">){</span>
    <span class="k">if</span><span class="p">(</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">==</span> <span class="n">dev</span> <span class="o">&amp;&amp;</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">blockno</span> <span class="o">==</span> <span class="n">blockno</span><span class="p">){</span>
      <span class="n">b</span><span class="o">-&gt;</span><span class="n">refcnt</span><span class="o">++</span><span class="p">;</span>
      <span class="n">release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bcache</span><span class="p">.</span><span class="n">bufmap_locks</span><span class="p">[</span><span class="n">key</span><span class="p">]);</span>
      <span class="n">acquiresleep</span><span class="p">(</span><span class="o">&amp;</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
      <span class="k">return</span> <span class="n">b</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="c1">// Not cached.</span>

  <span class="c1">// to get a suitable block to reuse, we need to search for one in all the buckets,</span>
  <span class="c1">// which means acquiring their bucket locks.</span>
  <span class="c1">// but it's not safe to try to acquire every single bucket lock while holding one.</span>
  <span class="c1">// it can easily lead to circular wait, which produces deadlock.</span>

  <span class="n">release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bcache</span><span class="p">.</span><span class="n">bufmap_locks</span><span class="p">[</span><span class="n">key</span><span class="p">]);</span>
  <span class="c1">// we need to release our bucket lock so that iterating through all the buckets won't</span>
  <span class="c1">// lead to circular wait and deadlock. however, as a side effect of releasing our bucket</span>
  <span class="c1">// lock, other cpus might request the same blockno at the same time and the cache buf for  </span>
  <span class="c1">// blockno might be created multiple times in the worst case. since multiple concurrent</span>
  <span class="c1">// bget requests might pass the "Is the block already cached?" test and start the </span>
  <span class="c1">// eviction &amp; reuse process multiple times for the same blockno.</span>
  <span class="c1">//</span>
  <span class="c1">// so, after acquiring eviction_lock, we check "whether cache for blockno is present"</span>
  <span class="c1">// once more, to be sure that we don't create duplicate cache bufs.</span>
  <span class="n">acquire</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bcache</span><span class="p">.</span><span class="n">eviction_lock</span><span class="p">);</span>

  <span class="c1">// Check again, is the block already cached?</span>
  <span class="c1">// no other eviction &amp; reuse will happen while we are holding eviction_lock,</span>
  <span class="c1">// which means no link list structure of any bucket can change.</span>
  <span class="c1">// so it's ok here to iterate through `bcache.bufmap[key]` without holding</span>
  <span class="c1">// it's cooresponding bucket lock, since we are holding a much stronger eviction_lock.</span>
  <span class="k">for</span><span class="p">(</span><span class="n">b</span> <span class="o">=</span> <span class="n">bcache</span><span class="p">.</span><span class="n">bufmap</span><span class="p">[</span><span class="n">key</span><span class="p">].</span><span class="n">next</span><span class="p">;</span> <span class="n">b</span><span class="p">;</span> <span class="n">b</span> <span class="o">=</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">){</span>
    <span class="k">if</span><span class="p">(</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">==</span> <span class="n">dev</span> <span class="o">&amp;&amp;</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">blockno</span> <span class="o">==</span> <span class="n">blockno</span><span class="p">){</span>
      <span class="n">acquire</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bcache</span><span class="p">.</span><span class="n">bufmap_locks</span><span class="p">[</span><span class="n">key</span><span class="p">]);</span> <span class="c1">// must do, for `refcnt++`</span>
      <span class="n">b</span><span class="o">-&gt;</span><span class="n">refcnt</span><span class="o">++</span><span class="p">;</span>
      <span class="n">release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bcache</span><span class="p">.</span><span class="n">bufmap_locks</span><span class="p">[</span><span class="n">key</span><span class="p">]);</span>
      <span class="n">release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bcache</span><span class="p">.</span><span class="n">eviction_lock</span><span class="p">);</span>
      <span class="n">acquiresleep</span><span class="p">(</span><span class="o">&amp;</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
      <span class="k">return</span> <span class="n">b</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="c1">// Still not cached.</span>
  <span class="c1">// we are now only holding eviction lock, none of the bucket locks are held by us.</span>
  <span class="c1">// so it's now safe to acquire any bucket's lock without risking circular wait and deadlock.</span>

  <span class="c1">// find the one least-recently-used buf among all buckets.</span>
  <span class="c1">// finish with it's corresponding bucket's lock held.</span>
  <span class="k">struct</span> <span class="n">buf</span> <span class="o">*</span><span class="n">before_least</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> 
  <span class="n">uint</span> <span class="n">holding_bucket</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
  <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">NBUFMAP_BUCKET</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
    <span class="c1">// before acquiring, we are either holding nothing, or only holding locks of</span>
    <span class="c1">// buckets that are *on the left side* of the current bucket</span>
    <span class="c1">// so no circular wait can ever happen here. (safe from deadlock)</span>
    <span class="n">acquire</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bcache</span><span class="p">.</span><span class="n">bufmap_locks</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
    <span class="kt">int</span> <span class="n">newfound</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// new least-recently-used buf found in this bucket</span>
    <span class="k">for</span><span class="p">(</span><span class="n">b</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">bcache</span><span class="p">.</span><span class="n">bufmap</span><span class="p">[</span><span class="n">i</span><span class="p">];</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span> <span class="n">b</span> <span class="o">=</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span><span class="p">(</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">refcnt</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="o">!</span><span class="n">before_least</span> <span class="o">||</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">lastuse</span> <span class="o">&lt;</span> <span class="n">before_least</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">lastuse</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">before_least</span> <span class="o">=</span> <span class="n">b</span><span class="p">;</span>
        <span class="n">newfound</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">newfound</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bcache</span><span class="p">.</span><span class="n">bufmap_locks</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="k">if</span><span class="p">(</span><span class="n">holding_bucket</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="n">release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bcache</span><span class="p">.</span><span class="n">bufmap_locks</span><span class="p">[</span><span class="n">holding_bucket</span><span class="p">]);</span>
      <span class="n">holding_bucket</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
      <span class="c1">// keep holding this bucket's lock....</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">before_least</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">panic</span><span class="p">(</span><span class="s">"bget: no buffers"</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="n">b</span> <span class="o">=</span> <span class="n">before_least</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
  
  <span class="k">if</span><span class="p">(</span><span class="n">holding_bucket</span> <span class="o">!=</span> <span class="n">key</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// remove the buf from it's original bucket</span>
    <span class="n">before_least</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
    <span class="n">release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bcache</span><span class="p">.</span><span class="n">bufmap_locks</span><span class="p">[</span><span class="n">holding_bucket</span><span class="p">]);</span>
    <span class="c1">// rehash and add it to the target bucket</span>
    <span class="n">acquire</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bcache</span><span class="p">.</span><span class="n">bufmap_locks</span><span class="p">[</span><span class="n">key</span><span class="p">]);</span>
    <span class="n">b</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">bcache</span><span class="p">.</span><span class="n">bufmap</span><span class="p">[</span><span class="n">key</span><span class="p">].</span><span class="n">next</span><span class="p">;</span>
    <span class="n">bcache</span><span class="p">.</span><span class="n">bufmap</span><span class="p">[</span><span class="n">key</span><span class="p">].</span><span class="n">next</span> <span class="o">=</span> <span class="n">b</span><span class="p">;</span>
  <span class="p">}</span>
  
  <span class="n">b</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">=</span> <span class="n">dev</span><span class="p">;</span>
  <span class="n">b</span><span class="o">-&gt;</span><span class="n">blockno</span> <span class="o">=</span> <span class="n">blockno</span><span class="p">;</span>
  <span class="n">b</span><span class="o">-&gt;</span><span class="n">refcnt</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="n">b</span><span class="o">-&gt;</span><span class="n">valid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="n">release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bcache</span><span class="p">.</span><span class="n">bufmap_locks</span><span class="p">[</span><span class="n">key</span><span class="p">]);</span>
  <span class="n">release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bcache</span><span class="p">.</span><span class="n">eviction_lock</span><span class="p">);</span>
  <span class="n">acquiresleep</span><span class="p">(</span><span class="o">&amp;</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
  <span class="k">return</span> <span class="n">b</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// ......</span>

<span class="c1">// Release a locked buffer.</span>
<span class="kt">void</span>
<span class="nf">brelse</span><span class="p">(</span><span class="k">struct</span> <span class="n">buf</span> <span class="o">*</span><span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">holdingsleep</span><span class="p">(</span><span class="o">&amp;</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">))</span>
    <span class="n">panic</span><span class="p">(</span><span class="s">"brelse"</span><span class="p">);</span>

  <span class="n">releasesleep</span><span class="p">(</span><span class="o">&amp;</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

  <span class="n">uint</span> <span class="n">key</span> <span class="o">=</span> <span class="n">BUFMAP_HASH</span><span class="p">(</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">blockno</span><span class="p">);</span>

  <span class="n">acquire</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bcache</span><span class="p">.</span><span class="n">bufmap_locks</span><span class="p">[</span><span class="n">key</span><span class="p">]);</span>
  <span class="n">b</span><span class="o">-&gt;</span><span class="n">refcnt</span><span class="o">--</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">refcnt</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">b</span><span class="o">-&gt;</span><span class="n">lastuse</span> <span class="o">=</span> <span class="n">ticks</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bcache</span><span class="p">.</span><span class="n">bufmap_locks</span><span class="p">[</span><span class="n">key</span><span class="p">]);</span>
<span class="p">}</span>

<span class="kt">void</span>
<span class="nf">bpin</span><span class="p">(</span><span class="k">struct</span> <span class="n">buf</span> <span class="o">*</span><span class="n">b</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">uint</span> <span class="n">key</span> <span class="o">=</span> <span class="n">BUFMAP_HASH</span><span class="p">(</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">blockno</span><span class="p">);</span>

  <span class="n">acquire</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bcache</span><span class="p">.</span><span class="n">bufmap_locks</span><span class="p">[</span><span class="n">key</span><span class="p">]);</span>
  <span class="n">b</span><span class="o">-&gt;</span><span class="n">refcnt</span><span class="o">++</span><span class="p">;</span>
  <span class="n">release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bcache</span><span class="p">.</span><span class="n">bufmap_locks</span><span class="p">[</span><span class="n">key</span><span class="p">]);</span>
<span class="p">}</span>

<span class="kt">void</span>
<span class="nf">bunpin</span><span class="p">(</span><span class="k">struct</span> <span class="n">buf</span> <span class="o">*</span><span class="n">b</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">uint</span> <span class="n">key</span> <span class="o">=</span> <span class="n">BUFMAP_HASH</span><span class="p">(</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">blockno</span><span class="p">);</span>

  <span class="n">acquire</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bcache</span><span class="p">.</span><span class="n">bufmap_locks</span><span class="p">[</span><span class="n">key</span><span class="p">]);</span>
  <span class="n">b</span><span class="o">-&gt;</span><span class="n">refcnt</span><span class="o">--</span><span class="p">;</span>
  <span class="n">release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bcache</span><span class="p">.</span><span class="n">bufmap_locks</span><span class="p">[</span><span class="n">key</span><span class="p">]);</span>
<span class="p">}</span>

</pre></table></code></div></div><h3 id="运行结果"><span class="mr-2">运行结果</span><a href="#运行结果" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><div class="language-text highlighter-rouge"><div class="code-header"> <span data-label-text="Text"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
</pre><td class="rouge-code"><pre>$ bcachetest
start test0
test0 results:
--- lock kmem/bcache stats
lock: kmem_cpu_0: #fetch-and-add 0 #acquire() 32897
lock: kmem_cpu_1: #fetch-and-add 0 #acquire() 77
lock: kmem_cpu_2: #fetch-and-add 0 #acquire() 61
lock: bcache_bufmap: #fetch-and-add 0 #acquire() 6400
lock: bcache_bufmap: #fetch-and-add 0 #acquire() 6685
lock: bcache_bufmap: #fetch-and-add 0 #acquire() 6696
lock: bcache_bufmap: #fetch-and-add 0 #acquire() 7018
lock: bcache_bufmap: #fetch-and-add 0 #acquire() 6266
lock: bcache_bufmap: #fetch-and-add 0 #acquire() 4206
lock: bcache_bufmap: #fetch-and-add 0 #acquire() 4206
lock: bcache_bufmap: #fetch-and-add 0 #acquire() 2193
lock: bcache_bufmap: #fetch-and-add 0 #acquire() 4202
lock: bcache_bufmap: #fetch-and-add 0 #acquire() 2196
lock: bcache_bufmap: #fetch-and-add 0 #acquire() 4359
lock: bcache_bufmap: #fetch-and-add 0 #acquire() 4409
lock: bcache_bufmap: #fetch-and-add 0 #acquire() 6411
lock: bcache_eviction: #fetch-and-add 0 #acquire() 83
--- top 5 contended locks:
lock: proc: #fetch-and-add 397110 #acquire() 70988
lock: proc: #fetch-and-add 262715 #acquire() 70988
lock: proc: #fetch-and-add 222165 #acquire() 70987
lock: virtio_disk: #fetch-and-add 161088 #acquire() 1098
lock: proc: #fetch-and-add 45459 #acquire() 71331
tot= 0
test0: OK
start test1
test1 OK
$
</pre></table></code></div></div><h2 id="小结"><span class="mr-2">小结</span><a href="#小结" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>多线程问题往往不如单线程程序中的问题那样容易发现，并且需要对底层指令层面以及 CPU 运行原理层面有足够的认知，才能有效地发现并解决多线程问题。引用 lecture 中的几个建议作为结尾：</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre>don't share if you don't have to
start with a few coarse-grained locks
instrument your code -- which locks are preventing parallelism?
use fine-grained locks only as needed for parallel performance
use an automated race detector
</pre></table></code></div></div><p>最后我自己的话：</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre>multithreading is a pain😭 , only worth it if there is non-insignificant performance increase. 

maybe try multi-process architecture for your next project, so you don't have to deal with all the multithreading hassles. you get the bonus of being able to scale horizontally (and almost infinitely) as well :)
</pre></table></code></div></div><h2 id="update-2021-01-07"><span class="mr-2">update 2021-01-07</span><a href="#update-2021-01-07" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>补充一下各个锁的作用：</p><ul><li>拿着 bufmap_locks[key] 锁的时候，代表key桶这一个桶中的链表结构、以及所有链表节点的 refcnt 都不会被其他线程改变。也就是说，如果想访问/修改一个桶的结构，或者桶内任意节点的 refcnt，必须先拿那个桶 key 对应的 bufmap_locks[key] 锁。 （理由：1.只有 eviction 会改变某个桶的链表结构，而 eviction 本身也会尝试获取该锁 bufmap_locks[key]，所以只要占有该锁，涉及该桶的 eviction 就不会进行，也就代表该桶链表结构不会被改变；2.所有修改某个节点 refcnt 的操作都会先获取其对应的桶锁 bufmap_locks[key]，所以只要占有该锁，桶内所有节点的 refcnt 就不会改变。）<li>拿着 eviction_lock 的时候，代表不会有其他线程可以进行驱逐操作。由于只有 eviction 可以改变桶的链表结构，拿着该锁，也就意味着<strong>整个哈希表</strong>中的<strong>所有桶</strong>的<strong>链表结构</strong>都不会被改变，但<strong>不保证链表内节点的refcnt不会改变</strong>。也就是说，拿着 eviction_lock 的时候，refcnt 依然可能会因为多线程导致不一致，但是可以保证拿着锁的整个过程中，每个桶的链表节点数量不会增加、减少，也不会改变顺序。所以拿着 eviction_lock 的时候，可以安全遍历每个桶的每个节点，但是<strong>不能访问 refcnt</strong>。如果遍历的时候需要访问某个 buf 的 refcnt，则需要另外再拿其所在桶的 bufmap_locks[key] 锁。</ul><p>更简短地讲：</p><ul><li>bufmap_locks 保护单个桶的链表结构，以及桶内所有节点的 refcnt<li>eviction_lock 保护所有桶的链表结构，但是不保护任何 refcnt</ul><p>驱逐过程中，首先需要拿 eviction_lock，使得可以遍历所有桶的链表结构。然后遍历链表结构寻找可驱逐块的时候，由于在某个桶i中判断是否有可驱逐块的过程需要读取 refcnt，所以需要再拿该桶的 bufmap_locks[i]。</p><p>Tricky的地方就是，bget 方法一开始判断块是否在缓存中时也获取了一个桶的 bufmap_locks[key]，此时如果遍历获取所有桶的 bufmap_locks[i] 的话，很容易引起环路等待而触发死锁。若在判断是否存在后立刻释放掉 bufmap_locks[key] 再拿 eviction_lock 的话，又会导致在释放桶锁和拿 eviction_lock 这两个操作中间的微小间隙，其他线程可能会对同一个块号进行 bget 访问，导致最终同一个块被插入两次。</p><p>博客后半部分都是在讲我是如何（尝试）解决这一问题的。</p><p>最终方案是在释放 bufmap_locks[key]，获取 eviction_lock 之后，再判断一次目标块号是否已经插入。这意味着依然会出现 bget 尝试对同一个 blockno 进行驱逐并插入两次的情况，但是能够保证除了第一个驱逐+插入的尝试能成功外，后续的尝试都不会导致重复驱逐+重复插入，而是能正确返回第一个成功的驱逐+插入产生的结果。也就是<strong>允许竞态条件的发生，但是对其进行检测</strong>，可以理解为一种乐观锁 optimistic locking。</p></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/course-notes/'>Course Notes</a>, <a href='/categories/mit6-s081/'>MIT6.S081</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/operating-system/" class="post-tag no-text-decoration" >operating system</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=%5Bmit6.s081%5D+%E7%AC%94%E8%AE%B0+Lab8%3A+Locks+%7C+%E9%94%81%E4%BC%98%E5%8C%96+-+Miigon%27s+blog&url=https%3A%2F%2Fblog.miigon.net%2Fposts%2Fs081-lab8-locks%2F" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=%5Bmit6.s081%5D+%E7%AC%94%E8%AE%B0+Lab8%3A+Locks+%7C+%E9%94%81%E4%BC%98%E5%8C%96+-+Miigon%27s+blog&u=https%3A%2F%2Fblog.miigon.net%2Fposts%2Fs081-lab8-locks%2F" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://t.me/share/url?url=https%3A%2F%2Fblog.miigon.net%2Fposts%2Fs081-lab8-locks%2F&text=%5Bmit6.s081%5D+%E7%AC%94%E8%AE%B0+Lab8%3A+Locks+%7C+%E9%94%81%E4%BC%98%E5%8C%96+-+Miigon%27s+blog" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i id="copy-link" class="fa-fw fas fa-link small" data-toggle="tooltip" data-placement="top" title="Copy link" data-title-succeed="Link copied successfully!"> </i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted"><div class="access"><div id="access-lastmod" class="post"><div class="panel-heading">Recently Updated</div><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/storing-hash-objects-on-filesystem/">[随笔]文件系统上存储哈希对象：哈希算法以及目录结构对性能的影响</a><li><a href="/posts/origin-of-git-feat-bitkeeper/">git的前世，和BitKeeper</a><li><a href="/posts/golang-loop-var-reference-problems-and-semantic-fix/">随笔：Golang 循环变量引用问题以及官方语义修复</a><li><a href="/posts/s081-lab6-copy-on-write-fork/">[mit6.s081] 笔记 Lab6: Copy-on-write fork | fork 懒拷贝</a><li><a href="/posts/mysql-prepare-slower-query-bug-analyze/">MySQL Prepare后语句查询性能降低 内核源码bug排查分析</a></ul></div><div id="access-tags"><div class="panel-heading">Trending Tags</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/operating-system/">operating system</a> <a class="post-tag" href="/tags/chinese/">Chinese</a> <a class="post-tag" href="/tags/system-design/">system design</a> <a class="post-tag" href="/tags/c/">C++</a> <a class="post-tag" href="/tags/course-recommendation/">course recommendation</a> <a class="post-tag" href="/tags/grpc/">gRPC</a> <a class="post-tag" href="/tags/translated/">translated</a> <a class="post-tag" href="/tags/announcement/">announcement</a> <a class="post-tag" href="/tags/c-standard/">c++ standard</a> <a class="post-tag" href="/tags/computer-system/">computer system</a></div></div><div id="access-links" class="post"><div class="panel-heading">Links</div><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="http://0xffff.one">0xffff.one 搬砖技术社区</a><li><a href="https://blog.izgq.net">ZGQ's Blog</a></ul></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"><div class="panel-heading pl-3 pt-2 mb-2">Contents</div><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div id="tail-wrapper" class="col-12 col-lg-11 col-xl-9 pl-3 pr-3 pr-xl-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/s081-lab1-unix-utilities/"><div class="card-body"> <em class="small" data-ts="1631005200" data-df="ll" > Sep 7, 2021 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>[mit6.s081] 笔记 Lab1: Unix utilities | Unix 实用工具</h3><div class="text-muted small"><p> 这是我自学 MIT6.S081 操作系统课程的 lab 代码笔记第一篇：Unix utilities。此 lab 大致耗时：4小时。 课程地址：https://pdos.csail.mit.edu/6.S081/2020/schedule.html Lab 地址：https://pdos.csail.mit.edu/6.S081/2020/labs/util.html 我的代码地...</p></div></div></a></div><div class="card"> <a href="/posts/s081-lab2-system-calls/"><div class="card-body"> <em class="small" data-ts="1631185200" data-df="ll" > Sep 9, 2021 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>[mit6.s081] 笔记 Lab2: System calls | 系统调用</h3><div class="text-muted small"><p> 这是我自学 MIT6.S081 操作系统课程的 lab 代码笔记第二篇：System calls。此 lab 大致耗时：4小时。 课程地址：https://pdos.csail.mit.edu/6.S081/2020/schedule.html Lab 地址：https://pdos.csail.mit.edu/6.S081/2020/labs/syscall.html 我的代码...</p></div></div></a></div><div class="card"> <a href="/posts/s081-lab3-page-tables/"><div class="card-body"> <em class="small" data-ts="1631790000" data-df="ll" > Sep 16, 2021 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>[mit6.s081] 笔记 Lab3: Page tables | 页表</h3><div class="text-muted small"><p> 这是我自学 MIT6.S081 操作系统课程的 lab 代码笔记第三篇：Page tables。此 lab 大致耗时：19小时。 课程地址：https://pdos.csail.mit.edu/6.S081/2020/schedule.html Lab 地址：https://pdos.csail.mit.edu/6.S081/2020/labs/pgtbl.html 我的代码地址...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/s081-lab7-multithreading/" class="btn btn-outline-primary" prompt="Older"><p>[mit6.s081] 笔记 Lab7: Multithreading | 多线程</p></a> <a href="/posts/s081-lab9-file-system/" class="btn btn-outline-primary" prompt="Newer"><p>[mit6.s081] 笔记 Lab9: File System | 文件系统</p></a></div><script type="text/javascript"> $(function () { const origin = "https://giscus.app"; const iframe = "iframe.giscus-frame"; const lightTheme = "light"; const darkTheme = "dark_dimmed"; let initTheme = lightTheme; if ($("html[data-mode=dark]").length > 0 || ($("html[data-mode]").length == 0 && window.matchMedia("(prefers-color-scheme: dark)").matches)) { initTheme = darkTheme; } let giscusAttributes = { "src": "https://giscus.app/client.js", "data-repo": "Miigon/blog", "data-repo-id": "MDEwOlJlcG9zaXRvcnkzMjI1MjkwNzA=", "data-category": "BlogComments", "data-category-id": "DIC_kwDOEzlnLs4CQ6Y4", "data-mapping": "pathname", "data-reactions-enabled": "1", "data-emit-metadata": "0", "data-theme": initTheme, "data-input-position": "top", "data-lang": "en", "crossorigin": "anonymous", "async": "" }; let giscusScript = document.createElement("script"); Object.entries(giscusAttributes).forEach(([key, value]) => giscusScript.setAttribute(key, value)); document.getElementById("tail-wrapper").prepend(giscusScript); addEventListener("message", (event) => { if (event.source === window && event.data && event.data.direction === ModeToggle.ID) { /* global theme mode changed */ const mode = event.data.message; const theme = (mode === ModeToggle.DARK_MODE ? darkTheme : lightTheme); const message = { setConfig: { theme: theme } }; const giscus = document.querySelector(iframe).contentWindow; giscus.postMessage({ giscus: message }, origin); } }); }); </script></div></div><footer class="row pl-3 pr-3"><div class="col-12 d-flex justify-content-between align-items-center text-muted pl-0 pr-0"><div class="footer-left"><p class="mb-0"> © 2023 <a href="https://github.com/Miigon">Miigon</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Customized Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><div id="access-tags"><div class="panel-heading">Trending Tags</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/operating-system/">operating system</a> <a class="post-tag" href="/tags/chinese/">Chinese</a> <a class="post-tag" href="/tags/system-design/">system design</a> <a class="post-tag" href="/tags/c/">C++</a> <a class="post-tag" href="/tags/course-recommendation/">course recommendation</a> <a class="post-tag" href="/tags/grpc/">gRPC</a> <a class="post-tag" href="/tags/translated/">translated</a> <a class="post-tag" href="/tags/announcement/">announcement</a> <a class="post-tag" href="/tags/c-standard/">c++ standard</a> <a class="post-tag" href="/tags/computer-system/">computer system</a></div></div></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a><div id="notification" class="toast" role="alert" aria-live="assertive" aria-atomic="true" data-animation="true" data-autohide="false"><div class="toast-header"> <button type="button" class="ml-2 ml-auto close" data-dismiss="toast" aria-label="Close"> <span aria-hidden="true">&times;</span> </button></div><div class="toast-body text-center pt-0"><p class="pl-2 pr-2 mb-3">A new version of content is available.</p><button type="button" class="btn btn-primary" aria-label="Update"> Update </button></div></div><script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No results found.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/magnific-popup@1/dist/jquery.magnific-popup.min.js,npm/lozad/dist/lozad.min.js,npm/clipboard@2/dist/clipboard.min.js"></script> <script src="https://cdn.jsdelivr.net/combine/npm/dayjs@1/dayjs.min.js,npm/dayjs@1/locale/en.min.js,npm/dayjs@1/plugin/relativeTime.min.js,npm/dayjs@1/plugin/localizedFormat.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.bundle.min.js"></script> <script defer src="/app.js"></script>
