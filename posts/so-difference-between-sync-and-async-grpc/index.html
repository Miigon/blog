<!DOCTYPE html><html lang="en" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="generator" content="Jekyll v4.2.2" /><meta property="og:title" content="[StackOverflow] Difference between synchronous and asynchorous gRPC API" /><meta property="og:locale" content="en" /><meta name="description" content="This is from one of my answers on StackOverflow. Original question: I am working on a service based on gRPC, which requires high throughput. But currently my program suffers low throughput when using C++ synchronous gRPC. I’ve read through gRPC documentations, but don’t find explicit explanation on the difference between sync/async APIs. Except async has control over completion queue, while it’s transparent to sync APIs. I want to know whether synchronous gRPC sends messages to TCP layer, and wait for its “ack”, thus the next message would be blocked? Meanwhile async APIs would send them asynchronously without latter messages waiting?" /><meta property="og:description" content="This is from one of my answers on StackOverflow. Original question: I am working on a service based on gRPC, which requires high throughput. But currently my program suffers low throughput when using C++ synchronous gRPC. I’ve read through gRPC documentations, but don’t find explicit explanation on the difference between sync/async APIs. Except async has control over completion queue, while it’s transparent to sync APIs. I want to know whether synchronous gRPC sends messages to TCP layer, and wait for its “ack”, thus the next message would be blocked? Meanwhile async APIs would send them asynchronously without latter messages waiting?" /><link rel="canonical" href="https://blog.miigon.net/posts/so-difference-between-sync-and-async-grpc/" /><meta property="og:url" content="https://blog.miigon.net/posts/so-difference-between-sync-and-async-grpc/" /><meta property="og:site_name" content="Miigon’s blog" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2021-08-20T23:09:00+08:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="[StackOverflow] Difference between synchronous and asynchorous gRPC API" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2021-09-07T11:26:02+08:00","datePublished":"2021-08-20T23:09:00+08:00","description":"This is from one of my answers on StackOverflow. Original question: I am working on a service based on gRPC, which requires high throughput. But currently my program suffers low throughput when using C++ synchronous gRPC. I’ve read through gRPC documentations, but don’t find explicit explanation on the difference between sync/async APIs. Except async has control over completion queue, while it’s transparent to sync APIs. I want to know whether synchronous gRPC sends messages to TCP layer, and wait for its “ack”, thus the next message would be blocked? Meanwhile async APIs would send them asynchronously without latter messages waiting?","headline":"[StackOverflow] Difference between synchronous and asynchorous gRPC API","mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.miigon.net/posts/so-difference-between-sync-and-async-grpc/"},"url":"https://blog.miigon.net/posts/so-difference-between-sync-and-async-grpc/"}</script><title>[StackOverflow] Difference between synchronous and asynchorous gRPC API | Miigon's blog</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="Miigon's blog"><meta name="application-name" content="Miigon's blog"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link rel="dns-prefetch" href="https://fonts.gstatic.com" crossorigin><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://cdn.jsdelivr.net" ><link rel="dns-prefetch" href="https://cdn.jsdelivr.net" ><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Lato&family=Source+Sans+Pro:wght@400;600;700;900&display=swap"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get MODE_ATTR() { return "data-mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } static get ID() { return "mode-toggle"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } let self = this; /* always follow the system prefers */ this.sysDarkPrefers.addEventListener("change", () => { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.notify(); }); } /* constructor() */ get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode === ModeToggle.DARK_MODE; } get isLightMode() { return this.mode === ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer)) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } setDark() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_ATTR); sessionStorage.removeItem(ModeToggle.MODE_KEY); } /* Notify another plugins that the theme mode has changed */ notify() { window.postMessage({ direction: ModeToggle.ID, message: this.modeStatus }, "*"); } } /* ModeToggle */ const toggle = new ModeToggle(); function flipMode() { if (toggle.hasMode) { if (toggle.isSysDarkPrefer) { if (toggle.isLightMode) { toggle.clearMode(); } else { toggle.setLight(); } } else { if (toggle.isDarkMode) { toggle.clearMode(); } else { toggle.setDark(); } } } else { if (toggle.isSysDarkPrefer) { toggle.setLight(); } else { toggle.setDark(); } } toggle.notify(); } /* flipMode() */ </script><body data-spy="scroll" data-target="#toc" data-topbar-visible="true"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" class="mx-auto"> <img src="/assets/img/avatar.png" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">Miigon's blog</a></div><div class="site-subtitle font-italic">My ideas, thoughts and experiences</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tag ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info-circle ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center align-items-center"> <button class="mode-toggle btn" aria-label="Switch Mode"> <i class="fas fa-adjust"></i> </button> <span class="icon-border"></span> <a href="https://github.com/Miigon" aria-label="github" target="_blank" rel="noopener"> <i class="fab fa-github-alt"></i> </a> <a href="https://twitter.com/" aria-label="twitter" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['miigon.pg','gmail.com'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="https://stackoverflow.com/users/7509248/miigon" aria-label="stack-overflow" target="_blank" rel="noopener"> <i class="fab fa-stack-overflow"></i> </a></div></div><div id="topbar-wrapper"><div id="topbar" class="container d-flex align-items-center justify-content-between h-100 pl-3 pr-3 pl-md-4 pr-md-4"> <span id="breadcrumb"> <span> <a href="/"> Home </a> </span> <span>[StackOverflow] Difference between synchronous and asynchorous gRPC API</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..."> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper" class="d-flex justify-content-center"><div id="main" class="container pl-xl-4 pr-xl-4"><div class="row"><div id="core-wrapper" class="col-12 col-lg-11 col-xl-9 pr-xl-4"><div class="post pl-1 pr-1 pl-md-2 pr-md-2"><h1 data-toc-skip>[StackOverflow] Difference between synchronous and asynchorous gRPC API</h1><div class="post-meta text-muted"> <span> Posted <em class="" data-ts="1629472140" data-df="ll" data-toggle="tooltip" data-placement="bottom"> Aug 20, 2021 </em> </span> <span> Updated <em class="" data-ts="1630985162" data-df="ll" data-toggle="tooltip" data-placement="bottom"> Sep 7, 2021 </em> </span><div class="d-flex justify-content-between"> <span> By <em> <a href="https://github.com/Miigon">Miigon</a> </em> </span><div> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="1525 words"> <em>8 min</em> read</span></div></div></div><div class="post-content"><blockquote><hr /><p>This is from <a href="https://stackoverflow.com/a/68771426/7509248">one of my answers on StackOverflow</a>.</p><h2 id="original-question"><span class="mr-2">Original question:</span><a href="#original-question" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>I am working on a service based on gRPC, which requires high throughput. But currently my program suffers low throughput when using C++ synchronous gRPC.</p><p>I’ve read through gRPC documentations, but don’t find explicit explanation on the difference between sync/async APIs. Except async has control over completion queue, while it’s transparent to sync APIs.</p><p>I want to know whether synchronous gRPC sends messages to TCP layer, and wait for its “ack”, thus the next message would be blocked? Meanwhile async APIs would send them asynchronously without latter messages waiting?</p></blockquote><p><strong>TLDR: Yes, async APIs would send the messages asynchronously without latter messages waiting, while synchronous APIs will block the whole thread while one message is being sent/received.</strong></p><p>gRPC uses <a href="https://grpc.github.io/grpc/cpp/classgrpc_1_1_completion_queue.html">CompletionQueue</a> for it’s asynchronous operations. You can find the official tutorial here: https://grpc.io/docs/languages/cpp/async/</p><p>CompletionQueue is an event queue. “event” here can be the completion of a request data reception or the expiry of an alarm(timer), etc. (basically, the completion of any asynchronous operation.)</p><p>Using <a href="https://github.com/grpc/grpc/blob/v1.38.0/examples/cpp/helloworld/greeter_async_server.cc">the official gRPC asynchronous APIs example</a> as example, focus on the <code class="language-plaintext highlighter-rouge">CallData</code> class and <code class="language-plaintext highlighter-rouge">HandleRpcs()</code>:</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre><td class="rouge-code"><pre>  <span class="kt">void</span> <span class="nf">HandleRpcs</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// Spawn a new CallData instance to serve new clients.</span>
    <span class="k">new</span> <span class="n">CallData</span><span class="p">(</span><span class="o">&amp;</span><span class="n">service_</span><span class="p">,</span> <span class="n">cq_</span><span class="p">.</span><span class="n">get</span><span class="p">());</span>
    <span class="kt">void</span><span class="o">*</span> <span class="n">tag</span><span class="p">;</span>  <span class="c1">// uniquely identifies a request.</span>
    <span class="kt">bool</span> <span class="n">ok</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span> <span class="p">{</span>
      <span class="c1">// Block waiting to read the next event from the completion queue. The</span>
      <span class="c1">// event is uniquely identified by its tag, which in this case is the</span>
      <span class="c1">// memory address of a CallData instance.</span>
      <span class="c1">// The return value of Next should always be checked. This return value</span>
      <span class="c1">// tells us whether there is any kind of event or cq_ is shutting down.</span>
      <span class="n">GPR_ASSERT</span><span class="p">(</span><span class="n">cq_</span><span class="o">-&gt;</span><span class="n">Next</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tag</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ok</span><span class="p">));</span>
      <span class="n">GPR_ASSERT</span><span class="p">(</span><span class="n">ok</span><span class="p">);</span>
      <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">CallData</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">tag</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">Proceed</span><span class="p">();</span>
    <span class="p">}</span>
  <span class="p">}</span>
</pre></table></code></div></div><p>HandleRpcs() is the main loop of the server. It’s an infinite loop which continuously gets the next event from the completion queue by using <code class="language-plaintext highlighter-rouge">cq-&gt;Next()</code> , and calls it’s <code class="language-plaintext highlighter-rouge">Proceed()</code> method (our custom method to process client request of different states).</p><p>The <code class="language-plaintext highlighter-rouge">CallData</code> class (instance of which represents a complete processing cycle of a client request):</p><div class="language-c++ highlighter-rouge"><div class="code-header"> <span data-label-text="C++"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
</pre><td class="rouge-code"><pre>  <span class="k">class</span> <span class="nc">CallData</span> <span class="p">{</span>
   <span class="nl">public:</span>
    <span class="c1">// Take in the "service" instance (in this case representing an asynchronous</span>
    <span class="c1">// server) and the completion queue "cq" used for asynchronous communication</span>
    <span class="c1">// with the gRPC runtime.</span>
    <span class="n">CallData</span><span class="p">(</span><span class="n">Greeter</span><span class="o">::</span><span class="n">AsyncService</span><span class="o">*</span> <span class="n">service</span><span class="p">,</span> <span class="n">ServerCompletionQueue</span><span class="o">*</span> <span class="n">cq</span><span class="p">)</span>
        <span class="o">:</span> <span class="n">service_</span><span class="p">(</span><span class="n">service</span><span class="p">),</span> <span class="n">cq_</span><span class="p">(</span><span class="n">cq</span><span class="p">),</span> <span class="n">responder_</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx_</span><span class="p">),</span> <span class="n">status_</span><span class="p">(</span><span class="n">CREATE</span><span class="p">)</span> <span class="p">{</span>
      <span class="c1">// Invoke the serving logic right away.</span>
      <span class="n">Proceed</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="n">Proceed</span><span class="p">()</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">status_</span> <span class="o">==</span> <span class="n">CREATE</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// Make this instance progress to the PROCESS state.</span>
        <span class="n">status_</span> <span class="o">=</span> <span class="n">PROCESS</span><span class="p">;</span>

        <span class="c1">// As part of the initial CREATE state, we *request* that the system</span>
        <span class="c1">// start processing SayHello requests. In this request, "this" acts are</span>
        <span class="c1">// the tag uniquely identifying the request (so that different CallData</span>
        <span class="c1">// instances can serve different requests concurrently), in this case</span>
        <span class="c1">// the memory address of this CallData instance.</span>
        <span class="n">service_</span><span class="o">-&gt;</span><span class="n">RequestSayHello</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx_</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">request_</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">responder_</span><span class="p">,</span> <span class="n">cq_</span><span class="p">,</span> <span class="n">cq_</span><span class="p">,</span>
                                  <span class="k">this</span><span class="p">);</span>
      <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">status_</span> <span class="o">==</span> <span class="n">PROCESS</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// Spawn a new CallData instance to serve new clients while we process</span>
        <span class="c1">// the one for this CallData. The instance will deallocate itself as</span>
        <span class="c1">// part of its FINISH state.</span>
        <span class="k">new</span> <span class="n">CallData</span><span class="p">(</span><span class="n">service_</span><span class="p">,</span> <span class="n">cq_</span><span class="p">);</span>

        <span class="c1">// The actual processing.</span>
        <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">prefix</span><span class="p">(</span><span class="s">"Hello "</span><span class="p">);</span>
        <span class="n">reply_</span><span class="p">.</span><span class="n">set_message</span><span class="p">(</span><span class="n">prefix</span> <span class="o">+</span> <span class="n">request_</span><span class="p">.</span><span class="n">name</span><span class="p">());</span>

        <span class="c1">// And we are done! Let the gRPC runtime know we've finished, using the</span>
        <span class="c1">// memory address of this instance as the uniquely identifying tag for</span>
        <span class="c1">// the event.</span>
        <span class="n">status_</span> <span class="o">=</span> <span class="n">FINISH</span><span class="p">;</span>
        <span class="n">responder_</span><span class="p">.</span><span class="n">Finish</span><span class="p">(</span><span class="n">reply_</span><span class="p">,</span> <span class="n">Status</span><span class="o">::</span><span class="n">OK</span><span class="p">,</span> <span class="k">this</span><span class="p">);</span>
      <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">GPR_ASSERT</span><span class="p">(</span><span class="n">status_</span> <span class="o">==</span> <span class="n">FINISH</span><span class="p">);</span>
        <span class="c1">// Once in the FINISH state, deallocate ourselves (CallData).</span>
        <span class="k">delete</span> <span class="k">this</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="p">}</span>

   <span class="nl">private:</span>
    <span class="c1">// The means of communication with the gRPC runtime for an asynchronous</span>
    <span class="c1">// server.</span>
    <span class="n">Greeter</span><span class="o">::</span><span class="n">AsyncService</span><span class="o">*</span> <span class="n">service_</span><span class="p">;</span>
    <span class="c1">// The producer-consumer queue where for asynchronous server notifications.</span>
    <span class="n">ServerCompletionQueue</span><span class="o">*</span> <span class="n">cq_</span><span class="p">;</span>
    <span class="c1">// Context for the rpc, allowing to tweak aspects of it such as the use</span>
    <span class="c1">// of compression, authentication, as well as to send metadata back to the</span>
    <span class="c1">// client.</span>
    <span class="n">ServerContext</span> <span class="n">ctx_</span><span class="p">;</span>

    <span class="c1">// What we get from the client.</span>
    <span class="n">HelloRequest</span> <span class="n">request_</span><span class="p">;</span>
    <span class="c1">// What we send back to the client.</span>
    <span class="n">HelloReply</span> <span class="n">reply_</span><span class="p">;</span>

    <span class="c1">// The means to get back to the client.</span>
    <span class="n">ServerAsyncResponseWriter</span><span class="o">&lt;</span><span class="n">HelloReply</span><span class="o">&gt;</span> <span class="n">responder_</span><span class="p">;</span>

    <span class="c1">// Let's implement a tiny state machine with the following states.</span>
    <span class="k">enum</span> <span class="n">CallStatus</span> <span class="p">{</span> <span class="n">CREATE</span><span class="p">,</span> <span class="n">PROCESS</span><span class="p">,</span> <span class="n">FINISH</span> <span class="p">};</span>
    <span class="n">CallStatus</span> <span class="n">status_</span><span class="p">;</span>  <span class="c1">// The current serving state.</span>
  <span class="p">};</span>
</pre></table></code></div></div><p>As we can see, a <code class="language-plaintext highlighter-rouge">CallData</code> has three states: CREATE, PROCESS and FINISH.</p><h2 id="a-request-routine-looks-like-this"><span class="mr-2">A request routine looks like this:</span><a href="#a-request-routine-looks-like-this" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><ol><li>At startup, preallocates <em>one</em> CallData for a future incoming client.<li>During the construction of that CallData object, <code class="language-plaintext highlighter-rouge">service_-&gt;RequestSayHello(&amp;ctx_, &amp;request_, &amp;responder_, cq_, cq_, this)</code> gets called, which tells gRPC to prepare for the reception of <em>exactly one</em> <code class="language-plaintext highlighter-rouge">SayHello</code> request.<br /> At this point we don’t know where the request will come from or when it will come, we are just telling gRPC that we are ready to process when one actually arrives, and let gRPC notice us when it happens.<br /> Arguments to <code class="language-plaintext highlighter-rouge">RequestSayHello</code> tells gRPC where to put the context, request body and responder of the request after receiving one, as well as which completion queue to use for the notice and what tags should be attached to the notice event (in this case, <code class="language-plaintext highlighter-rouge">this</code> is used as the tag).<li><code class="language-plaintext highlighter-rouge">HandleRpcs()</code> blocks on <code class="language-plaintext highlighter-rouge">cq-&gt;Next()</code>. Waiting for an event to occur.</ol><p><strong>some time later….</strong></p><ol><li>client makes a <code class="language-plaintext highlighter-rouge">SayHello</code> request to the server, <strong>gRPC starts receiving and decoding that request. (IO operation)</strong></ol><p><strong>some time later….</strong></p><ol><li>gRPC have finished receiving the request. It puts the request body into the <code class="language-plaintext highlighter-rouge">request_</code> field of the CallData object (via the pointer supplied earlier), then creates an event (with <code class="language-plaintext highlighter-rouge">the pointer to the CallData object</code> as tag, as asked earlier by the last argument to <code class="language-plaintext highlighter-rouge">RequestSayHello</code>). gRPC then <strong>puts that event into the completion queue <code class="language-plaintext highlighter-rouge">cq_</code></strong>.<li><strong>The loop in <code class="language-plaintext highlighter-rouge">HandleRpcs()</code> received the event</strong>(the previously blocked call to <code class="language-plaintext highlighter-rouge">cq-&gt;Next()</code> returns now), calls <code class="language-plaintext highlighter-rouge">CallData::Proceed()</code> to process the request.<li><code class="language-plaintext highlighter-rouge">status_</code> of the CallData is <code class="language-plaintext highlighter-rouge">PROCESS</code>, so it does the following:<br /> 6.1. Creates a new CallData object, so that new client requests after this one can be processed.<br /> 6.2. Generates the reply for the request, tells gRPC we have finished processing and please send the reply back to the client.<br /> 6.3 <strong>gRPC starts transmission of the reply. (IO operation)</strong><br /> 6.4 The loop in <code class="language-plaintext highlighter-rouge">HandleRpcs()</code> goes into the next iteration and blocks on <code class="language-plaintext highlighter-rouge">cq-&gt;Next()</code> again, waiting for a new event to occur.</ol><p><strong>some time later….</strong></p><ol><li>gRPC have finished transmission of the reply and tells us that by again <strong>putting an event into the completion queue</strong> with a pointer to CallData as the tag.<li><code class="language-plaintext highlighter-rouge">cq-&gt;Next()</code> <strong>receives the event and returns</strong>, <code class="language-plaintext highlighter-rouge">CallData::Proceed()</code> deallocates the CallData object (by using <code class="language-plaintext highlighter-rouge">delete this;</code>). <code class="language-plaintext highlighter-rouge">HandleRpcs()</code> loops and blocks on <code class="language-plaintext highlighter-rouge">cq-&gt;Next()</code> again, waiting for a new event.</ol><p>It might look like the process is largely the same as synchonous API, just with extra access to the completion queue. However, by doing it this way, at each and every <code class="language-plaintext highlighter-rouge">some time later....</code> (usually is waiting for IO operation to complete or waiting for a request to occur), <code class="language-plaintext highlighter-rouge">cq-&gt;Next()</code> can actually receive operation completion events not only for this request, but for other requests as well.</p><p><strong>So if a new request come in while the first request is, let’s say, waiting for the transmission of reply data to finish, <code class="language-plaintext highlighter-rouge">cq-&gt;Next()</code> will get the event emitted by the new request, and starts the processing of the new request immediately and concurrently, instead of waiting for the first request to finish its transmission.</strong></p><p>Synchonous API, on the other hand, will always wait for the <strong>full completion</strong> of one request (from start receiving to finish replying) before even starting the receiving of another one. This meant near 0% CPU utilization while receiving request body data and sending back reply data (IO operations). Precious CPU time that could have been used to process other requests are wasted on just waiting.</p><p>This is really bad since if a client with a bad internet connection (100ms round-trip) sent a request to the server, we will have to spend at least 200ms for every request from this client just on actively waiting for TCP transmission to finish. That would bring our server performance down to only ~5 requests per second.</p><p>Whereas if we are using asynchonous API, we just don’t actively wait for anything. We tell gRPC: “please send this data to the client, but we will not wait for you to finish here. Instead, just put a little letter to the completion queue when you are done, and we’ll check it later.” and move on to process other requests.</p><h1 id="related-information">Related information</h1><p>You can see how a simple server is written for both <a href="https://github.com/grpc/grpc/blob/v1.38.0/examples/cpp/helloworld/greeter_server.cc">synchronous APIs</a> and <a href="https://github.com/grpc/grpc/blob/v1.38.0/examples/cpp/helloworld/greeter_async_server.cc">asynchronous APIs</a></p><h2 id="best-performance-practices"><span class="mr-2">Best performance practices</span><a href="#best-performance-practices" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>The best performance practice suggested by the <a href="https://grpc.github.io/grpc/cpp/md_doc_cpp_perf_notes.html">gRPC C++ Performance Nodes</a> is to spawn the amount of threads equal to your CPU cores count, and use one CompletionQueue per thread.</p></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/backend/'>Backend</a>, <a href='/categories/networking/'>Networking</a>, <a href='/categories/grpc/'>gRPC</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/c/" class="post-tag no-text-decoration" >C++</a> <a href="/tags/grpc/" class="post-tag no-text-decoration" >gRPC</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=%5BStackOverflow%5D+Difference+between+synchronous+and+asynchorous+gRPC+API+-+Miigon%27s+blog&url=https%3A%2F%2Fblog.miigon.net%2Fposts%2Fso-difference-between-sync-and-async-grpc%2F" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=%5BStackOverflow%5D+Difference+between+synchronous+and+asynchorous+gRPC+API+-+Miigon%27s+blog&u=https%3A%2F%2Fblog.miigon.net%2Fposts%2Fso-difference-between-sync-and-async-grpc%2F" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://t.me/share/url?url=https%3A%2F%2Fblog.miigon.net%2Fposts%2Fso-difference-between-sync-and-async-grpc%2F&text=%5BStackOverflow%5D+Difference+between+synchronous+and+asynchorous+gRPC+API+-+Miigon%27s+blog" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i id="copy-link" class="fa-fw fas fa-link small" data-toggle="tooltip" data-placement="top" title="Copy link" data-title-succeed="Link copied successfully!"> </i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted"><div class="access"><div id="access-lastmod" class="post"><div class="panel-heading">Recently Updated</div><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/storing-hash-objects-on-filesystem/">[随笔]文件系统上存储哈希对象：哈希算法以及目录结构对性能的影响</a><li><a href="/posts/origin-of-git-feat-bitkeeper/">git的前世，和BitKeeper</a><li><a href="/posts/golang-loop-var-reference-problems-and-semantic-fix/">随笔：Golang 循环变量引用问题以及官方语义修复</a><li><a href="/posts/s081-lab6-copy-on-write-fork/">[mit6.s081] 笔记 Lab6: Copy-on-write fork | fork 懒拷贝</a><li><a href="/posts/mysql-prepare-slower-query-bug-analyze/">MySQL Prepare后语句查询性能降低 内核源码bug排查分析</a></ul></div><div id="access-tags"><div class="panel-heading">Trending Tags</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/operating-system/">operating system</a> <a class="post-tag" href="/tags/chinese/">Chinese</a> <a class="post-tag" href="/tags/system-design/">system design</a> <a class="post-tag" href="/tags/c/">C++</a> <a class="post-tag" href="/tags/course-recommendation/">course recommendation</a> <a class="post-tag" href="/tags/grpc/">gRPC</a> <a class="post-tag" href="/tags/translated/">translated</a> <a class="post-tag" href="/tags/announcement/">announcement</a> <a class="post-tag" href="/tags/c-standard/">c++ standard</a> <a class="post-tag" href="/tags/computer-system/">computer system</a></div></div><div id="access-links" class="post"><div class="panel-heading">Links</div><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="http://0xffff.one">0xffff.one 搬砖技术社区</a><li><a href="https://blog.izgq.net">ZGQ's Blog</a></ul></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"><div class="panel-heading pl-3 pt-2 mb-2">Contents</div><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div id="tail-wrapper" class="col-12 col-lg-11 col-xl-9 pl-3 pr-3 pr-xl-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/cn-so-difference-between-sync-and-async-grpc/"><div class="card-body"> <em class="small" data-ts="1629472140" data-df="ll" > Aug 20, 2021 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>[StackOverflow] C++ gRPC 异步 API 实例与优势</h3><div class="text-muted small"><p> 转自 我的一个 StackOverflow 回答。因为答案比较长，而且感觉比较有意义，就翻译成了中文发了出来。 原问题: 我正在用 gRPC 构建一个要求高吞吐量的服务。但是我现在用 C++ 同步式 gRPC 编写的程序的吞吐量并不高。 我已经读过了 gRPC 文档，但是我并没有找到对于同步/异步 API 的区别的清晰解释。我只知道异步 API 可以控制完成队列（...</p></div></div></a></div><div class="card"> <a href="/posts/cpp-ios-base-fixed-precision-loss/"><div class="card-body"> <em class="small" data-ts="1614168480" data-df="ll" > Feb 24, 2021 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>问题分析：ios_base::fixed 导致输出精度丢失？</h3><div class="text-muted small"><p> 这篇文章是来自我在 0xffff.one 上的一个帖子 https://0xffff.one/d/911/ 的回复。 原帖内容： 百度说是这行代码的作用是使用定点输出，同时输出小数点后6位(我试了好多数，仍然表示很迷) 为什么有这行代码有时候求两个数加减乘除的结果就不对，没有这行代码就对呢 比如55.25+11.17有上面那行代码结果是66.419998，没有就是66...</p></div></div></a></div><div class="card"> <a href="/posts/postgresql-source-compilation-guide/"><div class="card-body"> <em class="small" data-ts="1646323691" data-df="ll" > Mar 4, 2022 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>[SZU] 数据库内核课程 PostgreSQL 12.5 源码安装避坑 guide</h3><div class="text-muted small"><p> 课程：2022 年下学期，秦建斌老师的《数据库内核原理与实现》课程。 示例环境：Ubuntu 20.04 LTS PostgreSQL 版本： 12.5 1. 准备 linux 环境/虚拟机/或Windows下使用wsl Linux/Mac 用户可直接编译，Windows 用户自行搜索 wsl 教程配置后，剩余流程同 Linux 用户。 Mac 用户需要用其他方式（homebr...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/cn-so-difference-between-sync-and-async-grpc/" class="btn btn-outline-primary" prompt="Older"><p>[StackOverflow] C++ gRPC 异步 API 实例与优势</p></a> <a href="/posts/s081-lab1-unix-utilities/" class="btn btn-outline-primary" prompt="Newer"><p>[mit6.s081] 笔记 Lab1: Unix utilities | Unix 实用工具</p></a></div><script type="text/javascript"> $(function () { const origin = "https://giscus.app"; const iframe = "iframe.giscus-frame"; const lightTheme = "light"; const darkTheme = "dark_dimmed"; let initTheme = lightTheme; if ($("html[data-mode=dark]").length > 0 || ($("html[data-mode]").length == 0 && window.matchMedia("(prefers-color-scheme: dark)").matches)) { initTheme = darkTheme; } let giscusAttributes = { "src": "https://giscus.app/client.js", "data-repo": "Miigon/blog", "data-repo-id": "MDEwOlJlcG9zaXRvcnkzMjI1MjkwNzA=", "data-category": "BlogComments", "data-category-id": "DIC_kwDOEzlnLs4CQ6Y4", "data-mapping": "pathname", "data-reactions-enabled": "1", "data-emit-metadata": "0", "data-theme": initTheme, "data-input-position": "top", "data-lang": "en", "crossorigin": "anonymous", "async": "" }; let giscusScript = document.createElement("script"); Object.entries(giscusAttributes).forEach(([key, value]) => giscusScript.setAttribute(key, value)); document.getElementById("tail-wrapper").prepend(giscusScript); addEventListener("message", (event) => { if (event.source === window && event.data && event.data.direction === ModeToggle.ID) { /* global theme mode changed */ const mode = event.data.message; const theme = (mode === ModeToggle.DARK_MODE ? darkTheme : lightTheme); const message = { setConfig: { theme: theme } }; const giscus = document.querySelector(iframe).contentWindow; giscus.postMessage({ giscus: message }, origin); } }); }); </script></div></div><footer class="row pl-3 pr-3"><div class="col-12 d-flex justify-content-between align-items-center text-muted pl-0 pr-0"><div class="footer-left"><p class="mb-0"> © 2023 <a href="https://github.com/Miigon">Miigon</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Customized Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><div id="access-tags"><div class="panel-heading">Trending Tags</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/operating-system/">operating system</a> <a class="post-tag" href="/tags/chinese/">Chinese</a> <a class="post-tag" href="/tags/system-design/">system design</a> <a class="post-tag" href="/tags/c/">C++</a> <a class="post-tag" href="/tags/course-recommendation/">course recommendation</a> <a class="post-tag" href="/tags/grpc/">gRPC</a> <a class="post-tag" href="/tags/translated/">translated</a> <a class="post-tag" href="/tags/announcement/">announcement</a> <a class="post-tag" href="/tags/c-standard/">c++ standard</a> <a class="post-tag" href="/tags/computer-system/">computer system</a></div></div></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a><div id="notification" class="toast" role="alert" aria-live="assertive" aria-atomic="true" data-animation="true" data-autohide="false"><div class="toast-header"> <button type="button" class="ml-2 ml-auto close" data-dismiss="toast" aria-label="Close"> <span aria-hidden="true">&times;</span> </button></div><div class="toast-body text-center pt-0"><p class="pl-2 pr-2 mb-3">A new version of content is available.</p><button type="button" class="btn btn-primary" aria-label="Update"> Update </button></div></div><script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No results found.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/magnific-popup@1/dist/jquery.magnific-popup.min.js,npm/lozad/dist/lozad.min.js,npm/clipboard@2/dist/clipboard.min.js"></script> <script src="https://cdn.jsdelivr.net/combine/npm/dayjs@1/dayjs.min.js,npm/dayjs@1/locale/en.min.js,npm/dayjs@1/plugin/relativeTime.min.js,npm/dayjs@1/plugin/localizedFormat.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.bundle.min.js"></script> <script defer src="/app.js"></script>
