---
title: "[mit6.s081] ç¬”è®° Lab8: Locks | é”"
date: 2021-10-15 22:48:00 +0800
categories: [Course Notes, MIT6.S081]
tags: [operating system]
---
> è¿™æ˜¯æˆ‘è‡ªå­¦ MIT6.S081 æ“ä½œç³»ç»Ÿè¯¾ç¨‹çš„ lab ä»£ç ç¬”è®°ç¬¬å…«ç¯‡ï¼šLocksã€‚æ­¤ lab å¤§è‡´è€—æ—¶ï¼š14å°æ—¶ã€‚  
> 
> è¯¾ç¨‹åœ°å€ï¼š[https://pdos.csail.mit.edu/6.S081/2020/schedule.html](https://pdos.csail.mit.edu/6.S081/2020/schedule.html)  
> Lab åœ°å€ï¼š[https://pdos.csail.mit.edu/6.S081/2020/labs/lock.html](https://pdos.csail.mit.edu/6.S081/2020/labs/lock.html)  
> æˆ‘çš„ä»£ç åœ°å€ï¼š[https://github.com/Miigon/my-xv6-labs-2020/tree/lock](https://github.com/Miigon/my-xv6-labs-2020/tree/lock)  
> Commits: [https://github.com/Miigon/my-xv6-labs-2020/commits/lock](https://github.com/Miigon/my-xv6-labs-2020/commits/lock)  
> 
> æœ¬æ–‡ä¸­ä»£ç æ³¨é‡Šæ˜¯ç¼–å†™åšå®¢çš„æ—¶å€™åŠ å…¥çš„ï¼ŒåŸä»“åº“ä¸­çš„ä»£ç å¯èƒ½ç¼ºä¹æ³¨é‡Šæˆ–ä»£ç ä¸å®Œå…¨ç›¸åŒã€‚  

# Lab 8: Locks

é‡æ–°è®¾è®¡ä»£ç ä»¥é™ä½é”ç«äº‰ï¼Œæé«˜å¤šæ ¸æœºå™¨ä¸Šç³»ç»Ÿçš„å¹¶è¡Œæ€§ã€‚

## Memory allocator (moderate)

é€šè¿‡æ‹†åˆ† kmem ä¸­çš„ç©ºé—²å†…å­˜é“¾è¡¨ï¼Œé™ä½ kalloc å®ç°ä¸­çš„ kmem é”ç«äº‰ã€‚

### åŸç†ä¸åˆ†æ

kalloc åŸæœ¬çš„å®ç°ä¸­ï¼Œä½¿ç”¨ freelist é“¾è¡¨ï¼Œå°†ç©ºé—²ç‰©ç†é¡µ**æœ¬èº«**ç›´æ¥ç”¨ä½œé“¾è¡¨é¡¹ï¼ˆè¿™æ ·å¯ä»¥ä¸ä½¿ç”¨é¢å¤–ç©ºé—´ï¼‰è¿æ¥æˆä¸€ä¸ªé“¾è¡¨ï¼Œåœ¨åˆ†é…çš„æ—¶å€™ï¼Œå°†ç‰©ç†é¡µä»é“¾è¡¨ä¸­ç§»é™¤ï¼Œå›æ”¶æ—¶å°†ç‰©ç†é¡µæ”¾å›é“¾è¡¨ä¸­ã€‚

```c
// kernel/kalloc.c
struct {
  struct spinlock lock;
  struct run *freelist;
} kmem;
```

åˆ†é…ç‰©ç†é¡µçš„å®ç°ï¼ˆåŸç‰ˆï¼‰ï¼š
```c
// kernel/kalloc.c
void *
kalloc(void)
{
  struct run *r;

  acquire(&kmem.lock);
  r = kmem.freelist; // å–å‡ºä¸€ä¸ªç‰©ç†é¡µã€‚é¡µè¡¨é¡¹æœ¬èº«å°±æ˜¯ç‰©ç†é¡µã€‚
  if(r)
    kmem.freelist = r->next;
  release(&kmem.lock);

  if(r)
    memset((char*)r, 5, PGSIZE); // fill with junk
  return (void*)r;
}

```

åœ¨è¿™é‡Œæ— è®ºæ˜¯åˆ†é…ç‰©ç†é¡µæˆ–é‡Šæ”¾ç‰©ç†é¡µï¼Œéƒ½éœ€è¦ä¿®æ”¹ freelist é“¾è¡¨ã€‚ç”±äºä¿®æ”¹æ˜¯å¤šæ­¥æ“ä½œï¼Œä¸ºäº†ä¿æŒå¤šçº¿ç¨‹ä¸€è‡´æ€§ï¼Œå¿…é¡»åŠ é”ã€‚ä½†è¿™æ ·çš„è®¾è®¡ä¹Ÿä½¿å¾—å¤šçº¿ç¨‹æ— æ³•å¹¶å‘ç”³è¯·å†…å­˜ï¼Œé™åˆ¶äº†å¹¶å‘æ•ˆç‡ã€‚

è¯æ®æ˜¯ kmem é”ä¸Šé¢‘ç¹çš„é”ç«äº‰ï¼š

```text
$ kalloctest
start test1
test1 results:
--- lock kmem/bcache stats
lock: kmem: #fetch-and-add 83375 #acquire() 433015
lock: bcache: #fetch-and-add 0 #acquire() 1260
--- top 5 contended locks:
lock: kmem: #fetch-and-add 83375 #acquire() 433015  // kmem æ˜¯æ•´ä¸ªç³»ç»Ÿä¸­ç«äº‰æœ€æ¿€çƒˆçš„é”
lock: proc: #fetch-and-add 23737 #acquire() 130718
lock: virtio_disk: #fetch-and-add 11159 #acquire() 114
lock: proc: #fetch-and-add 5937 #acquire() 130786
lock: proc: #fetch-and-add 4080 #acquire() 130786
tot= 83375
test1 FAIL
```

è¿™é‡Œä½“ç°äº†ä¸€ä¸ªå…ˆ profile å†è¿›è¡Œä¼˜åŒ–çš„æ€è·¯ã€‚å¦‚æœä¸€ä¸ªå¤§é”å¹¶ä¸ä¼šå¼•èµ·æ˜æ˜¾çš„æ€§èƒ½é—®é¢˜ï¼Œæœ‰æ—¶å€™å¤§é”å°±è¶³å¤Ÿäº†ã€‚åªæœ‰åœ¨ä¸‡åˆ†ç¡®å®šæ€§èƒ½çƒ­ç‚¹æ˜¯åœ¨è¯¥é”çš„æ—¶å€™æ‰è¿›è¡Œä¼˜åŒ–ï¼Œã€Œè¿‡æ—©ä¼˜åŒ–æ˜¯ä¸‡æ¶ä¹‹æºã€ã€‚

è¿™é‡Œè§£å†³æ€§èƒ½çƒ­ç‚¹çš„æ€è·¯æ˜¯ã€Œå°†å…±äº«èµ„æºå˜ä¸ºä¸å…±äº«èµ„æºã€ã€‚é”ç«äº‰ä¼˜åŒ–ä¸€èˆ¬æœ‰å‡ ä¸ªæ€è·¯ï¼š
- åªåœ¨å¿…é¡»å…±äº«çš„æ—¶å€™å…±äº«ï¼ˆå¯¹åº”ä¸ºå°†èµ„æºä» CPU å…±äº«æ‹†åˆ†ä¸ºæ¯ä¸ª CPU ç‹¬ç«‹ï¼‰
- å¿…é¡»å…±äº«æ—¶ï¼Œå°½é‡å‡å°‘åœ¨å…³é”®åŒºä¸­åœç•™çš„æ—¶é—´ï¼ˆå¯¹åº”â€œå¤§é”åŒ–å°é”â€ï¼Œé™ä½é”çš„ç²’åº¦ï¼‰

è¯¥ lab çš„å®éªŒç›®æ ‡ï¼Œå³æ˜¯ä¸ºæ¯ä¸ª CPU åˆ†é…ç‹¬ç«‹çš„ freelistï¼Œè¿™æ ·å¤šä¸ª CPU å¹¶å‘åˆ†é…ç‰©ç†é¡µå°±ä¸å†ä¼šäº’ç›¸æ’æ–¥äº†ï¼Œæé«˜äº†å¹¶è¡Œæ€§ã€‚

ä½†ç”±äºåœ¨ä¸€ä¸ª CPU freelist ä¸­ç©ºé—²é¡µä¸è¶³çš„æƒ…å†µä¸‹ï¼Œä»éœ€è¦ä»å…¶ä»– CPU çš„ freelist ä¸­â€œå·â€å†…å­˜é¡µï¼Œæ‰€ä»¥ä¸€ä¸ª CPU çš„ freelist å¹¶ä¸æ˜¯åªä¼šè¢«å…¶å¯¹åº” CPU è®¿é—®ï¼Œè¿˜å¯èƒ½åœ¨â€œå·â€å†…å­˜é¡µçš„æ—¶å€™è¢«å…¶ä»– CPU è®¿é—®ï¼Œæ•…ä»ç„¶éœ€è¦ä½¿ç”¨å•ç‹¬çš„é”æ¥ä¿æŠ¤æ¯ä¸ª CPU çš„ freelistã€‚ä½†ä¸€ä¸ª CPU freelist ä¸­ç©ºé—²é¡µä¸è¶³çš„æƒ…å†µç›¸å¯¹æ¥è¯´æ˜¯æ¯”è¾ƒç¨€æœ‰çš„ï¼Œæ‰€ä»¥æ€»ä½“æ€§èƒ½ä¾ç„¶æ¯”å•ç‹¬ kmem å¤§é”è¦å¿«ã€‚åœ¨æœ€ä½³æƒ…å†µä¸‹ï¼Œä¹Ÿå°±æ˜¯æ²¡æœ‰å‘ç”Ÿè·¨ CPU â€œå·â€é¡µçš„æƒ…å†µä¸‹ï¼Œè¿™äº›å°é”ä¸ä¼šå‘ç”Ÿä»»ä½•é”ç«äº‰ã€‚

### ä»£ç å®ç°

```c
// kernel/kalloc.c
struct {
  struct spinlock lock;
  struct run *freelist;
} kmem[NCPU]; // ä¸ºæ¯ä¸ª CPU åˆ†é…ç‹¬ç«‹çš„ freelistï¼Œå¹¶ç”¨ç‹¬ç«‹çš„é”ä¿æŠ¤å®ƒã€‚

char *kmem_lock_names[] = {
  "kmem_cpu_0",
  "kmem_cpu_1",
  "kmem_cpu_2",
  "kmem_cpu_3",
  "kmem_cpu_4",
  "kmem_cpu_5",
  "kmem_cpu_6",
  "kmem_cpu_7",
};

void
kinit()
{
  for(int i=0;i<NCPU;i++) { // åˆå§‹åŒ–æ‰€æœ‰é”
    initlock(&kmem[i].lock, kmem_lock_names[i]);
  }
  freerange(end, (void*)PHYSTOP);
}

```

```c
// kernel/kalloc.c
void
kfree(void *pa)
{
  struct run *r;

  if(((uint64)pa % PGSIZE) != 0 || (char*)pa < end || (uint64)pa >= PHYSTOP)
    panic("kfree");

  // Fill with junk to catch dangling refs.
  memset(pa, 1, PGSIZE);

  r = (struct run*)pa;

  push_off();

  int cpu = cpuid();

  acquire(&kmem[cpu].lock);
  r->next = kmem[cpu].freelist;
  kmem[cpu].freelist = r;
  release(&kmem[cpu].lock);

  pop_off();
}

void *
kalloc(void)
{
  struct run *r;

  push_off();

  int cpu = cpuid();

  acquire(&kmem[cpu].lock);

  if(!kmem[cpu].freelist) { // no page left for this cpu
    int steal_left = 64; // steal 64 pages from other cpu(s)
    for(int i=0;i<NCPU;i++) {
      if(i == cpu) continue; // no self-robbery
      acquire(&kmem[i].lock);
      struct run *rr = kmem[i].freelist;
      while(rr && steal_left) {
        kmem[i].freelist = rr->next;
        rr->next = kmem[cpu].freelist;
        kmem[cpu].freelist = rr;
        rr = kmem[i].freelist;
        steal_left--;
      }
      release(&kmem[i].lock);
      if(steal_left == 0) break; // done stealing
    }
  }

  r = kmem[cpu].freelist;
  if(r)
    kmem[cpu].freelist = r->next;
  release(&kmem[cpu].lock);

  pop_off();

  if(r)
    memset((char*)r, 5, PGSIZE); // fill with junk
  return (void*)r;
}

```

è¿™é‡Œé€‰æ‹©åœ¨å†…å­˜é¡µä¸è¶³çš„æ—¶å€™ï¼Œä»å…¶ä»–çš„ CPU â€œå·â€ 64 ä¸ªé¡µï¼Œè¿™é‡Œçš„æ•°å€¼æ˜¯éšæ„å–çš„ï¼Œåœ¨ç°å®åœºæ™¯ä¸­ï¼Œæœ€å¥½è¿›è¡Œæµ‹é‡åé€‰å–åˆé€‚çš„æ•°å€¼ï¼Œå°½é‡ä½¿å¾—â€œå·â€é¡µé¢‘ç‡ä½ã€‚

å†æ¬¡è¿è¡Œ kalloctestï¼š

```text
$ kalloctest
start test1
test1 results:
--- lock kmem/bcache stats
lock: kmem_cpu_0: #fetch-and-add 0 #acquire() 35979
lock: kmem_cpu_1: #fetch-and-add 0 #acquire() 195945
lock: kmem_cpu_2: #fetch-and-add 0 #acquire() 201094
lock: bcache: #fetch-and-add 0 #acquire() 1248
--- top 5 contended locks:
lock: proc: #fetch-and-add 22486 #acquire() 132299
lock: virtio_disk: #fetch-and-add 16002 #acquire() 114
lock: proc: #fetch-and-add 11199 #acquire() 132301
lock: proc: #fetch-and-add 5330 #acquire() 132322
lock: proc: #fetch-and-add 4874 #acquire() 132345
tot= 0
test1 OK
start test2
total free number of pages: 32499 (out of 32768)
.....
test2 OK
```

å¯ä»¥çœ‹åˆ°ï¼Œkmem å¸¦æ¥çš„é”ç«äº‰é™ä½åˆ°äº† 0ï¼ˆä»åŸæœ¬çš„ ~83375ï¼‰ã€‚

## Buffer cache (hard)

> If multiple processes use the file system intensively, they will likely contend for bcache.lock, which protects the disk block cache in kernel/bio.c. bcachetest creates several processes that repeatedly read different files in order to generate contention on bcache.lock;

å¤šä¸ªè¿›ç¨‹åŒæ—¶ä½¿ç”¨æ–‡ä»¶ç³»ç»Ÿçš„æ—¶å€™ï¼Œbcache.lock ä¸Šä¼šå‘ç”Ÿä¸¥é‡çš„é”ç«äº‰ã€‚bcache.lock é”ç”¨äºä¿æŠ¤ç£ç›˜åŒºå—ç¼“å­˜ï¼Œåœ¨åŸæœ¬çš„è®¾è®¡ä¸­ï¼Œç”±äºè¯¥é”çš„å­˜åœ¨ï¼Œå¤šä¸ªè¿›ç¨‹ä¸èƒ½åŒæ—¶æ“ä½œï¼ˆç”³è¯·ã€é‡Šæ”¾ï¼‰ç£ç›˜ç¼“å­˜ã€‚

### åŸç†

å› ä¸ºä¸åƒ kalloc ä¸­ä¸€ä¸ªç‰©ç†é¡µåˆ†é…åå°±åªå½’å•ä¸ªè¿›ç¨‹æ‰€ç®¡ï¼Œbcache ä¸­çš„åŒºå—ç¼“å­˜æ˜¯ä¼šè¢«å¤šä¸ªè¿›ç¨‹ï¼ˆè¿›ä¸€æ­¥åœ°ï¼Œè¢«å¤šä¸ª CPUï¼‰å…±äº«çš„ï¼ˆç”±äºå¤šä¸ªè¿›ç¨‹å¯ä»¥åŒæ—¶è®¿é—®åŒä¸€ä¸ªåŒºå—ï¼‰ã€‚æ‰€ä»¥ kmem ä¸­ä¸ºæ¯ä¸ª CPU é¢„å…ˆåˆ†å‰²ä¸€éƒ¨åˆ†ä¸“å±çš„é¡µçš„æ–¹æ³•åœ¨è¿™é‡Œæ˜¯è¡Œä¸é€šçš„ã€‚

å‰é¢æåˆ°çš„ï¼š
> é”ç«äº‰ä¼˜åŒ–ä¸€èˆ¬æœ‰å‡ ä¸ªæ€è·¯ï¼š
> - åªåœ¨å¿…é¡»å…±äº«çš„æ—¶å€™å…±äº«ï¼ˆå¯¹åº”ä¸ºå°†èµ„æºä» CPU å…±äº«æ‹†åˆ†ä¸ºæ¯ä¸ª CPU ç‹¬ç«‹ï¼‰
> - å¿…é¡»å…±äº«æ—¶ï¼Œå°½é‡å‡å°‘åœ¨å…³é”®åŒºä¸­åœç•™çš„æ—¶é—´ï¼ˆå¯¹åº”â€œå¤§é”åŒ–å°é”â€ï¼Œé™ä½é”çš„ç²’åº¦ï¼‰

åœ¨è¿™é‡Œï¼Œ bcache å±äºâ€œå¿…é¡»å…±äº«â€çš„æƒ…å†µï¼Œæ‰€ä»¥éœ€è¦ç”¨åˆ°ç¬¬äºŒä¸ªæ€è·¯ï¼Œé™ä½é”çš„ç²’åº¦ï¼Œç”¨æ›´ç²¾ç»†çš„é” scheme æ¥é™ä½å‡ºç°ç«äº‰çš„æ¦‚ç‡ã€‚

```c
// kernel/bio.c
struct {
  struct spinlock lock;
  struct buf buf[NBUF];

  // Linked list of all buffers, through prev/next.
  // Sorted by how recently the buffer was used.
  // head.next is most recent, head.prev is least.
  struct buf head;
} bcache;
```

åŸç‰ˆ xv6 çš„è®¾è®¡ä¸­ï¼Œä½¿ç”¨åŒå‘é“¾è¡¨å­˜å‚¨æ‰€æœ‰çš„åŒºå—ç¼“å­˜ï¼Œæ¯æ¬¡å°è¯•è·å–ä¸€ä¸ªåŒºå— blockno çš„æ—¶å€™ï¼Œä¼šéå†é“¾è¡¨ï¼Œå¦‚æœç›®æ ‡åŒºå—å·²ç»å­˜åœ¨ç¼“å­˜ä¸­åˆ™ç›´æ¥è¿”å›ï¼Œå¦‚æœä¸å­˜åœ¨åˆ™é€‰å–ä¸€ä¸ªæœ€è¿‘æœ€ä¹…æœªä½¿ç”¨çš„ï¼Œä¸”å¼•ç”¨è®¡æ•°ä¸º 0 çš„ buf å—ä½œä¸ºå…¶åŒºå—ç¼“å­˜ï¼Œå¹¶è¿”å›ã€‚

æ–°çš„æ”¹è¿›æ–¹æ¡ˆï¼Œå¯ä»¥**å»ºç«‹ä¸€ä¸ªä» blockno åˆ° buf çš„å“ˆå¸Œè¡¨ï¼Œå¹¶ä¸ºæ¯ä¸ªæ¡¶å•ç‹¬åŠ é”**ã€‚è¿™æ ·ï¼Œä»…æœ‰åœ¨ä¸¤ä¸ªè¿›ç¨‹åŒæ—¶è®¿é—®çš„åŒºå—åŒæ—¶å“ˆå¸Œåˆ°åŒä¸€ä¸ªæ¡¶çš„æ—¶å€™ï¼Œæ‰ä¼šå‘ç”Ÿé”ç«äº‰ã€‚å½“æ¡¶ä¸­çš„ç©ºé—² buf ä¸è¶³çš„æ—¶å€™ï¼Œä»å…¶ä»–çš„æ¡¶ä¸­è·å– bufã€‚

æ€è·¯ä¸Šæ˜¯å¾ˆç®€å•çš„ï¼Œä½†æ˜¯å…·ä½“å®ç°çš„æ—¶å€™ï¼Œéœ€è¦æ³¨æ„æ­»é”é—®é¢˜ã€‚è¿™é‡Œçš„è®¸å¤šæ­»é”é—®é¢˜æ¯”è¾ƒéšæ™¦ï¼Œè€Œä¸” bcachetest æµ‹è¯•ä¸å‡ºæ¥ï¼Œä½†æ˜¯åœ¨å®é™…è¿è¡Œçš„ç³»ç»Ÿä¸­ï¼Œæ˜¯æœ‰å¯èƒ½è§¦å‘æ­»é”çš„ã€‚ç½‘ä¸Šçœ‹è¿‡è®¸å¤šå…¶ä»–é€šè¿‡äº†çš„åŒå­¦çš„åšå®¢ï¼Œä»£ç ä¸­éƒ½æ²¡æœ‰æ³¨æ„åˆ°è¿™ä¸€ç‚¹ã€‚

### æ­»é”é—®é¢˜

è€ƒè™‘ä¸€ä¸‹æˆ‘ä»¬çš„æ–°è®¾è®¡ï¼Œé¦–å…ˆåœ¨ bcache ä¸­å®šä¹‰å“ˆå¸Œè¡¨ bufmapï¼Œå¹¶ä¸ºæ¯ä¸ªæ¡¶è®¾ç½®é”ï¼š
```c
// kernel/bio.h
struct {
  struct buf buf[NBUF];
  struct spinlock eviction_lock;

  // Hash map: dev and blockno to buf
  struct buf bufmap[NBUFMAP_BUCKET];
  struct spinlock bufmap_locks[NBUFMAP_BUCKET];
} bcache;
```

bget(uint dev, uint blockno) ä¸­ï¼Œé¦–å…ˆåœ¨ blockno å¯¹åº”æ¡¶ä¸­æ‰«æç¼“å­˜æ˜¯å¦å­˜åœ¨ï¼Œå¦‚æœä¸å­˜åœ¨ï¼Œåˆ™åœ¨**æ‰€æœ‰æ¡¶**ä¸­å¯»æ‰¾ä¸€ä¸ªæœ€è¿‘æœ€ä¹…æœªä½¿ç”¨çš„æ— å¼•ç”¨ bufï¼Œè¿›è¡Œç¼“å­˜é©±é€ï¼Œç„¶åå°†å…¶é‡æ–°ç§»åŠ¨åˆ° blockno å¯¹åº”çš„æ¡¶ä¸­ï¼ˆrehashï¼‰ï¼Œä½œä¸º blockno çš„ç¼“å­˜è¿”å›ã€‚

è¿™é‡Œå¾ˆå®¹æ˜“å°±ä¼šå†™å‡ºè¿™æ ·çš„ä»£ç ï¼š

```c
bget(dev, blockno) {
  key := hash(dev, blockno);

  acquire(bufmap_locks[key]); // è·å– key æ¡¶çš„é”
  
  // æŸ¥æ‰¾ blockno çš„ç¼“å­˜æ˜¯å¦å­˜åœ¨ï¼Œè‹¥æ˜¯ç›´æ¥è¿”å›ï¼Œè‹¥å¦ç»§ç»­æ‰§è¡Œ
  if(b := look_for_blockno_in(bufmap[key])) {
    b->refcnt++
    release(bufmap_locks[key]);
    return b;
  }

  // æŸ¥æ‰¾å¯é©±é€ç¼“å­˜ b
  
  least_recently := NULL;
  
  for i := [0, NBUFMAP_BUCKET) { // éå†æ‰€æœ‰çš„æ¡¶
    acquire(bufmap_locks[i]);    // è·å–ç¬¬ i æ¡¶çš„é”

    b := look_for_least_recently_used_with_no_ref(bufmap[key]);
    // å¦‚æœæ‰¾åˆ°æœªä½¿ç”¨æ—¶é—´æ›´é•¿çš„ç©ºé—²å—
    if(b.last_use < least_recently.last_use) {  
      least_recently := b;
    }

    release(bufmap_locks[i]);   // æŸ¥æ‰¾ç»“æŸåï¼Œé‡Šæ”¾ç¬¬ i æ¡¶çš„é”
  }

  b := least_recently;

  // é©±é€ b åŸæœ¬å­˜å‚¨çš„ç¼“å­˜ï¼ˆå°†å…¶ä»åŸæ¥çš„æ¡¶åˆ é™¤ï¼‰
  evict(b);

  // å°† b åŠ å…¥åˆ°æ–°çš„æ¡¶
  append(bucket[key], b);

  release(bufmap_locks[key]); // é‡Šæ”¾ key æ¡¶çš„é”

  // è®¾ç½® b çš„å„ä¸ªå±æ€§
  setup(b);
  return b;
}
```

ä¸Šé¢çš„ä»£ç çœ‹èµ·æ¥å¾ˆåˆç†ï¼Œä½†æ˜¯å´æœ‰ä¸¤ä¸ªé—®é¢˜ï¼Œä¸€ä¸ªå¯¼è‡´è¿è¡Œç»“æœå‡ºé”™ï¼Œä¸€ä¸ªå¯¼è‡´æ­»é”ã€‚

### é—®é¢˜1ï¼šå¯¼è‡´è¿è¡Œç»“æœå‡ºé”™

ç¬¬ä¸€ä¸ªé—®é¢˜æ¯”è¾ƒæ˜¾è€Œæ˜“è§ï¼Œåé¢è¿›è¡Œç¼“å­˜é©±é€çš„æ—¶å€™ï¼Œæ¯æ‰«æä¸€ä¸ªæ¡¶å‰ä¼šè·å–è¯¥æ¡¶çš„é”ï¼Œä½†æ˜¯æ¯æ‰«æå®Œä¸€ä¸ªæ¡¶ååˆé‡Šæ”¾äº†è¯¥æ¡¶çš„é”ã€‚**ä»é‡Šæ”¾é”çš„é‚£ä¸€ç¬é—´ï¼Œè·å–å‡ºæ¥çš„æœ€è¿‘æœ€ä¹…æœªä½¿ç”¨çš„ç©ºé—² buf å°±ä¸å†å¯é äº†**ã€‚å› ä¸ºåœ¨æˆ‘ä»¬é‡Šæ”¾ b åŸæ¥æ‰€åœ¨çš„æ¡¶çš„é”åï¼ˆ`release(bufmap_locks[i]);` åï¼‰ï¼Œä½†æ˜¯ä»åŸæ¡¶åˆ é™¤ b ä¹‹å‰ï¼ˆ`evict(b);` å‰ï¼‰ï¼Œå¦ä¸€ä¸ª CPU å®Œå…¨å¯èƒ½ä¼šè°ƒç”¨ bget è¯·æ±‚ bï¼Œä½¿å¾— b çš„å¼•ç”¨è®¡æ•°å˜ä¸ºä¸ä¸ºé›¶ã€‚æ­¤æ—¶æˆ‘ä»¬å¯¹ b è¿›è¡Œé©±é€å°±æ˜¯ä¸å®‰å…¨çš„äº†ã€‚

è§£å†³æ–¹æ³•ä¹Ÿå¹¶ä¸å¤æ‚ï¼Œåªéœ€è¦åœ¨æ‰«ææ¡¶çš„æ—¶å€™ï¼Œç¡®ä¿æ‰¾åˆ°æœ€è¿‘æœ€ä¹…æœªä½¿ç”¨çš„ç©ºé—² buf åï¼Œä¸é‡Šæ”¾æ¡¶é”ï¼Œç»§ç»­æŒæœ‰å…¶å¯¹åº”çš„æ¡¶çš„é”ç›´åˆ°é©±é€å®Œæˆå³å¯ã€‚

> è¿™é‡Œç»´æŠ¤çš„ä¸å˜é‡ï¼ˆinvariantï¼‰æ˜¯ï¼šã€Œæ‰«æåˆ°çš„ buf åœ¨é©±é€å®Œæˆå‰ä¿æŒå¯é©±é€ã€ï¼Œä»¥åŠã€Œæ¡¶ä¸­è‹¥å­˜åœ¨æŸä¸ªå—çš„ bufï¼Œåˆ™è¿™ä¸ª buf å¯ç”¨ï¼Œbgetå¯ä»¥ç›´æ¥è¿”å›è¿™ä¸ª bufã€ã€‚

```c
bget(dev, blockno) {
  acquire(bufmap_locks[key]); // è·å– key æ¡¶é”
  
  // æŸ¥æ‰¾ blockno çš„ç¼“å­˜æ˜¯å¦å­˜åœ¨ï¼Œè‹¥æ˜¯ç›´æ¥è¿”å›ï¼Œè‹¥å¦ç»§ç»­æ‰§è¡Œ
  if(b := look_for_blockno_in(bufmap[key])) {
    b->refcnt++
    release(bufmap_locks[key]);
    return b;
  }

  // ç¼“å­˜ä¸å­˜åœ¨ï¼ŒæŸ¥æ‰¾å¯é©±é€ç¼“å­˜ b
  
  least_recently := NULL;
  holding_bucket := -1;
  
  for i := [0, NBUFMAP_BUCKET) { // éå†æ‰€æœ‰çš„æ¡¶
    acquire(bufmap_locks[i]);    // è·å–ç¬¬ i æ¡¶çš„é”

    b := look_for_least_recently_used_with_no_ref(bufmap[key]);
    // å¦‚æœæ‰¾åˆ°æœªä½¿ç”¨æ—¶é—´æ›´é•¿çš„ç©ºé—²å—ï¼ˆæ–°çš„ least_recentlyï¼‰
    
    if(b.last_use >= least_recently.last_use) {
      release(bufmap_locks[i]);   // è¯¥æ¡¶ä¸­æ²¡æœ‰æ‰¾åˆ°æ–°çš„ least_recentlyï¼Œé‡Šæ”¾è¯¥æ¡¶çš„é”

    } else {
      // b.last_use < least_recently.last_use
      least_recently := b;

      // é‡Šæ”¾åŸæœ¬ holding çš„é”ï¼ˆholding_bucket < iï¼‰
      if(holding_bucket != -1 && holding_bucket != key) release(bufmap_locks[holding_bucket]);
      // ä¿æŒç¬¬ i æ¡¶çš„é”ä¸é‡Šæ”¾......
      holding_bucket := i;
    }
  }

  b := least_recently;

  // æ­¤æ—¶ï¼Œä»ç„¶æŒæœ‰ b æ‰€åœ¨çš„æ¡¶çš„é” bufmap_locks[holding_bucket]
  // é©±é€ b åŸæœ¬å­˜å‚¨çš„ç¼“å­˜ï¼ˆå°†å…¶ä»åŸæ¥çš„æ¡¶åˆ é™¤ï¼‰
  evict(b);
  release(bufmap_locks[holding_bucket]); // é©±é€åå†é‡Šæ”¾ b åŸæœ¬æ‰€åœ¨æ¡¶çš„é”

  // å°† b åŠ å…¥åˆ°æ–°çš„æ¡¶
  append(bucket[key], b);

  release(bufmap_locks[key]); // é‡Šæ”¾ key æ¡¶é”

  // è®¾ç½® b çš„å„ä¸ªå±æ€§
  setup(b);
  return b;
}
```

### é—®é¢˜2: å¯¼è‡´æ­»é”

è¿™é‡Œå‡ºç°çš„ç¬¬äºŒä¸ªé—®é¢˜å°±æ˜¯ï¼Œä¸€å¼€å§‹æˆ‘ä»¬åœ¨ blockno å¯¹åº”çš„æ¡¶ä¸­éå†æ£€æŸ¥ç¼“å­˜æ˜¯å¦å­˜åœ¨æ—¶ï¼Œè·å–äº†å®ƒçš„é”ã€‚è€Œåœ¨æˆ‘ä»¬å‘ç° blockno ä¸å­˜åœ¨ç¼“å­˜ä¸­ä¹‹åï¼Œéœ€è¦åœ¨æ‹¿ç€ key æ¡¶é”çš„åŒæ—¶ï¼Œ**éå†æ‰€æœ‰çš„æ¡¶å¹¶ä¾æ¬¡è·å–å®ƒä»¬æ¯ä¸ªçš„é”**ï¼Œè€ƒè™‘è¿™ç§æƒ…å†µï¼š
```text
å‡è®¾å—å· b1 çš„å“ˆå¸Œå€¼æ˜¯ 2ï¼Œå—å· b2 çš„å“ˆå¸Œå€¼æ˜¯ 5
å¹¶ä¸”ä¸¤ä¸ªå—åœ¨è¿è¡Œå‰éƒ½æ²¡æœ‰è¢«ç¼“å­˜
----------------------------------------
CPU1                  CPU2
----------------------------------------
bget(dev, b1)         bget(dev,b2)
    |                     |
    V                     V
è·å–æ¡¶ 2 çš„é”           è·å–æ¡¶ 5 çš„é”
    |                     |
    V                     V
ç¼“å­˜ä¸å­˜åœ¨ï¼Œéå†æ‰€æœ‰æ¡¶    ç¼“å­˜ä¸å­˜åœ¨ï¼Œéå†æ‰€æœ‰æ¡¶
    |                     |
    V                     V
  ......                éå†åˆ°æ¡¶ 2
    |                å°è¯•è·å–æ¡¶ 2 çš„é”
    |                     |
    V                     V
  éå†åˆ°æ¡¶ 5          æ¡¶ 2 çš„é”ç”± CPU1 æŒæœ‰ï¼Œç­‰å¾…é‡Šæ”¾
å°è¯•è·å–æ¡¶ 5 çš„é”
    |
    V
æ¡¶ 5 çš„é”ç”± CPU2 æŒæœ‰ï¼Œç­‰å¾…é‡Šæ”¾

!æ­¤æ—¶ CPU1 ç­‰å¾… CPU2ï¼Œè€Œ CPU2 åœ¨ç­‰å¾… CPU1ï¼Œé™·å…¥æ­»é”!

```

è¿™é‡Œï¼Œç”±äº CPU1 æŒæœ‰é” 2 çš„æƒ…å†µä¸‹å»ç”³è¯·é” 5ï¼Œè€Œ CPU2 æŒæœ‰é” 5 çš„æƒ…å†µä¸‹ç”³è¯·é” 2ï¼Œé€ æˆäº†**ç¯è·¯ç­‰å¾…**ã€‚

å¤ä¹ ä¸€ä¸‹æ­»é”çš„å››ä¸ªæ¡ä»¶ï¼š
1. äº’æ–¥ï¼ˆä¸€ä¸ªèµ„æºåœ¨ä»»ä½•æ—¶å€™åªèƒ½å±äºä¸€ä¸ªçº¿ç¨‹ï¼‰
2. è¯·æ±‚ä¿æŒï¼ˆçº¿ç¨‹åœ¨æ‹¿ç€ä¸€ä¸ªé”çš„æƒ…å†µä¸‹ï¼Œå»ç”³è¯·å¦ä¸€ä¸ªé”ï¼‰
3. ä¸å‰¥å¤ºï¼ˆå¤–åŠ›ä¸å¼ºåˆ¶å‰¥å¤ºä¸€ä¸ªçº¿ç¨‹å·²ç»æ‹¥æœ‰çš„èµ„æºï¼‰
4. ç¯è·¯ç­‰å¾…ï¼ˆè¯·æ±‚èµ„æºçš„é¡ºåºå½¢æˆäº†ä¸€ä¸ªç¯ï¼‰

åªè¦ç ´åäº†å››ä¸ªæ¡ä»¶ä¸­çš„ä»»ä½•ä¸€ä¸ªï¼Œå°±èƒ½ç ´åæ­»é”ã€‚ä¸ºäº†å°è¯•è§£å†³è¿™ä¸ªæ­»é”é—®é¢˜ï¼Œæˆ‘ä»¬è€ƒè™‘ç ´åæ¯ä¸€ä¸ªæ¡ä»¶çš„å¯è¡Œæ€§ï¼š
1. äº’æ–¥ï¼šåœ¨è¿™é‡Œä¸€ä¸ªæ¡¶åªèƒ½åŒæ—¶è¢«ä¸€ä¸ª CPUï¼ˆçº¿ç¨‹ï¼‰å¤„ç†ï¼Œäº’æ–¥æ¡ä»¶æ˜¯å¿…é¡»çš„ï¼Œæ— æ³•ç ´åã€‚
2. è¯·æ±‚ä¿æŒ
3. ä¸å‰¥å¤ºï¼šéå†æ¡¶çš„æ—¶å€™ï¼Œåœ¨ç¯è·¯è¯·æ±‚å‡ºç°æ—¶å¼ºè¡Œé‡Šæ”¾ä¸€æ–¹çš„é”ï¼Ÿå³ä½¿èƒ½æ£€æµ‹ï¼Œè¢«å¼ºåˆ¶é‡Šæ”¾é”çš„ä¸€æ–¹çš„ bget è¯·æ±‚ä¼šå¤±è´¥ï¼Œé€ æˆæ–‡ä»¶ç³»ç»Ÿç›¸å…³ç³»ç»Ÿè°ƒç”¨å¤±è´¥ï¼Œä¸å¯è¡Œã€‚
4. ç¯è·¯ç­‰å¾…ï¼šæ”¹å˜è®¿é—®é¡ºåºï¼Œæ¯”å¦‚æ°¸è¿œåªéå†å½“å‰ key å·¦ä¾§çš„æ¡¶ï¼Œä½¿å¾—æ— è®ºå¦‚ä½•è®¿é—®éƒ½ä¸ä¼šå‡ºç°ç¯è·¯ï¼Ÿå¯è§£å†³æ­»é”ï¼Œä½†å‡è®¾ blockno å“ˆå¸Œåˆ°ç¬¬ä¸€ä¸ªæ¡¶ï¼Œå¹¶ä¸” cache missed æ—¶ï¼Œå°†æ— æ³•è¿›è¡Œç¼“å­˜é©±é€æ¥è…¾å‡ºæ–°å—ä¾›å…¶ä½¿ç”¨ï¼ˆå› ä¸ºç¬¬ä¸€ä¸ªæ¡¶å·¦ä¾§æ²¡æœ‰ä»»ä½•æ¡¶ï¼‰ã€‚

ä»ã€Œäº’æ–¥ã€ã€ã€Œä¸å‰¥å¤ºã€å’Œã€Œç¯è·¯ç­‰å¾…ã€æ¡ä»¶å…¥æ‰‹éƒ½æ— æ³•è§£å†³è¿™ä¸ªæ­»é”é—®é¢˜ï¼Œé‚£åªèƒ½è€ƒè™‘ã€Œè¯·æ±‚ä¿æŒã€äº†ã€‚

è¿™é‡Œæ­»é”å‡ºç°çš„åŸå› æ˜¯æˆ‘ä»¬åœ¨æ‹¿ç€ä¸€ä¸ªé”çš„æƒ…å†µä¸‹ï¼Œå»å°è¯•ç”³è¯·å¦ä¸€ä¸ªé”ï¼Œå¹¶ä¸”è¯·æ±‚é¡ºåºå‡ºç°äº†ç¯è·¯ã€‚æ—¢ç„¶å¸¦ç¯è·¯çš„è¯·æ±‚é¡ºåºæ˜¯ä¸å¯é¿å…çš„ï¼Œé‚£å”¯ä¸€çš„é€‰é¡¹å°±æ˜¯**åœ¨ç”³è¯·ä»»ä½•å…¶ä»–æ¡¶é”ä¹‹å‰ï¼Œå…ˆæ”¾å¼ƒä¹‹å‰æŒæœ‰çš„ key çš„æ¡¶é”**ï¼Œåœ¨æ‰¾åˆ°å¹¶é©±é€æœ€è¿‘æœ€ä¹…æœªä½¿ç”¨çš„ç©ºé—²å— b åï¼Œå†é‡æ–°è·å– key çš„æ¡¶é”ï¼Œå°† b åŠ å…¥æ¡¶ã€‚

å¤§è‡´ä»£ç æ˜¯è¿™æ ·ï¼š

```c
bget(dev, blockno) {
  acquire(bufmap_locks[key]); // è·å– key æ¡¶é”
  
  // æŸ¥æ‰¾ blockno çš„ç¼“å­˜æ˜¯å¦å­˜åœ¨ï¼Œè‹¥æ˜¯ç›´æ¥è¿”å›ï¼Œè‹¥å¦ç»§ç»­æ‰§è¡Œ
  if(b := look_for_blockno_in(bufmap[key])) {
    b->refcnt++
    release(bufmap_locks[key]);
    return b;
  }

  release(bufmap_locks[key]); // å…ˆé‡Šæ”¾ key æ¡¶é”ï¼Œé˜²æ­¢æŸ¥æ‰¾é©±é€æ—¶å‡ºç°ç¯è·¯ç­‰å¾…

  // ç¼“å­˜ä¸å­˜åœ¨ï¼ŒæŸ¥æ‰¾å¯é©±é€ç¼“å­˜ b
  
  holding_bucket := -1;
  for i := [0, NBUFMAP_BUCKET) {
    acquire(bufmap_locks[i]); // è¯·æ±‚æ—¶ä¸æŒæœ‰ key æ¡¶é”ï¼Œä¸ä¼šå‡ºç°ç¯è·¯ç­‰å¾…
    if(b := look_for_least_recently_used_with_no_ref(bufmap[key])) {
      if(holding_bucket != -1) release(bufmap_locks[holding_bucket]);
      holding_bucket := i;
      // å¦‚æœæ‰¾åˆ°æ–°çš„æœªä½¿ç”¨æ—¶é—´æ›´é•¿çš„ç©ºé—²å—ï¼Œåˆ™å°†åŸæ¥çš„å—æ‰€å±æ¡¶çš„é”é‡Šæ”¾æ‰ï¼Œä¿æŒæ–°å—æ‰€å±æ¡¶çš„é”...
    } else {
      release(bufmap_locks[holding_bucket]);
    }
  }

  // é©±é€ b åŸæœ¬å­˜å‚¨çš„ç¼“å­˜ï¼ˆå°†å…¶ä»åŸæ¥çš„æ¡¶åˆ é™¤ï¼‰
  evict(b);
  release(bufmap_locks[holding_bucket]); // é‡Šæ”¾ b åŸæ‰€åœ¨æ¡¶çš„é”

  acquire(bufmap_locks[key]); // å†æ¬¡è·å– key æ¡¶é”
  append(b, bucket[key]);     // å°† b åŠ å…¥åˆ°æ–°çš„æ¡¶
  release(bufmap_locks[key]); // é‡Šæ”¾ key æ¡¶é”


  // è®¾ç½® b çš„å„ä¸ªå±æ€§
  setup(b);
  return b;
}

```

è¿™æ ·ä»¥æ¥ï¼Œbget ä¸­æ— è®ºä»»ä½•ä½ç½®ï¼Œè·å–æ¡¶é”çš„æ—¶å€™éƒ½è¦ä¹ˆæ²¡æ‹¿å…¶ä»–é”ï¼Œè¦ä¹ˆåªæ‹¿äº†å…¶å·¦ä¾§çš„æ¡¶é”ï¼ˆéå†æ‰€æœ‰æ¡¶æŸ¥æ‰¾å¯é©±é€ç¼“å­˜ b çš„è¿‡ç¨‹ä¸­ï¼Œå¯¹æ¡¶çš„éå†å›ºå®šä»å°åˆ°å¤§è®¿é—®ï¼‰ï¼Œæ‰€ä»¥æ°¸è¿œä¸ä¼šå‡ºç°ç¯è·¯ï¼Œæ­»é”å¾—åˆ°äº†é¿å…ã€‚ä½†æ˜¯è¿™æ ·çš„æ–¹æ¡ˆåˆä¼šå¸¦æ¥æ–°çš„é—®é¢˜ã€‚

### æ–°çš„é—®é¢˜

æ³¨æ„åˆ°æˆ‘ä»¬å¼€å§‹ã€Œæœç´¢æ‰€æœ‰æ¡¶å¯»æ‰¾å¯é©±é€çš„ bufã€è¿™ä¸ªè¿‡ç¨‹å‰ï¼Œä¸ºäº†é˜²æ­¢ç¯è·¯ç­‰å¾…ï¼Œè€Œé‡Šæ”¾äº† key çš„æ¡¶é”ï¼ˆkey ä¸ºè¯·æ±‚çš„ blockno çš„å“ˆå¸Œå€¼ï¼‰ï¼Œç›´åˆ°éå†æ‰€æœ‰æ¡¶å¹¶é©±é€æœ€è¿‘æœ€ä¹…æœªä½¿ç”¨çš„ç©ºé—² buf çš„è¿‡ç¨‹å®Œæˆåæ‰é‡æ–°è·å– key æ¡¶é”ã€‚é—®é¢˜åœ¨äºï¼Œåœ¨é‡Šæ”¾æ‰ key æ¡¶é”ä¹‹åï¼Œç¬¬ä¸€å—å…³é”®åŒºï¼ˆâ€œæŸ¥æ‰¾ blockno çš„ç¼“å­˜æ˜¯å¦å­˜åœ¨ï¼Œè‹¥æ˜¯ç›´æ¥è¿”å›ï¼Œè‹¥å¦ç»§ç»­æ‰§è¡Œâ€çš„åŒºåŸŸï¼‰å°±å¾—ä¸åˆ°é”ä¿æŠ¤äº†ã€‚è¿™æ„å‘³ç€åœ¨ã€Œé‡Šæ”¾æ‰ key æ¡¶é”åã€åˆ°ã€Œé‡æ–°è·å– key æ¡¶é”å‰ã€çš„è¿™ä¸ªé˜¶æ®µï¼Œä¹Ÿå°±æ˜¯æˆ‘ä»¬è¿›è¡Œé©±é€+é‡åˆ†é…æ—¶ï¼Œå¦å¤–ä¸€ä¸ª CPU å®Œå…¨æœ‰å¯èƒ½è®¿é—®åŒä¸€ä¸ª blocknoï¼Œè·å–åˆ° key çš„æ¡¶é”ï¼Œé€šè¿‡äº†ä¸€å¼€å§‹ã€Œç¼“å­˜ä¸å­˜åœ¨ã€çš„æµ‹è¯•ï¼Œç„¶åä¹Ÿè¿›å…¥åˆ°é©±é€+é‡åˆ†é…ä¸­ï¼Œå¯¼è‡´ã€Œä¸€ä¸ªåŒºå—æœ‰å¤šä»½ç¼“å­˜ã€çš„é”™è¯¯æƒ…å†µå‡ºç°ã€‚

æ€ä¹ˆä¿éšœåŒä¸€ä¸ªåŒºå—ä¸ä¼šæœ‰ä¸¤ä¸ªç¼“å­˜å‘¢ï¼Ÿ

è¿™ä¸ªé—®é¢˜ç›¸å¯¹æ¯”è¾ƒæ£˜æ‰‹ï¼Œæˆ‘ä»¬ç›®å‰çŸ¥é“çš„é™åˆ¶æ¡ä»¶æœ‰ï¼š
* åœ¨éå†æ¡¶æŸ¥æ‰¾å¯é©±é€ buf çš„è¿‡ç¨‹ä¸­ï¼Œä¸èƒ½æŒæœ‰ key çš„æ¡¶é”ï¼Œå¦åˆ™ä¼šå‡ºç°æ­»é”ã€‚
* åœ¨éå†æ¡¶æŸ¥æ‰¾å¯é©±é€ buf çš„è¿‡ç¨‹ä¸­ï¼Œä¸æŒæœ‰ key æ¡¶é”çš„è¯ï¼Œå¯èƒ½ä¼šæœ‰å…¶ä»– CPU è®¿é—®åŒä¸€ blocknoï¼Œå¹¶å®Œæˆé©±é€+é‡åˆ†é…ï¼Œå¯¼è‡´åŒä¸€ blockno è¢«é‡å¤ç¼“å­˜ã€‚

è¿™é‡Œä¸å¾—ä¸æ‰¿è®¤ï¼Œæˆ‘å¹¶æ²¡æœ‰æƒ³åˆ°ä»€ä¹ˆç‰¹åˆ«å¥½çš„æ–¹æ³•ï¼Œåªæƒ³åˆ°äº†ä¸€ä¸ªç‰ºç‰²ä¸€ç‚¹æ•ˆç‡ï¼Œä½†æ˜¯èƒ½ä¿è¯æç«¯æƒ…å†µä¸‹å®‰å…¨çš„æ–¹æ¡ˆï¼š

* æ·»åŠ  eviction_lockï¼Œå°†é©±é€+é‡åˆ†é…çš„è¿‡ç¨‹é™åˆ¶ä¸ºå•çº¿ç¨‹

  æ³¨æ„æ­¤å¤„åº”è¯¥å…ˆé‡Šæ”¾æ¡¶é”åï¼Œå†è·å– eviction_lockã€‚å†™åä¼šå¯¼è‡´ eviction_lock å’Œæ¡¶é”å‘ç”Ÿæ­»é”ã€‚ï¼ˆçº¿ç¨‹ 1 æ‹¿ç€æ¡¶ A é”è¯·æ±‚ eviction_lockï¼Œ çº¿ç¨‹ 2 æ‹¿ç€ eviction_lock é©±é€æ—¶éå†è¯·æ±‚åˆ°æ¡¶ A é”ï¼‰

  ```c
  bget(dev, blockno) {
    acquire(bufmap_locks[key]); // è·å– key æ¡¶é”
    
    // æŸ¥æ‰¾ blockno çš„ç¼“å­˜æ˜¯å¦å­˜åœ¨ï¼Œè‹¥æ˜¯ç›´æ¥è¿”å›ï¼Œè‹¥å¦ç»§ç»­æ‰§è¡Œ
    if(b := look_for_blockno_in(bufmap[key])) {
      b->refcnt++
      release(bufmap_locks[key]);
      return b;
    }
    
    // æ³¨æ„è¿™é‡Œçš„ acquire å’Œ release çš„é¡ºåº
    release(bufmap_locks[key]); // å…ˆé‡Šæ”¾ key æ¡¶é”ï¼Œé˜²æ­¢æŸ¥æ‰¾é©±é€æ—¶å‡ºç°ç¯è·¯æ­»é”
    acquire(eviction_lock);     // è·å¾—é©±é€é”ï¼Œé˜²æ­¢å¤šä¸ª CPU åŒæ—¶é©±é€å½±å“åç»­åˆ¤æ–­

    // ç¼“å­˜ä¸å­˜åœ¨ï¼ŒæŸ¥æ‰¾å¯é©±é€ç¼“å­˜ b
    
    // .......

    acquire(bufmap_locks[key]); // å†æ¬¡è·å– key æ¡¶é”
    append(b, bucket[key]);     // å°† b åŠ å…¥åˆ°æ–°çš„æ¡¶
    release(bufmap_locks[key]); // é‡Šæ”¾ key æ¡¶é”

    release(eviction_lock);     // é‡Šæ”¾é©±é€é”

    // è®¾ç½® b çš„å„ä¸ªå±æ€§
    setup(b);
    return b;
  }
  ```
* åœ¨è·å– eviction_lock ä¹‹åï¼Œé©¬ä¸Š**å†æ¬¡åˆ¤æ–­ blockno çš„ç¼“å­˜æ˜¯å¦å­˜åœ¨**ï¼Œè‹¥æ˜¯ç›´æ¥è¿”å›ï¼Œè‹¥å¦ç»§ç»­æ‰§è¡Œ
  ```c
  bget(dev, blockno) {
    acquire(bufmap_locks[key]); // è·å– key æ¡¶é”
    
    // æŸ¥æ‰¾ blockno çš„ç¼“å­˜æ˜¯å¦å­˜åœ¨ï¼Œè‹¥æ˜¯ç›´æ¥è¿”å›ï¼Œè‹¥å¦ç»§ç»­æ‰§è¡Œ
    if(b := look_for_blockno_in(bufmap[key])) {
      b->refcnt++
      release(bufmap_locks[key]);
      return b;
    }
    
    // æ³¨æ„è¿™é‡Œçš„ acquire å’Œ release çš„é¡ºåº
    release(bufmap_locks[key]); // å…ˆé‡Šæ”¾ key æ¡¶é”ï¼Œé˜²æ­¢æŸ¥æ‰¾é©±é€æ—¶å‡ºç°ç¯è·¯æ­»é”
    acquire(eviction_lock);     // è·å¾—é©±é€é”ï¼Œé˜²æ­¢å¤šä¸ª CPU åŒæ—¶é©±é€å½±å“åç»­åˆ¤æ–­

    // **å†æ¬¡æŸ¥æ‰¾ blockno çš„ç¼“å­˜æ˜¯å¦å­˜åœ¨**ï¼Œè‹¥æ˜¯ç›´æ¥è¿”å›ï¼Œè‹¥å¦ç»§ç»­æ‰§è¡Œ
    // è¿™é‡Œç”±äºæŒæœ‰ eviction_lockï¼Œæ²¡æœ‰ä»»ä½•å…¶ä»–çº¿ç¨‹èƒ½å¤Ÿè¿›è¡Œé©±é€æ“ä½œï¼Œæ‰€ä»¥
    // æ²¡æœ‰ä»»ä½•å…¶ä»–çº¿ç¨‹èƒ½å¤Ÿæ”¹å˜ bufmap[key] æ¡¶é“¾è¡¨çš„ç»“æ„ï¼Œæ‰€ä»¥è¿™é‡Œä¸äº‹å…ˆè·å–
    // å…¶ç›¸åº”æ¡¶é”è€Œç›´æ¥å¼€å§‹éå†æ˜¯å®‰å…¨çš„ã€‚
    if(b := look_for_blockno_in(bufmap[key])) {
      acquire(bufmap_locks[key]); // å¿…é¡»è·å–ï¼Œä¿æŠ¤éåŸå­æ“ä½œ `refcnt++`
      b->refcnt++
      release(bufmap_locks[key]);

      release(eviction_lock);
      return b;
    }

    // ç¼“å­˜ä¸å­˜åœ¨ï¼ŒæŸ¥æ‰¾å¯é©±é€ç¼“å­˜ b
    
    // .......

    acquire(bufmap_locks[key]); // å†æ¬¡è·å– key æ¡¶é”
    append(b, bucket[key]);     // å°† b åŠ å…¥åˆ°æ–°çš„æ¡¶
    release(bufmap_locks[key]); // é‡Šæ”¾ key æ¡¶é”

    release(eviction_lock);     // é‡Šæ”¾é©±é€é”

    // è®¾ç½® b çš„å„ä¸ªå±æ€§
    setup(b);
    return b;
  }
  ```

è¿™æ ·ä»¥æ¥ï¼Œå³ä½¿æœ‰å¤šä¸ªçº¿ç¨‹åŒæ—¶è¯·æ±‚åŒä¸€ä¸ª blocknoï¼Œå¹¶ä¸”æ‰€æœ‰çº¿ç¨‹éƒ½ç¢°å·§é€šè¿‡äº†ä¸€å¼€å§‹çš„ã€Œblockno çš„ç¼“å­˜æ˜¯å¦å­˜åœ¨ã€çš„åˆ¤æ–­ä¸”ç»“æœéƒ½ä¸ºã€Œç¼“å­˜ä¸å­˜åœ¨ã€ï¼Œåˆ™è¿›å…¥å— eviction_lock ä¿æŠ¤çš„é©±é€+é‡åˆ†é…åŒºä»£ç åï¼Œèƒ½å¤Ÿå®é™…è¿›è¡Œé©±é€+é‡åˆ†é…çš„ï¼Œä¹Ÿåªæœ‰ç¬¬ä¸€ä¸ªè¿›å…¥çš„çº¿ç¨‹ã€‚

ç¬¬ä¸€ä¸ªçº¿ç¨‹è¿›å…¥å¹¶é©±é€+é‡åˆ†é…å®Œæ¯•åæ‰é‡Šæ”¾ eviction_lockï¼Œæ­¤æ—¶ blockno çš„ç¼“å­˜å·²ç»ç”±ä¸å­˜åœ¨å˜ä¸ºå­˜åœ¨äº†ï¼Œåç»­çš„æ‰€æœ‰çº¿ç¨‹æ­¤æ—¶è¿›å…¥åéƒ½ä¼šè¢«ç¬¬äºŒæ¬¡ã€Œblockno ç¼“å­˜æ˜¯å¦å­˜åœ¨ã€çš„åˆ¤æ–­ä»£ç æ‹¦ä½ï¼Œå¹¶ç›´æ¥è¿”å›å·²åˆ†é…å¥½çš„ç¼“å­˜ bufï¼Œè€Œä¸ä¼šé‡å¤å¯¹åŒä¸€ä¸ª blockno è¿›è¡Œé©±é€+é‡åˆ†é…ã€‚

è¿™ä¹ˆåšçš„å¥½å¤„æ˜¯ï¼Œä¿è¯äº†æŸ¥æ‰¾è¿‡ç¨‹ä¸­ä¸ä¼šå‡ºç°æ­»é”ï¼Œå¹¶ä¸”ä¸ä¼šå‡ºç°æç«¯æƒ…å†µä¸‹ä¸€ä¸ªå—äº§ç”Ÿå¤šä¸ªç¼“å­˜çš„æƒ…å†µã€‚è€Œåå¤„æ˜¯ï¼Œå¼•å…¥äº†å…¨å±€ eviction_lockï¼Œä½¿å¾—åŸæœ¬å¯å¹¶å‘çš„éå†é©±é€è¿‡ç¨‹å¹¶å‘æ€§é™ä½äº†ã€‚å¹¶ä¸”æ¯ä¸€æ¬¡ cache miss çš„æ—¶å€™ï¼Œéƒ½ä¼šå¤šä¸€æ¬¡é¢å¤–çš„æ¡¶éå†å¼€é”€ã€‚

ç„¶è€Œï¼Œcache miss æœ¬èº«ï¼ˆhopefullyï¼‰ä¸ºæ¯”è¾ƒç¨€æœ‰äº‹ä»¶ï¼Œå¹¶ä¸”å¯¹äº cache miss çš„å—ï¼Œç”±äºåç»­éœ€è¦ä»**ç£ç›˜**ä¸­è¯»å…¥å…¶æ•°æ®ï¼Œç£ç›˜è¯»å…¥çš„è€—æ—¶å°†æ¯”ä¸€æ¬¡æ¡¶éå†çš„è€—æ—¶å¤šå¥½å‡ ä¸ªæ•°é‡çº§ï¼Œæ‰€ä»¥æˆ‘è®¤ä¸ºè¿™æ ·çš„æ–¹æ¡ˆçš„å¼€é”€è¿˜æ˜¯å¯ä»¥æ¥å—çš„ã€‚

### å®Œæ•´ä¼ªä»£ç 
```c
bget(dev, blockno) {
  acquire(bufmap_locks[key]); // è·å– key æ¡¶é”
  
  // æŸ¥æ‰¾ blockno çš„ç¼“å­˜æ˜¯å¦å­˜åœ¨ï¼Œè‹¥æ˜¯ç›´æ¥è¿”å›ï¼Œè‹¥å¦ç»§ç»­æ‰§è¡Œ
  if(b := look_for_blockno_in(bufmap[key])) {
    b->refcnt++
    release(bufmap_locks[key]);
    return b;
  }
  
  // æ³¨æ„è¿™é‡Œçš„ acquire å’Œ release çš„é¡ºåº
  release(bufmap_locks[key]); // å…ˆé‡Šæ”¾ key æ¡¶é”ï¼Œé˜²æ­¢æŸ¥æ‰¾é©±é€æ—¶å‡ºç°ç¯è·¯æ­»é”
  acquire(eviction_lock);     // è·å¾—é©±é€é”ï¼Œé˜²æ­¢å¤šä¸ª CPU åŒæ—¶é©±é€å½±å“åç»­åˆ¤æ–­

  // **å†æ¬¡æŸ¥æ‰¾ blockno çš„ç¼“å­˜æ˜¯å¦å­˜åœ¨**ï¼Œè‹¥æ˜¯ç›´æ¥è¿”å›ï¼Œè‹¥å¦ç»§ç»­æ‰§è¡Œ
  // è¿™é‡Œç”±äºæŒæœ‰ eviction_lockï¼Œæ²¡æœ‰ä»»ä½•å…¶ä»–çº¿ç¨‹èƒ½å¤Ÿè¿›è¡Œé©±é€æ“ä½œï¼Œæ‰€ä»¥
  // æ²¡æœ‰ä»»ä½•å…¶ä»–çº¿ç¨‹èƒ½å¤Ÿæ”¹å˜ bufmap[key] æ¡¶é“¾è¡¨çš„ç»“æ„ï¼Œæ‰€ä»¥è¿™é‡Œä¸äº‹å…ˆè·å–
  // å…¶ç›¸åº”æ¡¶é”è€Œç›´æ¥å¼€å§‹éå†æ˜¯å®‰å…¨çš„ã€‚
  if(b := look_for_blockno_in(bufmap[key])) {
    acquire(bufmap_locks[key]); // å¿…é¡»è·å–ï¼Œä¿æŠ¤éåŸå­æ“ä½œ `refcnt++`
    b->refcnt++
    release(bufmap_locks[key]);

    release(eviction_lock);
    return b;
  }

  // ç¼“å­˜ä¸å­˜åœ¨ï¼ŒæŸ¥æ‰¾å¯é©±é€ç¼“å­˜ b
  
  holding_bucket := -1; // å½“å‰æŒæœ‰çš„æ¡¶é”
  for i := [0, NBUFMAP_BUCKET) {
    acquire(bufmap_locks[i]); // è¯·æ±‚æ—¶ä¸æŒæœ‰ key æ¡¶é”ï¼Œä¸ä¼šå‡ºç°ç¯è·¯ç­‰å¾…
    if(b := look_for_least_recently_used_with_no_ref(bufmap[key])) {
      if(holding_bucket != -1) release(bufmap_locks[holding_bucket]);
      holding_bucket := i;
      // å¦‚æœæ‰¾åˆ°æ–°çš„æœªä½¿ç”¨æ—¶é—´æ›´é•¿çš„ç©ºé—²å—ï¼Œåˆ™å°†åŸæ¥çš„å—æ‰€å±æ¡¶çš„é”é‡Šæ”¾æ‰ï¼Œä¿æŒæ–°å—æ‰€å±æ¡¶çš„é”...
    } else {
      release(bufmap_locks[holding_bucket]);
    }
  }

  acquire(bufmap_locks[key]); // å†æ¬¡è·å– key æ¡¶é”
  append(b, bucket[key]);     // å°† b åŠ å…¥åˆ°æ–°çš„æ¡¶
  release(bufmap_locks[key]); // é‡Šæ”¾ key æ¡¶é”

  release(eviction_lock);     // é‡Šæ”¾é©±é€é”

  // è®¾ç½® b çš„å„ä¸ªå±æ€§
  setup(b);
  return b;
}

```
### å®Œæ•´ä»£ç 
```c
struct buf {
  int valid;   // has data been read from disk?
  int disk;    // does disk "own" buf?
  uint dev;
  uint blockno;
  struct sleeplock lock;
  uint refcnt;
  uint lastuse; // *newly added, used to keep track of the least-recently-used buf
  struct buf *next;
  uchar data[BSIZE];
};
```

```c
// kernel/bio.c

// bucket number for bufmap
#define NBUFMAP_BUCKET 13
// hash function for bufmap
#define BUFMAP_HASH(dev, blockno) ((((dev)<<27)|(blockno))%NBUFMAP_BUCKET)

struct {
  struct buf buf[NBUF];
  struct spinlock eviction_lock;

  // Hash map: dev and blockno to buf
  struct buf bufmap[NBUFMAP_BUCKET];
  struct spinlock bufmap_locks[NBUFMAP_BUCKET];
} bcache;

void
binit(void)
{
  // Initialize bufmap
  for(int i=0;i<NBUFMAP_BUCKET;i++) {
    initlock(&bcache.bufmap_locks[i], "bcache_bufmap");
    bcache.bufmap[i].next = 0;
  }

  // Initialize buffers
  for(int i=0;i<NBUF;i++){
    struct buf *b = &bcache.buf[i];
    initsleeplock(&b->lock, "buffer");
    b->lastuse = 0;
    b->refcnt = 0;
    // put all the buffers into bufmap[0]
    b->next = bcache.bufmap[0].next;
    bcache.bufmap[0].next = b;
  }

  initlock(&bcache.eviction_lock, "bcache_eviction");
}

// Look through buffer cache for block on device dev.
// If not found, allocate a buffer.
// In either case, return locked buffer.
static struct buf*
bget(uint dev, uint blockno)
{
  struct buf *b;

  uint key = BUFMAP_HASH(dev, blockno);

  acquire(&bcache.bufmap_locks[key]);

  // Is the block already cached?
  for(b = bcache.bufmap[key].next; b; b = b->next){
    if(b->dev == dev && b->blockno == blockno){
      b->refcnt++;
      release(&bcache.bufmap_locks[key]);
      acquiresleep(&b->lock);
      return b;
    }
  }

  // Not cached.

  // to get a suitable block to reuse, we need to search for one in all the buckets,
  // which means acquiring their bucket locks.
  // but it's not safe to try to acquire every single bucket lock while holding one.
  // it can easily lead to circular wait, which produces deadlock.

  release(&bcache.bufmap_locks[key]);
  // we need to release our bucket lock so that iterating through all the buckets won't
  // lead to circular wait and deadlock. however, as a side effect of releasing our bucket
  // lock, other cpus might request the same blockno at the same time and the cache buf for  
  // blockno might be created multiple times in the worst case. since multiple concurrent
  // bget requests might pass the "Is the block already cached?" test and start the 
  // eviction & reuse process multiple times for the same blockno.
  //
  // so, after acquiring eviction_lock, we check "whether cache for blockno is present"
  // once more, to be sure that we don't create duplicate cache bufs.
  acquire(&bcache.eviction_lock);

  // Check again, is the block already cached?
  // no other eviction & reuse will happen while we are holding eviction_lock,
  // which means no link list structure of any bucket can change.
  // so it's ok here to iterate through `bcache.bufmap[key]` without holding
  // it's cooresponding bucket lock, since we are holding a much stronger eviction_lock.
  for(b = bcache.bufmap[key].next; b; b = b->next){
    if(b->dev == dev && b->blockno == blockno){
      acquire(&bcache.bufmap_locks[key]); // must do, for `refcnt++`
      b->refcnt++;
      release(&bcache.bufmap_locks[key]);
      release(&bcache.eviction_lock);
      acquiresleep(&b->lock);
      return b;
    }
  }

  // Still not cached.
  // we are now only holding eviction lock, none of the bucket locks are held by us.
  // so it's now safe to acquire any bucket's lock without risking circular wait and deadlock.

  // find the one least-recently-used buf among all buckets.
  // finish with it's corresponding bucket's lock held.
  struct buf *before_least = 0; 
  uint holding_bucket = -1;
  for(int i = 0; i < NBUFMAP_BUCKET; i++){
    // before acquiring, we are either holding nothing, or only holding locks of
    // buckets that are *on the left side* of the current bucket
    // so no circular wait can ever happen here. (safe from deadlock)
    acquire(&bcache.bufmap_locks[i]);
    int newfound = 0; // new least-recently-used buf found in this bucket
    for(b = &bcache.bufmap[i]; b->next; b = b->next) {
      if(b->next->refcnt == 0 && (!before_least || b->next->lastuse < before_least->next->lastuse)) {
        before_least = b;
        newfound = 1;
      }
    }
    if(!newfound) {
      release(&bcache.bufmap_locks[i]);
    } else {
      if(holding_bucket != -1) release(&bcache.bufmap_locks[holding_bucket]);
      holding_bucket = i;
      // keep holding this bucket's lock....
    }
  }
  if(!before_least) {
    panic("bget: no buffers");
  }
  b = before_least->next;
  
  if(holding_bucket != key) {
    // remove the buf from it's original bucket
    before_least->next = b->next;
    release(&bcache.bufmap_locks[holding_bucket]);
    // rehash and add it to the target bucket
    acquire(&bcache.bufmap_locks[key]);
    b->next = bcache.bufmap[key].next;
    bcache.bufmap[key].next = b;
  }
  
  b->dev = dev;
  b->blockno = blockno;
  b->refcnt = 1;
  b->valid = 0;
  release(&bcache.bufmap_locks[key]);
  release(&bcache.eviction_lock);
  acquiresleep(&b->lock);
  return b;
}

// ......

// Release a locked buffer.
void
brelse(struct buf *b)
{
  if(!holdingsleep(&b->lock))
    panic("brelse");

  releasesleep(&b->lock);

  uint key = BUFMAP_HASH(b->dev, b->blockno);

  acquire(&bcache.bufmap_locks[key]);
  b->refcnt--;
  if (b->refcnt == 0) {
    b->lastuse = ticks;
  }
  release(&bcache.bufmap_locks[key]);
}

void
bpin(struct buf *b) {
  uint key = BUFMAP_HASH(b->dev, b->blockno);

  acquire(&bcache.bufmap_locks[key]);
  b->refcnt++;
  release(&bcache.bufmap_locks[key]);
}

void
bunpin(struct buf *b) {
  uint key = BUFMAP_HASH(b->dev, b->blockno);

  acquire(&bcache.bufmap_locks[key]);
  b->refcnt--;
  release(&bcache.bufmap_locks[key]);
}

```

### è¿è¡Œç»“æœ

```text
$ bcachetest
start test0
test0 results:
--- lock kmem/bcache stats
lock: kmem_cpu_0: #fetch-and-add 0 #acquire() 32897
lock: kmem_cpu_1: #fetch-and-add 0 #acquire() 77
lock: kmem_cpu_2: #fetch-and-add 0 #acquire() 61
lock: bcache_bufmap: #fetch-and-add 0 #acquire() 6400
lock: bcache_bufmap: #fetch-and-add 0 #acquire() 6685
lock: bcache_bufmap: #fetch-and-add 0 #acquire() 6696
lock: bcache_bufmap: #fetch-and-add 0 #acquire() 7018
lock: bcache_bufmap: #fetch-and-add 0 #acquire() 6266
lock: bcache_bufmap: #fetch-and-add 0 #acquire() 4206
lock: bcache_bufmap: #fetch-and-add 0 #acquire() 4206
lock: bcache_bufmap: #fetch-and-add 0 #acquire() 2193
lock: bcache_bufmap: #fetch-and-add 0 #acquire() 4202
lock: bcache_bufmap: #fetch-and-add 0 #acquire() 2196
lock: bcache_bufmap: #fetch-and-add 0 #acquire() 4359
lock: bcache_bufmap: #fetch-and-add 0 #acquire() 4409
lock: bcache_bufmap: #fetch-and-add 0 #acquire() 6411
lock: bcache_eviction: #fetch-and-add 0 #acquire() 83
--- top 5 contended locks:
lock: proc: #fetch-and-add 397110 #acquire() 70988
lock: proc: #fetch-and-add 262715 #acquire() 70988
lock: proc: #fetch-and-add 222165 #acquire() 70987
lock: virtio_disk: #fetch-and-add 161088 #acquire() 1098
lock: proc: #fetch-and-add 45459 #acquire() 71331
tot= 0
test0: OK
start test1
test1 OK
$
```

## å°ç»“

å¤šçº¿ç¨‹é—®é¢˜å¾€å¾€ä¸å¦‚å•çº¿ç¨‹ç¨‹åºä¸­çš„é—®é¢˜é‚£æ ·å®¹æ˜“å‘ç°ï¼Œå¹¶ä¸”éœ€è¦å¯¹åº•å±‚æŒ‡ä»¤å±‚é¢ä»¥åŠ CPU è¿è¡ŒåŸç†å±‚é¢æœ‰è¶³å¤Ÿçš„è®¤çŸ¥ï¼Œæ‰èƒ½æœ‰æ•ˆåœ°å‘ç°å¹¶è§£å†³å¤šçº¿ç¨‹é—®é¢˜ã€‚å¼•ç”¨ lecture ä¸­çš„å‡ ä¸ªå»ºè®®ä½œä¸ºç»“å°¾ï¼š
```
don't share if you don't have to
start with a few coarse-grained locks
instrument your code -- which locks are preventing parallelism?
use fine-grained locks only as needed for parallel performance
use an automated race detector
```

æœ€åæˆ‘è‡ªå·±çš„è¯ï¼š
```
multithreading is a painğŸ˜­ , only worth it if there is non-insignificant performance increase. 

maybe try multi-process architecture for your next project, so you don't have to deal with all the multithreading hassles. you get the bonus of being able to scale horizontally (and almost infinitely) as well :)
```